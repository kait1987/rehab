
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Gym
 * 
 */
export type Gym = $Result.DefaultSelection<Prisma.$GymPayload>
/**
 * Model GymFacility
 * 
 */
export type GymFacility = $Result.DefaultSelection<Prisma.$GymFacilityPayload>
/**
 * Model GymOperatingHour
 * 
 */
export type GymOperatingHour = $Result.DefaultSelection<Prisma.$GymOperatingHourPayload>
/**
 * Model GymCrowdLevel
 * 
 */
export type GymCrowdLevel = $Result.DefaultSelection<Prisma.$GymCrowdLevelPayload>
/**
 * Model ReviewTag
 * 
 */
export type ReviewTag = $Result.DefaultSelection<Prisma.$ReviewTagPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewTagMapping
 * 
 */
export type ReviewTagMapping = $Result.DefaultSelection<Prisma.$ReviewTagMappingPayload>
/**
 * Model BodyPart
 * 
 */
export type BodyPart = $Result.DefaultSelection<Prisma.$BodyPartPayload>
/**
 * Model EquipmentType
 * 
 */
export type EquipmentType = $Result.DefaultSelection<Prisma.$EquipmentTypePayload>
/**
 * Model ExerciseTemplate
 * 
 */
export type ExerciseTemplate = $Result.DefaultSelection<Prisma.$ExerciseTemplatePayload>
/**
 * Model ExerciseEquipmentMapping
 * 
 */
export type ExerciseEquipmentMapping = $Result.DefaultSelection<Prisma.$ExerciseEquipmentMappingPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseExercise
 * 
 */
export type CourseExercise = $Result.DefaultSelection<Prisma.$CourseExercisePayload>
/**
 * Model UserPainProfile
 * 
 */
export type UserPainProfile = $Result.DefaultSelection<Prisma.$UserPainProfilePayload>
/**
 * Model UserCourseHistory
 * 
 */
export type UserCourseHistory = $Result.DefaultSelection<Prisma.$UserCourseHistoryPayload>
/**
 * Model UserFavorite
 * 
 */
export type UserFavorite = $Result.DefaultSelection<Prisma.$UserFavoritePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gym`: Exposes CRUD operations for the **Gym** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gyms
    * const gyms = await prisma.gym.findMany()
    * ```
    */
  get gym(): Prisma.GymDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymFacility`: Exposes CRUD operations for the **GymFacility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymFacilities
    * const gymFacilities = await prisma.gymFacility.findMany()
    * ```
    */
  get gymFacility(): Prisma.GymFacilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymOperatingHour`: Exposes CRUD operations for the **GymOperatingHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymOperatingHours
    * const gymOperatingHours = await prisma.gymOperatingHour.findMany()
    * ```
    */
  get gymOperatingHour(): Prisma.GymOperatingHourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gymCrowdLevel`: Exposes CRUD operations for the **GymCrowdLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymCrowdLevels
    * const gymCrowdLevels = await prisma.gymCrowdLevel.findMany()
    * ```
    */
  get gymCrowdLevel(): Prisma.GymCrowdLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewTag`: Exposes CRUD operations for the **ReviewTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewTags
    * const reviewTags = await prisma.reviewTag.findMany()
    * ```
    */
  get reviewTag(): Prisma.ReviewTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewTagMapping`: Exposes CRUD operations for the **ReviewTagMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewTagMappings
    * const reviewTagMappings = await prisma.reviewTagMapping.findMany()
    * ```
    */
  get reviewTagMapping(): Prisma.ReviewTagMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bodyPart`: Exposes CRUD operations for the **BodyPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BodyParts
    * const bodyParts = await prisma.bodyPart.findMany()
    * ```
    */
  get bodyPart(): Prisma.BodyPartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentType`: Exposes CRUD operations for the **EquipmentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentTypes
    * const equipmentTypes = await prisma.equipmentType.findMany()
    * ```
    */
  get equipmentType(): Prisma.EquipmentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseTemplate`: Exposes CRUD operations for the **ExerciseTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseTemplates
    * const exerciseTemplates = await prisma.exerciseTemplate.findMany()
    * ```
    */
  get exerciseTemplate(): Prisma.ExerciseTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseEquipmentMapping`: Exposes CRUD operations for the **ExerciseEquipmentMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseEquipmentMappings
    * const exerciseEquipmentMappings = await prisma.exerciseEquipmentMapping.findMany()
    * ```
    */
  get exerciseEquipmentMapping(): Prisma.ExerciseEquipmentMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseExercise`: Exposes CRUD operations for the **CourseExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseExercises
    * const courseExercises = await prisma.courseExercise.findMany()
    * ```
    */
  get courseExercise(): Prisma.CourseExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPainProfile`: Exposes CRUD operations for the **UserPainProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPainProfiles
    * const userPainProfiles = await prisma.userPainProfile.findMany()
    * ```
    */
  get userPainProfile(): Prisma.UserPainProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCourseHistory`: Exposes CRUD operations for the **UserCourseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCourseHistories
    * const userCourseHistories = await prisma.userCourseHistory.findMany()
    * ```
    */
  get userCourseHistory(): Prisma.UserCourseHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorite`: Exposes CRUD operations for the **UserFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorites
    * const userFavorites = await prisma.userFavorite.findMany()
    * ```
    */
  get userFavorite(): Prisma.UserFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Gym: 'Gym',
    GymFacility: 'GymFacility',
    GymOperatingHour: 'GymOperatingHour',
    GymCrowdLevel: 'GymCrowdLevel',
    ReviewTag: 'ReviewTag',
    Review: 'Review',
    ReviewTagMapping: 'ReviewTagMapping',
    BodyPart: 'BodyPart',
    EquipmentType: 'EquipmentType',
    ExerciseTemplate: 'ExerciseTemplate',
    ExerciseEquipmentMapping: 'ExerciseEquipmentMapping',
    Course: 'Course',
    CourseExercise: 'CourseExercise',
    UserPainProfile: 'UserPainProfile',
    UserCourseHistory: 'UserCourseHistory',
    UserFavorite: 'UserFavorite',
    Event: 'Event',
    Patient: 'Patient'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "gym" | "gymFacility" | "gymOperatingHour" | "gymCrowdLevel" | "reviewTag" | "review" | "reviewTagMapping" | "bodyPart" | "equipmentType" | "exerciseTemplate" | "exerciseEquipmentMapping" | "course" | "courseExercise" | "userPainProfile" | "userCourseHistory" | "userFavorite" | "event" | "patient"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Gym: {
        payload: Prisma.$GymPayload<ExtArgs>
        fields: Prisma.GymFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          findFirst: {
            args: Prisma.GymFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          findMany: {
            args: Prisma.GymFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>[]
          }
          create: {
            args: Prisma.GymCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          createMany: {
            args: Prisma.GymCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>[]
          }
          delete: {
            args: Prisma.GymDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          update: {
            args: Prisma.GymUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          deleteMany: {
            args: Prisma.GymDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>[]
          }
          upsert: {
            args: Prisma.GymUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymPayload>
          }
          aggregate: {
            args: Prisma.GymAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGym>
          }
          groupBy: {
            args: Prisma.GymGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymCountArgs<ExtArgs>
            result: $Utils.Optional<GymCountAggregateOutputType> | number
          }
        }
      }
      GymFacility: {
        payload: Prisma.$GymFacilityPayload<ExtArgs>
        fields: Prisma.GymFacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymFacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymFacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>
          }
          findFirst: {
            args: Prisma.GymFacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymFacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>
          }
          findMany: {
            args: Prisma.GymFacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>[]
          }
          create: {
            args: Prisma.GymFacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>
          }
          createMany: {
            args: Prisma.GymFacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymFacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>[]
          }
          delete: {
            args: Prisma.GymFacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>
          }
          update: {
            args: Prisma.GymFacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>
          }
          deleteMany: {
            args: Prisma.GymFacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymFacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymFacilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>[]
          }
          upsert: {
            args: Prisma.GymFacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymFacilityPayload>
          }
          aggregate: {
            args: Prisma.GymFacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymFacility>
          }
          groupBy: {
            args: Prisma.GymFacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymFacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymFacilityCountArgs<ExtArgs>
            result: $Utils.Optional<GymFacilityCountAggregateOutputType> | number
          }
        }
      }
      GymOperatingHour: {
        payload: Prisma.$GymOperatingHourPayload<ExtArgs>
        fields: Prisma.GymOperatingHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymOperatingHourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymOperatingHourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>
          }
          findFirst: {
            args: Prisma.GymOperatingHourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymOperatingHourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>
          }
          findMany: {
            args: Prisma.GymOperatingHourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>[]
          }
          create: {
            args: Prisma.GymOperatingHourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>
          }
          createMany: {
            args: Prisma.GymOperatingHourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymOperatingHourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>[]
          }
          delete: {
            args: Prisma.GymOperatingHourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>
          }
          update: {
            args: Prisma.GymOperatingHourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>
          }
          deleteMany: {
            args: Prisma.GymOperatingHourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymOperatingHourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymOperatingHourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>[]
          }
          upsert: {
            args: Prisma.GymOperatingHourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymOperatingHourPayload>
          }
          aggregate: {
            args: Prisma.GymOperatingHourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymOperatingHour>
          }
          groupBy: {
            args: Prisma.GymOperatingHourGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymOperatingHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymOperatingHourCountArgs<ExtArgs>
            result: $Utils.Optional<GymOperatingHourCountAggregateOutputType> | number
          }
        }
      }
      GymCrowdLevel: {
        payload: Prisma.$GymCrowdLevelPayload<ExtArgs>
        fields: Prisma.GymCrowdLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymCrowdLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymCrowdLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>
          }
          findFirst: {
            args: Prisma.GymCrowdLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymCrowdLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>
          }
          findMany: {
            args: Prisma.GymCrowdLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>[]
          }
          create: {
            args: Prisma.GymCrowdLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>
          }
          createMany: {
            args: Prisma.GymCrowdLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymCrowdLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>[]
          }
          delete: {
            args: Prisma.GymCrowdLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>
          }
          update: {
            args: Prisma.GymCrowdLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>
          }
          deleteMany: {
            args: Prisma.GymCrowdLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymCrowdLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GymCrowdLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>[]
          }
          upsert: {
            args: Prisma.GymCrowdLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymCrowdLevelPayload>
          }
          aggregate: {
            args: Prisma.GymCrowdLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymCrowdLevel>
          }
          groupBy: {
            args: Prisma.GymCrowdLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymCrowdLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymCrowdLevelCountArgs<ExtArgs>
            result: $Utils.Optional<GymCrowdLevelCountAggregateOutputType> | number
          }
        }
      }
      ReviewTag: {
        payload: Prisma.$ReviewTagPayload<ExtArgs>
        fields: Prisma.ReviewTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>
          }
          findFirst: {
            args: Prisma.ReviewTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>
          }
          findMany: {
            args: Prisma.ReviewTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>[]
          }
          create: {
            args: Prisma.ReviewTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>
          }
          createMany: {
            args: Prisma.ReviewTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>[]
          }
          delete: {
            args: Prisma.ReviewTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>
          }
          update: {
            args: Prisma.ReviewTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>
          }
          deleteMany: {
            args: Prisma.ReviewTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>[]
          }
          upsert: {
            args: Prisma.ReviewTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagPayload>
          }
          aggregate: {
            args: Prisma.ReviewTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewTag>
          }
          groupBy: {
            args: Prisma.ReviewTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewTagCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewTagCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewTagMapping: {
        payload: Prisma.$ReviewTagMappingPayload<ExtArgs>
        fields: Prisma.ReviewTagMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewTagMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewTagMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>
          }
          findFirst: {
            args: Prisma.ReviewTagMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewTagMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>
          }
          findMany: {
            args: Prisma.ReviewTagMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>[]
          }
          create: {
            args: Prisma.ReviewTagMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>
          }
          createMany: {
            args: Prisma.ReviewTagMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewTagMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>[]
          }
          delete: {
            args: Prisma.ReviewTagMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>
          }
          update: {
            args: Prisma.ReviewTagMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>
          }
          deleteMany: {
            args: Prisma.ReviewTagMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewTagMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewTagMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>[]
          }
          upsert: {
            args: Prisma.ReviewTagMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTagMappingPayload>
          }
          aggregate: {
            args: Prisma.ReviewTagMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewTagMapping>
          }
          groupBy: {
            args: Prisma.ReviewTagMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewTagMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewTagMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewTagMappingCountAggregateOutputType> | number
          }
        }
      }
      BodyPart: {
        payload: Prisma.$BodyPartPayload<ExtArgs>
        fields: Prisma.BodyPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodyPartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodyPartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>
          }
          findFirst: {
            args: Prisma.BodyPartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodyPartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>
          }
          findMany: {
            args: Prisma.BodyPartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>[]
          }
          create: {
            args: Prisma.BodyPartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>
          }
          createMany: {
            args: Prisma.BodyPartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BodyPartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>[]
          }
          delete: {
            args: Prisma.BodyPartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>
          }
          update: {
            args: Prisma.BodyPartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>
          }
          deleteMany: {
            args: Prisma.BodyPartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BodyPartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BodyPartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>[]
          }
          upsert: {
            args: Prisma.BodyPartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyPartPayload>
          }
          aggregate: {
            args: Prisma.BodyPartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBodyPart>
          }
          groupBy: {
            args: Prisma.BodyPartGroupByArgs<ExtArgs>
            result: $Utils.Optional<BodyPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodyPartCountArgs<ExtArgs>
            result: $Utils.Optional<BodyPartCountAggregateOutputType> | number
          }
        }
      }
      EquipmentType: {
        payload: Prisma.$EquipmentTypePayload<ExtArgs>
        fields: Prisma.EquipmentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          findFirst: {
            args: Prisma.EquipmentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          findMany: {
            args: Prisma.EquipmentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>[]
          }
          create: {
            args: Prisma.EquipmentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          createMany: {
            args: Prisma.EquipmentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>[]
          }
          delete: {
            args: Prisma.EquipmentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          update: {
            args: Prisma.EquipmentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          deleteMany: {
            args: Prisma.EquipmentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>[]
          }
          upsert: {
            args: Prisma.EquipmentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentTypePayload>
          }
          aggregate: {
            args: Prisma.EquipmentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentType>
          }
          groupBy: {
            args: Prisma.EquipmentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentTypeCountAggregateOutputType> | number
          }
        }
      }
      ExerciseTemplate: {
        payload: Prisma.$ExerciseTemplatePayload<ExtArgs>
        fields: Prisma.ExerciseTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>
          }
          findFirst: {
            args: Prisma.ExerciseTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>
          }
          findMany: {
            args: Prisma.ExerciseTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>[]
          }
          create: {
            args: Prisma.ExerciseTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>
          }
          createMany: {
            args: Prisma.ExerciseTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>[]
          }
          delete: {
            args: Prisma.ExerciseTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>
          }
          update: {
            args: Prisma.ExerciseTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTemplatePayload>
          }
          aggregate: {
            args: Prisma.ExerciseTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseTemplate>
          }
          groupBy: {
            args: Prisma.ExerciseTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseTemplateCountAggregateOutputType> | number
          }
        }
      }
      ExerciseEquipmentMapping: {
        payload: Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>
        fields: Prisma.ExerciseEquipmentMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseEquipmentMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseEquipmentMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>
          }
          findFirst: {
            args: Prisma.ExerciseEquipmentMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseEquipmentMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>
          }
          findMany: {
            args: Prisma.ExerciseEquipmentMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>[]
          }
          create: {
            args: Prisma.ExerciseEquipmentMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>
          }
          createMany: {
            args: Prisma.ExerciseEquipmentMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseEquipmentMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>[]
          }
          delete: {
            args: Prisma.ExerciseEquipmentMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>
          }
          update: {
            args: Prisma.ExerciseEquipmentMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseEquipmentMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseEquipmentMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseEquipmentMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>[]
          }
          upsert: {
            args: Prisma.ExerciseEquipmentMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseEquipmentMappingPayload>
          }
          aggregate: {
            args: Prisma.ExerciseEquipmentMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseEquipmentMapping>
          }
          groupBy: {
            args: Prisma.ExerciseEquipmentMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseEquipmentMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseEquipmentMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseEquipmentMappingCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseExercise: {
        payload: Prisma.$CourseExercisePayload<ExtArgs>
        fields: Prisma.CourseExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>
          }
          findFirst: {
            args: Prisma.CourseExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>
          }
          findMany: {
            args: Prisma.CourseExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>[]
          }
          create: {
            args: Prisma.CourseExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>
          }
          createMany: {
            args: Prisma.CourseExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>[]
          }
          delete: {
            args: Prisma.CourseExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>
          }
          update: {
            args: Prisma.CourseExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>
          }
          deleteMany: {
            args: Prisma.CourseExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>[]
          }
          upsert: {
            args: Prisma.CourseExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseExercisePayload>
          }
          aggregate: {
            args: Prisma.CourseExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseExercise>
          }
          groupBy: {
            args: Prisma.CourseExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseExerciseCountAggregateOutputType> | number
          }
        }
      }
      UserPainProfile: {
        payload: Prisma.$UserPainProfilePayload<ExtArgs>
        fields: Prisma.UserPainProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPainProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPainProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>
          }
          findFirst: {
            args: Prisma.UserPainProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPainProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>
          }
          findMany: {
            args: Prisma.UserPainProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>[]
          }
          create: {
            args: Prisma.UserPainProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>
          }
          createMany: {
            args: Prisma.UserPainProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPainProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>[]
          }
          delete: {
            args: Prisma.UserPainProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>
          }
          update: {
            args: Prisma.UserPainProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserPainProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPainProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPainProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserPainProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPainProfilePayload>
          }
          aggregate: {
            args: Prisma.UserPainProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPainProfile>
          }
          groupBy: {
            args: Prisma.UserPainProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPainProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPainProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserPainProfileCountAggregateOutputType> | number
          }
        }
      }
      UserCourseHistory: {
        payload: Prisma.$UserCourseHistoryPayload<ExtArgs>
        fields: Prisma.UserCourseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCourseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCourseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserCourseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCourseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>
          }
          findMany: {
            args: Prisma.UserCourseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>[]
          }
          create: {
            args: Prisma.UserCourseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>
          }
          createMany: {
            args: Prisma.UserCourseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCourseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserCourseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>
          }
          update: {
            args: Prisma.UserCourseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserCourseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCourseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCourseHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserCourseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserCourseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCourseHistory>
          }
          groupBy: {
            args: Prisma.UserCourseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCourseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCourseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserCourseHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserFavorite: {
        payload: Prisma.$UserFavoritePayload<ExtArgs>
        fields: Prisma.UserFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          update: {
            args: Prisma.UserFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorite>
          }
          groupBy: {
            args: Prisma.UserFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    gym?: GymOmit
    gymFacility?: GymFacilityOmit
    gymOperatingHour?: GymOperatingHourOmit
    gymCrowdLevel?: GymCrowdLevelOmit
    reviewTag?: ReviewTagOmit
    review?: ReviewOmit
    reviewTagMapping?: ReviewTagMappingOmit
    bodyPart?: BodyPartOmit
    equipmentType?: EquipmentTypeOmit
    exerciseTemplate?: ExerciseTemplateOmit
    exerciseEquipmentMapping?: ExerciseEquipmentMappingOmit
    course?: CourseOmit
    courseExercise?: CourseExerciseOmit
    userPainProfile?: UserPainProfileOmit
    userCourseHistory?: UserCourseHistoryOmit
    userFavorite?: UserFavoriteOmit
    event?: EventOmit
    patient?: PatientOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reviews: number
    courses: number
    userPainProfiles: number
    userCourseHistory: number
    userFavorites: number
    events: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    userPainProfiles?: boolean | UserCountOutputTypeCountUserPainProfilesArgs
    userCourseHistory?: boolean | UserCountOutputTypeCountUserCourseHistoryArgs
    userFavorites?: boolean | UserCountOutputTypeCountUserFavoritesArgs
    events?: boolean | UserCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPainProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPainProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCourseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type GymCountOutputType
   */

  export type GymCountOutputType = {
    operatingHours: number
    crowdLevels: number
    reviews: number
    userFavorites: number
  }

  export type GymCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operatingHours?: boolean | GymCountOutputTypeCountOperatingHoursArgs
    crowdLevels?: boolean | GymCountOutputTypeCountCrowdLevelsArgs
    reviews?: boolean | GymCountOutputTypeCountReviewsArgs
    userFavorites?: boolean | GymCountOutputTypeCountUserFavoritesArgs
  }

  // Custom InputTypes
  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCountOutputType
     */
    select?: GymCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountOperatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymOperatingHourWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountCrowdLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymCrowdLevelWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * GymCountOutputType without action
   */
  export type GymCountOutputTypeCountUserFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Count Type ReviewTagCountOutputType
   */

  export type ReviewTagCountOutputType = {
    reviewTagMappings: number
  }

  export type ReviewTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewTagMappings?: boolean | ReviewTagCountOutputTypeCountReviewTagMappingsArgs
  }

  // Custom InputTypes
  /**
   * ReviewTagCountOutputType without action
   */
  export type ReviewTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagCountOutputType
     */
    select?: ReviewTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewTagCountOutputType without action
   */
  export type ReviewTagCountOutputTypeCountReviewTagMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewTagMappingWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    reviewTagMappings: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewTagMappings?: boolean | ReviewCountOutputTypeCountReviewTagMappingsArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountReviewTagMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewTagMappingWhereInput
  }


  /**
   * Count Type BodyPartCountOutputType
   */

  export type BodyPartCountOutputType = {
    exerciseTemplates: number
    userPainProfiles: number
  }

  export type BodyPartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTemplates?: boolean | BodyPartCountOutputTypeCountExerciseTemplatesArgs
    userPainProfiles?: boolean | BodyPartCountOutputTypeCountUserPainProfilesArgs
  }

  // Custom InputTypes
  /**
   * BodyPartCountOutputType without action
   */
  export type BodyPartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPartCountOutputType
     */
    select?: BodyPartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BodyPartCountOutputType without action
   */
  export type BodyPartCountOutputTypeCountExerciseTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseTemplateWhereInput
  }

  /**
   * BodyPartCountOutputType without action
   */
  export type BodyPartCountOutputTypeCountUserPainProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPainProfileWhereInput
  }


  /**
   * Count Type EquipmentTypeCountOutputType
   */

  export type EquipmentTypeCountOutputType = {
    exerciseEquipmentMappings: number
  }

  export type EquipmentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseEquipmentMappings?: boolean | EquipmentTypeCountOutputTypeCountExerciseEquipmentMappingsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentTypeCountOutputType without action
   */
  export type EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentTypeCountOutputType
     */
    select?: EquipmentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentTypeCountOutputType without action
   */
  export type EquipmentTypeCountOutputTypeCountExerciseEquipmentMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseEquipmentMappingWhereInput
  }


  /**
   * Count Type ExerciseTemplateCountOutputType
   */

  export type ExerciseTemplateCountOutputType = {
    exerciseEquipmentMappings: number
    courseExercises: number
  }

  export type ExerciseTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseEquipmentMappings?: boolean | ExerciseTemplateCountOutputTypeCountExerciseEquipmentMappingsArgs
    courseExercises?: boolean | ExerciseTemplateCountOutputTypeCountCourseExercisesArgs
  }

  // Custom InputTypes
  /**
   * ExerciseTemplateCountOutputType without action
   */
  export type ExerciseTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplateCountOutputType
     */
    select?: ExerciseTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseTemplateCountOutputType without action
   */
  export type ExerciseTemplateCountOutputTypeCountExerciseEquipmentMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseEquipmentMappingWhereInput
  }

  /**
   * ExerciseTemplateCountOutputType without action
   */
  export type ExerciseTemplateCountOutputTypeCountCourseExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseExerciseWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    courseExercises: number
    userCourseHistory: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseExercises?: boolean | CourseCountOutputTypeCountCourseExercisesArgs
    userCourseHistory?: boolean | CourseCountOutputTypeCountUserCourseHistoryArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseExerciseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountUserCourseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    displayName: string | null
    isAdmin: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    displayName: string | null
    isAdmin: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    displayName: number
    isAdmin: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    displayName?: true
    isAdmin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    displayName?: true
    isAdmin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    displayName?: true
    isAdmin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    displayName: string | null
    isAdmin: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    displayName?: boolean
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    userPainProfiles?: boolean | User$userPainProfilesArgs<ExtArgs>
    userCourseHistory?: boolean | User$userCourseHistoryArgs<ExtArgs>
    userFavorites?: boolean | User$userFavoritesArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    displayName?: boolean
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    displayName?: boolean
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    displayName?: boolean
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "displayName" | "isAdmin" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    userPainProfiles?: boolean | User$userPainProfilesArgs<ExtArgs>
    userCourseHistory?: boolean | User$userCourseHistoryArgs<ExtArgs>
    userFavorites?: boolean | User$userFavoritesArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      userPainProfiles: Prisma.$UserPainProfilePayload<ExtArgs>[]
      userCourseHistory: Prisma.$UserCourseHistoryPayload<ExtArgs>[]
      userFavorites: Prisma.$UserFavoritePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      displayName: string | null
      isAdmin: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPainProfiles<T extends User$userPainProfilesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPainProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCourseHistory<T extends User$userCourseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$userCourseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userFavorites<T extends User$userFavoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$userFavoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.userPainProfiles
   */
  export type User$userPainProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    where?: UserPainProfileWhereInput
    orderBy?: UserPainProfileOrderByWithRelationInput | UserPainProfileOrderByWithRelationInput[]
    cursor?: UserPainProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPainProfileScalarFieldEnum | UserPainProfileScalarFieldEnum[]
  }

  /**
   * User.userCourseHistory
   */
  export type User$userCourseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    where?: UserCourseHistoryWhereInput
    orderBy?: UserCourseHistoryOrderByWithRelationInput | UserCourseHistoryOrderByWithRelationInput[]
    cursor?: UserCourseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseHistoryScalarFieldEnum | UserCourseHistoryScalarFieldEnum[]
  }

  /**
   * User.userFavorites
   */
  export type User$userFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Gym
   */

  export type AggregateGym = {
    _count: GymCountAggregateOutputType | null
    _avg: GymAvgAggregateOutputType | null
    _sum: GymSumAggregateOutputType | null
    _min: GymMinAggregateOutputType | null
    _max: GymMaxAggregateOutputType | null
  }

  export type GymAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    facilityInfoCount: number | null
  }

  export type GymSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    facilityInfoCount: number | null
  }

  export type GymMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string | null
    website: string | null
    priceRange: string | null
    description: string | null
    isActive: boolean | null
    facilityInfoCount: number | null
    lastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    phone: string | null
    website: string | null
    priceRange: string | null
    description: string | null
    isActive: boolean | null
    facilityInfoCount: number | null
    lastUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymCountAggregateOutputType = {
    id: number
    name: number
    address: number
    latitude: number
    longitude: number
    phone: number
    website: number
    priceRange: number
    description: number
    isActive: number
    facilityInfoCount: number
    lastUpdatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    facilityInfoCount?: true
  }

  export type GymSumAggregateInputType = {
    latitude?: true
    longitude?: true
    facilityInfoCount?: true
  }

  export type GymMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    website?: true
    priceRange?: true
    description?: true
    isActive?: true
    facilityInfoCount?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    website?: true
    priceRange?: true
    description?: true
    isActive?: true
    facilityInfoCount?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    phone?: true
    website?: true
    priceRange?: true
    description?: true
    isActive?: true
    facilityInfoCount?: true
    lastUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gym to aggregate.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gyms
    **/
    _count?: true | GymCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymMaxAggregateInputType
  }

  export type GetGymAggregateType<T extends GymAggregateArgs> = {
        [P in keyof T & keyof AggregateGym]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGym[P]>
      : GetScalarType<T[P], AggregateGym[P]>
  }




  export type GymGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymWhereInput
    orderBy?: GymOrderByWithAggregationInput | GymOrderByWithAggregationInput[]
    by: GymScalarFieldEnum[] | GymScalarFieldEnum
    having?: GymScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymCountAggregateInputType | true
    _avg?: GymAvgAggregateInputType
    _sum?: GymSumAggregateInputType
    _min?: GymMinAggregateInputType
    _max?: GymMaxAggregateInputType
  }

  export type GymGroupByOutputType = {
    id: string
    name: string
    address: string
    latitude: Decimal
    longitude: Decimal
    phone: string | null
    website: string | null
    priceRange: string | null
    description: string | null
    isActive: boolean
    facilityInfoCount: number
    lastUpdatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GymCountAggregateOutputType | null
    _avg: GymAvgAggregateOutputType | null
    _sum: GymSumAggregateOutputType | null
    _min: GymMinAggregateOutputType | null
    _max: GymMaxAggregateOutputType | null
  }

  type GetGymGroupByPayload<T extends GymGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymGroupByOutputType[P]>
            : GetScalarType<T[P], GymGroupByOutputType[P]>
        }
      >
    >


  export type GymSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    priceRange?: boolean
    description?: boolean
    isActive?: boolean
    facilityInfoCount?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilities?: boolean | Gym$facilitiesArgs<ExtArgs>
    operatingHours?: boolean | Gym$operatingHoursArgs<ExtArgs>
    crowdLevels?: boolean | Gym$crowdLevelsArgs<ExtArgs>
    reviews?: boolean | Gym$reviewsArgs<ExtArgs>
    userFavorites?: boolean | Gym$userFavoritesArgs<ExtArgs>
    _count?: boolean | GymCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gym"]>

  export type GymSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    priceRange?: boolean
    description?: boolean
    isActive?: boolean
    facilityInfoCount?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gym"]>

  export type GymSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    priceRange?: boolean
    description?: boolean
    isActive?: boolean
    facilityInfoCount?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gym"]>

  export type GymSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    priceRange?: boolean
    description?: boolean
    isActive?: boolean
    facilityInfoCount?: boolean
    lastUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "latitude" | "longitude" | "phone" | "website" | "priceRange" | "description" | "isActive" | "facilityInfoCount" | "lastUpdatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["gym"]>
  export type GymInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | Gym$facilitiesArgs<ExtArgs>
    operatingHours?: boolean | Gym$operatingHoursArgs<ExtArgs>
    crowdLevels?: boolean | Gym$crowdLevelsArgs<ExtArgs>
    reviews?: boolean | Gym$reviewsArgs<ExtArgs>
    userFavorites?: boolean | Gym$userFavoritesArgs<ExtArgs>
    _count?: boolean | GymCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GymIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GymIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GymPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gym"
    objects: {
      facilities: Prisma.$GymFacilityPayload<ExtArgs> | null
      operatingHours: Prisma.$GymOperatingHourPayload<ExtArgs>[]
      crowdLevels: Prisma.$GymCrowdLevelPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      userFavorites: Prisma.$UserFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      latitude: Prisma.Decimal
      longitude: Prisma.Decimal
      phone: string | null
      website: string | null
      priceRange: string | null
      description: string | null
      isActive: boolean
      facilityInfoCount: number
      lastUpdatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gym"]>
    composites: {}
  }

  type GymGetPayload<S extends boolean | null | undefined | GymDefaultArgs> = $Result.GetResult<Prisma.$GymPayload, S>

  type GymCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymCountAggregateInputType | true
    }

  export interface GymDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gym'], meta: { name: 'Gym' } }
    /**
     * Find zero or one Gym that matches the filter.
     * @param {GymFindUniqueArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymFindUniqueArgs>(args: SelectSubset<T, GymFindUniqueArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gym that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymFindUniqueOrThrowArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymFindUniqueOrThrowArgs>(args: SelectSubset<T, GymFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gym that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFindFirstArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymFindFirstArgs>(args?: SelectSubset<T, GymFindFirstArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gym that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFindFirstOrThrowArgs} args - Arguments to find a Gym
     * @example
     * // Get one Gym
     * const gym = await prisma.gym.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymFindFirstOrThrowArgs>(args?: SelectSubset<T, GymFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gyms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gyms
     * const gyms = await prisma.gym.findMany()
     * 
     * // Get first 10 Gyms
     * const gyms = await prisma.gym.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymWithIdOnly = await prisma.gym.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymFindManyArgs>(args?: SelectSubset<T, GymFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gym.
     * @param {GymCreateArgs} args - Arguments to create a Gym.
     * @example
     * // Create one Gym
     * const Gym = await prisma.gym.create({
     *   data: {
     *     // ... data to create a Gym
     *   }
     * })
     * 
     */
    create<T extends GymCreateArgs>(args: SelectSubset<T, GymCreateArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gyms.
     * @param {GymCreateManyArgs} args - Arguments to create many Gyms.
     * @example
     * // Create many Gyms
     * const gym = await prisma.gym.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymCreateManyArgs>(args?: SelectSubset<T, GymCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gyms and returns the data saved in the database.
     * @param {GymCreateManyAndReturnArgs} args - Arguments to create many Gyms.
     * @example
     * // Create many Gyms
     * const gym = await prisma.gym.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gyms and only return the `id`
     * const gymWithIdOnly = await prisma.gym.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymCreateManyAndReturnArgs>(args?: SelectSubset<T, GymCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gym.
     * @param {GymDeleteArgs} args - Arguments to delete one Gym.
     * @example
     * // Delete one Gym
     * const Gym = await prisma.gym.delete({
     *   where: {
     *     // ... filter to delete one Gym
     *   }
     * })
     * 
     */
    delete<T extends GymDeleteArgs>(args: SelectSubset<T, GymDeleteArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gym.
     * @param {GymUpdateArgs} args - Arguments to update one Gym.
     * @example
     * // Update one Gym
     * const gym = await prisma.gym.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymUpdateArgs>(args: SelectSubset<T, GymUpdateArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gyms.
     * @param {GymDeleteManyArgs} args - Arguments to filter Gyms to delete.
     * @example
     * // Delete a few Gyms
     * const { count } = await prisma.gym.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymDeleteManyArgs>(args?: SelectSubset<T, GymDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gyms
     * const gym = await prisma.gym.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymUpdateManyArgs>(args: SelectSubset<T, GymUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gyms and returns the data updated in the database.
     * @param {GymUpdateManyAndReturnArgs} args - Arguments to update many Gyms.
     * @example
     * // Update many Gyms
     * const gym = await prisma.gym.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gyms and only return the `id`
     * const gymWithIdOnly = await prisma.gym.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymUpdateManyAndReturnArgs>(args: SelectSubset<T, GymUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gym.
     * @param {GymUpsertArgs} args - Arguments to update or create a Gym.
     * @example
     * // Update or create a Gym
     * const gym = await prisma.gym.upsert({
     *   create: {
     *     // ... data to create a Gym
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gym we want to update
     *   }
     * })
     */
    upsert<T extends GymUpsertArgs>(args: SelectSubset<T, GymUpsertArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCountArgs} args - Arguments to filter Gyms to count.
     * @example
     * // Count the number of Gyms
     * const count = await prisma.gym.count({
     *   where: {
     *     // ... the filter for the Gyms we want to count
     *   }
     * })
    **/
    count<T extends GymCountArgs>(
      args?: Subset<T, GymCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gym.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymAggregateArgs>(args: Subset<T, GymAggregateArgs>): Prisma.PrismaPromise<GetGymAggregateType<T>>

    /**
     * Group by Gym.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymGroupByArgs['orderBy'] }
        : { orderBy?: GymGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gym model
   */
  readonly fields: GymFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gym.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facilities<T extends Gym$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Gym$facilitiesArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    operatingHours<T extends Gym$operatingHoursArgs<ExtArgs> = {}>(args?: Subset<T, Gym$operatingHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crowdLevels<T extends Gym$crowdLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Gym$crowdLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Gym$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Gym$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userFavorites<T extends Gym$userFavoritesArgs<ExtArgs> = {}>(args?: Subset<T, Gym$userFavoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gym model
   */
  interface GymFieldRefs {
    readonly id: FieldRef<"Gym", 'String'>
    readonly name: FieldRef<"Gym", 'String'>
    readonly address: FieldRef<"Gym", 'String'>
    readonly latitude: FieldRef<"Gym", 'Decimal'>
    readonly longitude: FieldRef<"Gym", 'Decimal'>
    readonly phone: FieldRef<"Gym", 'String'>
    readonly website: FieldRef<"Gym", 'String'>
    readonly priceRange: FieldRef<"Gym", 'String'>
    readonly description: FieldRef<"Gym", 'String'>
    readonly isActive: FieldRef<"Gym", 'Boolean'>
    readonly facilityInfoCount: FieldRef<"Gym", 'Int'>
    readonly lastUpdatedAt: FieldRef<"Gym", 'DateTime'>
    readonly createdAt: FieldRef<"Gym", 'DateTime'>
    readonly updatedAt: FieldRef<"Gym", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gym findUnique
   */
  export type GymFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym findUniqueOrThrow
   */
  export type GymFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym findFirst
   */
  export type GymFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gyms.
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gyms.
     */
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * Gym findFirstOrThrow
   */
  export type GymFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gym to fetch.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gyms.
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gyms.
     */
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * Gym findMany
   */
  export type GymFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter, which Gyms to fetch.
     */
    where?: GymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gyms to fetch.
     */
    orderBy?: GymOrderByWithRelationInput | GymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gyms.
     */
    cursor?: GymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gyms.
     */
    skip?: number
    distinct?: GymScalarFieldEnum | GymScalarFieldEnum[]
  }

  /**
   * Gym create
   */
  export type GymCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * The data needed to create a Gym.
     */
    data: XOR<GymCreateInput, GymUncheckedCreateInput>
  }

  /**
   * Gym createMany
   */
  export type GymCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gyms.
     */
    data: GymCreateManyInput | GymCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gym createManyAndReturn
   */
  export type GymCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * The data used to create many Gyms.
     */
    data: GymCreateManyInput | GymCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gym update
   */
  export type GymUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * The data needed to update a Gym.
     */
    data: XOR<GymUpdateInput, GymUncheckedUpdateInput>
    /**
     * Choose, which Gym to update.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym updateMany
   */
  export type GymUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gyms.
     */
    data: XOR<GymUpdateManyMutationInput, GymUncheckedUpdateManyInput>
    /**
     * Filter which Gyms to update
     */
    where?: GymWhereInput
    /**
     * Limit how many Gyms to update.
     */
    limit?: number
  }

  /**
   * Gym updateManyAndReturn
   */
  export type GymUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * The data used to update Gyms.
     */
    data: XOR<GymUpdateManyMutationInput, GymUncheckedUpdateManyInput>
    /**
     * Filter which Gyms to update
     */
    where?: GymWhereInput
    /**
     * Limit how many Gyms to update.
     */
    limit?: number
  }

  /**
   * Gym upsert
   */
  export type GymUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * The filter to search for the Gym to update in case it exists.
     */
    where: GymWhereUniqueInput
    /**
     * In case the Gym found by the `where` argument doesn't exist, create a new Gym with this data.
     */
    create: XOR<GymCreateInput, GymUncheckedCreateInput>
    /**
     * In case the Gym was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymUpdateInput, GymUncheckedUpdateInput>
  }

  /**
   * Gym delete
   */
  export type GymDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
    /**
     * Filter which Gym to delete.
     */
    where: GymWhereUniqueInput
  }

  /**
   * Gym deleteMany
   */
  export type GymDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gyms to delete
     */
    where?: GymWhereInput
    /**
     * Limit how many Gyms to delete.
     */
    limit?: number
  }

  /**
   * Gym.facilities
   */
  export type Gym$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    where?: GymFacilityWhereInput
  }

  /**
   * Gym.operatingHours
   */
  export type Gym$operatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    where?: GymOperatingHourWhereInput
    orderBy?: GymOperatingHourOrderByWithRelationInput | GymOperatingHourOrderByWithRelationInput[]
    cursor?: GymOperatingHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymOperatingHourScalarFieldEnum | GymOperatingHourScalarFieldEnum[]
  }

  /**
   * Gym.crowdLevels
   */
  export type Gym$crowdLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    where?: GymCrowdLevelWhereInput
    orderBy?: GymCrowdLevelOrderByWithRelationInput | GymCrowdLevelOrderByWithRelationInput[]
    cursor?: GymCrowdLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymCrowdLevelScalarFieldEnum | GymCrowdLevelScalarFieldEnum[]
  }

  /**
   * Gym.reviews
   */
  export type Gym$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Gym.userFavorites
   */
  export type Gym$userFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * Gym without action
   */
  export type GymDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gym
     */
    select?: GymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gym
     */
    omit?: GymOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymInclude<ExtArgs> | null
  }


  /**
   * Model GymFacility
   */

  export type AggregateGymFacility = {
    _count: GymFacilityCountAggregateOutputType | null
    _min: GymFacilityMinAggregateOutputType | null
    _max: GymFacilityMaxAggregateOutputType | null
  }

  export type GymFacilityMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    isQuiet: boolean | null
    hasRehabEquipment: boolean | null
    hasPtCoach: boolean | null
    hasShower: boolean | null
    hasParking: boolean | null
    hasLocker: boolean | null
    hasWaterDispenser: boolean | null
    hasAirConditioning: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymFacilityMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    isQuiet: boolean | null
    hasRehabEquipment: boolean | null
    hasPtCoach: boolean | null
    hasShower: boolean | null
    hasParking: boolean | null
    hasLocker: boolean | null
    hasWaterDispenser: boolean | null
    hasAirConditioning: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymFacilityCountAggregateOutputType = {
    id: number
    gymId: number
    isQuiet: number
    hasRehabEquipment: number
    hasPtCoach: number
    hasShower: number
    hasParking: number
    hasLocker: number
    hasWaterDispenser: number
    hasAirConditioning: number
    otherFacilities: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymFacilityMinAggregateInputType = {
    id?: true
    gymId?: true
    isQuiet?: true
    hasRehabEquipment?: true
    hasPtCoach?: true
    hasShower?: true
    hasParking?: true
    hasLocker?: true
    hasWaterDispenser?: true
    hasAirConditioning?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymFacilityMaxAggregateInputType = {
    id?: true
    gymId?: true
    isQuiet?: true
    hasRehabEquipment?: true
    hasPtCoach?: true
    hasShower?: true
    hasParking?: true
    hasLocker?: true
    hasWaterDispenser?: true
    hasAirConditioning?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymFacilityCountAggregateInputType = {
    id?: true
    gymId?: true
    isQuiet?: true
    hasRehabEquipment?: true
    hasPtCoach?: true
    hasShower?: true
    hasParking?: true
    hasLocker?: true
    hasWaterDispenser?: true
    hasAirConditioning?: true
    otherFacilities?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymFacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymFacility to aggregate.
     */
    where?: GymFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymFacilities to fetch.
     */
    orderBy?: GymFacilityOrderByWithRelationInput | GymFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymFacilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymFacilities
    **/
    _count?: true | GymFacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymFacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymFacilityMaxAggregateInputType
  }

  export type GetGymFacilityAggregateType<T extends GymFacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateGymFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymFacility[P]>
      : GetScalarType<T[P], AggregateGymFacility[P]>
  }




  export type GymFacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymFacilityWhereInput
    orderBy?: GymFacilityOrderByWithAggregationInput | GymFacilityOrderByWithAggregationInput[]
    by: GymFacilityScalarFieldEnum[] | GymFacilityScalarFieldEnum
    having?: GymFacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymFacilityCountAggregateInputType | true
    _min?: GymFacilityMinAggregateInputType
    _max?: GymFacilityMaxAggregateInputType
  }

  export type GymFacilityGroupByOutputType = {
    id: string
    gymId: string
    isQuiet: boolean
    hasRehabEquipment: boolean
    hasPtCoach: boolean
    hasShower: boolean
    hasParking: boolean
    hasLocker: boolean
    hasWaterDispenser: boolean
    hasAirConditioning: boolean
    otherFacilities: string[]
    createdAt: Date
    updatedAt: Date
    _count: GymFacilityCountAggregateOutputType | null
    _min: GymFacilityMinAggregateOutputType | null
    _max: GymFacilityMaxAggregateOutputType | null
  }

  type GetGymFacilityGroupByPayload<T extends GymFacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymFacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymFacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymFacilityGroupByOutputType[P]>
            : GetScalarType<T[P], GymFacilityGroupByOutputType[P]>
        }
      >
    >


  export type GymFacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymFacility"]>

  export type GymFacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymFacility"]>

  export type GymFacilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymFacility"]>

  export type GymFacilitySelectScalar = {
    id?: boolean
    gymId?: boolean
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymFacilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "isQuiet" | "hasRehabEquipment" | "hasPtCoach" | "hasShower" | "hasParking" | "hasLocker" | "hasWaterDispenser" | "hasAirConditioning" | "otherFacilities" | "createdAt" | "updatedAt", ExtArgs["result"]["gymFacility"]>
  export type GymFacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymFacilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymFacilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $GymFacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymFacility"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      isQuiet: boolean
      hasRehabEquipment: boolean
      hasPtCoach: boolean
      hasShower: boolean
      hasParking: boolean
      hasLocker: boolean
      hasWaterDispenser: boolean
      hasAirConditioning: boolean
      otherFacilities: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymFacility"]>
    composites: {}
  }

  type GymFacilityGetPayload<S extends boolean | null | undefined | GymFacilityDefaultArgs> = $Result.GetResult<Prisma.$GymFacilityPayload, S>

  type GymFacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymFacilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymFacilityCountAggregateInputType | true
    }

  export interface GymFacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymFacility'], meta: { name: 'GymFacility' } }
    /**
     * Find zero or one GymFacility that matches the filter.
     * @param {GymFacilityFindUniqueArgs} args - Arguments to find a GymFacility
     * @example
     * // Get one GymFacility
     * const gymFacility = await prisma.gymFacility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymFacilityFindUniqueArgs>(args: SelectSubset<T, GymFacilityFindUniqueArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymFacility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymFacilityFindUniqueOrThrowArgs} args - Arguments to find a GymFacility
     * @example
     * // Get one GymFacility
     * const gymFacility = await prisma.gymFacility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymFacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, GymFacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymFacility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityFindFirstArgs} args - Arguments to find a GymFacility
     * @example
     * // Get one GymFacility
     * const gymFacility = await prisma.gymFacility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymFacilityFindFirstArgs>(args?: SelectSubset<T, GymFacilityFindFirstArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymFacility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityFindFirstOrThrowArgs} args - Arguments to find a GymFacility
     * @example
     * // Get one GymFacility
     * const gymFacility = await prisma.gymFacility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymFacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, GymFacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymFacilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymFacilities
     * const gymFacilities = await prisma.gymFacility.findMany()
     * 
     * // Get first 10 GymFacilities
     * const gymFacilities = await prisma.gymFacility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymFacilityWithIdOnly = await prisma.gymFacility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymFacilityFindManyArgs>(args?: SelectSubset<T, GymFacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymFacility.
     * @param {GymFacilityCreateArgs} args - Arguments to create a GymFacility.
     * @example
     * // Create one GymFacility
     * const GymFacility = await prisma.gymFacility.create({
     *   data: {
     *     // ... data to create a GymFacility
     *   }
     * })
     * 
     */
    create<T extends GymFacilityCreateArgs>(args: SelectSubset<T, GymFacilityCreateArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymFacilities.
     * @param {GymFacilityCreateManyArgs} args - Arguments to create many GymFacilities.
     * @example
     * // Create many GymFacilities
     * const gymFacility = await prisma.gymFacility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymFacilityCreateManyArgs>(args?: SelectSubset<T, GymFacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymFacilities and returns the data saved in the database.
     * @param {GymFacilityCreateManyAndReturnArgs} args - Arguments to create many GymFacilities.
     * @example
     * // Create many GymFacilities
     * const gymFacility = await prisma.gymFacility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymFacilities and only return the `id`
     * const gymFacilityWithIdOnly = await prisma.gymFacility.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymFacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, GymFacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymFacility.
     * @param {GymFacilityDeleteArgs} args - Arguments to delete one GymFacility.
     * @example
     * // Delete one GymFacility
     * const GymFacility = await prisma.gymFacility.delete({
     *   where: {
     *     // ... filter to delete one GymFacility
     *   }
     * })
     * 
     */
    delete<T extends GymFacilityDeleteArgs>(args: SelectSubset<T, GymFacilityDeleteArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymFacility.
     * @param {GymFacilityUpdateArgs} args - Arguments to update one GymFacility.
     * @example
     * // Update one GymFacility
     * const gymFacility = await prisma.gymFacility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymFacilityUpdateArgs>(args: SelectSubset<T, GymFacilityUpdateArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymFacilities.
     * @param {GymFacilityDeleteManyArgs} args - Arguments to filter GymFacilities to delete.
     * @example
     * // Delete a few GymFacilities
     * const { count } = await prisma.gymFacility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymFacilityDeleteManyArgs>(args?: SelectSubset<T, GymFacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymFacilities
     * const gymFacility = await prisma.gymFacility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymFacilityUpdateManyArgs>(args: SelectSubset<T, GymFacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymFacilities and returns the data updated in the database.
     * @param {GymFacilityUpdateManyAndReturnArgs} args - Arguments to update many GymFacilities.
     * @example
     * // Update many GymFacilities
     * const gymFacility = await prisma.gymFacility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymFacilities and only return the `id`
     * const gymFacilityWithIdOnly = await prisma.gymFacility.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymFacilityUpdateManyAndReturnArgs>(args: SelectSubset<T, GymFacilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymFacility.
     * @param {GymFacilityUpsertArgs} args - Arguments to update or create a GymFacility.
     * @example
     * // Update or create a GymFacility
     * const gymFacility = await prisma.gymFacility.upsert({
     *   create: {
     *     // ... data to create a GymFacility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymFacility we want to update
     *   }
     * })
     */
    upsert<T extends GymFacilityUpsertArgs>(args: SelectSubset<T, GymFacilityUpsertArgs<ExtArgs>>): Prisma__GymFacilityClient<$Result.GetResult<Prisma.$GymFacilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityCountArgs} args - Arguments to filter GymFacilities to count.
     * @example
     * // Count the number of GymFacilities
     * const count = await prisma.gymFacility.count({
     *   where: {
     *     // ... the filter for the GymFacilities we want to count
     *   }
     * })
    **/
    count<T extends GymFacilityCountArgs>(
      args?: Subset<T, GymFacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymFacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymFacility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymFacilityAggregateArgs>(args: Subset<T, GymFacilityAggregateArgs>): Prisma.PrismaPromise<GetGymFacilityAggregateType<T>>

    /**
     * Group by GymFacility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymFacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymFacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymFacilityGroupByArgs['orderBy'] }
        : { orderBy?: GymFacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymFacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymFacility model
   */
  readonly fields: GymFacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymFacility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymFacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymFacility model
   */
  interface GymFacilityFieldRefs {
    readonly id: FieldRef<"GymFacility", 'String'>
    readonly gymId: FieldRef<"GymFacility", 'String'>
    readonly isQuiet: FieldRef<"GymFacility", 'Boolean'>
    readonly hasRehabEquipment: FieldRef<"GymFacility", 'Boolean'>
    readonly hasPtCoach: FieldRef<"GymFacility", 'Boolean'>
    readonly hasShower: FieldRef<"GymFacility", 'Boolean'>
    readonly hasParking: FieldRef<"GymFacility", 'Boolean'>
    readonly hasLocker: FieldRef<"GymFacility", 'Boolean'>
    readonly hasWaterDispenser: FieldRef<"GymFacility", 'Boolean'>
    readonly hasAirConditioning: FieldRef<"GymFacility", 'Boolean'>
    readonly otherFacilities: FieldRef<"GymFacility", 'String[]'>
    readonly createdAt: FieldRef<"GymFacility", 'DateTime'>
    readonly updatedAt: FieldRef<"GymFacility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymFacility findUnique
   */
  export type GymFacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * Filter, which GymFacility to fetch.
     */
    where: GymFacilityWhereUniqueInput
  }

  /**
   * GymFacility findUniqueOrThrow
   */
  export type GymFacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * Filter, which GymFacility to fetch.
     */
    where: GymFacilityWhereUniqueInput
  }

  /**
   * GymFacility findFirst
   */
  export type GymFacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * Filter, which GymFacility to fetch.
     */
    where?: GymFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymFacilities to fetch.
     */
    orderBy?: GymFacilityOrderByWithRelationInput | GymFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymFacilities.
     */
    cursor?: GymFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymFacilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymFacilities.
     */
    distinct?: GymFacilityScalarFieldEnum | GymFacilityScalarFieldEnum[]
  }

  /**
   * GymFacility findFirstOrThrow
   */
  export type GymFacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * Filter, which GymFacility to fetch.
     */
    where?: GymFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymFacilities to fetch.
     */
    orderBy?: GymFacilityOrderByWithRelationInput | GymFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymFacilities.
     */
    cursor?: GymFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymFacilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymFacilities.
     */
    distinct?: GymFacilityScalarFieldEnum | GymFacilityScalarFieldEnum[]
  }

  /**
   * GymFacility findMany
   */
  export type GymFacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * Filter, which GymFacilities to fetch.
     */
    where?: GymFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymFacilities to fetch.
     */
    orderBy?: GymFacilityOrderByWithRelationInput | GymFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymFacilities.
     */
    cursor?: GymFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymFacilities.
     */
    skip?: number
    distinct?: GymFacilityScalarFieldEnum | GymFacilityScalarFieldEnum[]
  }

  /**
   * GymFacility create
   */
  export type GymFacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a GymFacility.
     */
    data: XOR<GymFacilityCreateInput, GymFacilityUncheckedCreateInput>
  }

  /**
   * GymFacility createMany
   */
  export type GymFacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymFacilities.
     */
    data: GymFacilityCreateManyInput | GymFacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymFacility createManyAndReturn
   */
  export type GymFacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * The data used to create many GymFacilities.
     */
    data: GymFacilityCreateManyInput | GymFacilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymFacility update
   */
  export type GymFacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a GymFacility.
     */
    data: XOR<GymFacilityUpdateInput, GymFacilityUncheckedUpdateInput>
    /**
     * Choose, which GymFacility to update.
     */
    where: GymFacilityWhereUniqueInput
  }

  /**
   * GymFacility updateMany
   */
  export type GymFacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymFacilities.
     */
    data: XOR<GymFacilityUpdateManyMutationInput, GymFacilityUncheckedUpdateManyInput>
    /**
     * Filter which GymFacilities to update
     */
    where?: GymFacilityWhereInput
    /**
     * Limit how many GymFacilities to update.
     */
    limit?: number
  }

  /**
   * GymFacility updateManyAndReturn
   */
  export type GymFacilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * The data used to update GymFacilities.
     */
    data: XOR<GymFacilityUpdateManyMutationInput, GymFacilityUncheckedUpdateManyInput>
    /**
     * Filter which GymFacilities to update
     */
    where?: GymFacilityWhereInput
    /**
     * Limit how many GymFacilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymFacility upsert
   */
  export type GymFacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the GymFacility to update in case it exists.
     */
    where: GymFacilityWhereUniqueInput
    /**
     * In case the GymFacility found by the `where` argument doesn't exist, create a new GymFacility with this data.
     */
    create: XOR<GymFacilityCreateInput, GymFacilityUncheckedCreateInput>
    /**
     * In case the GymFacility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymFacilityUpdateInput, GymFacilityUncheckedUpdateInput>
  }

  /**
   * GymFacility delete
   */
  export type GymFacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
    /**
     * Filter which GymFacility to delete.
     */
    where: GymFacilityWhereUniqueInput
  }

  /**
   * GymFacility deleteMany
   */
  export type GymFacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymFacilities to delete
     */
    where?: GymFacilityWhereInput
    /**
     * Limit how many GymFacilities to delete.
     */
    limit?: number
  }

  /**
   * GymFacility without action
   */
  export type GymFacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymFacility
     */
    select?: GymFacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymFacility
     */
    omit?: GymFacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymFacilityInclude<ExtArgs> | null
  }


  /**
   * Model GymOperatingHour
   */

  export type AggregateGymOperatingHour = {
    _count: GymOperatingHourCountAggregateOutputType | null
    _avg: GymOperatingHourAvgAggregateOutputType | null
    _sum: GymOperatingHourSumAggregateOutputType | null
    _min: GymOperatingHourMinAggregateOutputType | null
    _max: GymOperatingHourMaxAggregateOutputType | null
  }

  export type GymOperatingHourAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type GymOperatingHourSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type GymOperatingHourMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    dayOfWeek: number | null
    openTime: string | null
    closeTime: string | null
    isClosed: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymOperatingHourMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    dayOfWeek: number | null
    openTime: string | null
    closeTime: string | null
    isClosed: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymOperatingHourCountAggregateOutputType = {
    id: number
    gymId: number
    dayOfWeek: number
    openTime: number
    closeTime: number
    isClosed: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymOperatingHourAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type GymOperatingHourSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type GymOperatingHourMinAggregateInputType = {
    id?: true
    gymId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymOperatingHourMaxAggregateInputType = {
    id?: true
    gymId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymOperatingHourCountAggregateInputType = {
    id?: true
    gymId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymOperatingHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymOperatingHour to aggregate.
     */
    where?: GymOperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymOperatingHours to fetch.
     */
    orderBy?: GymOperatingHourOrderByWithRelationInput | GymOperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymOperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymOperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymOperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymOperatingHours
    **/
    _count?: true | GymOperatingHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymOperatingHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymOperatingHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymOperatingHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymOperatingHourMaxAggregateInputType
  }

  export type GetGymOperatingHourAggregateType<T extends GymOperatingHourAggregateArgs> = {
        [P in keyof T & keyof AggregateGymOperatingHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymOperatingHour[P]>
      : GetScalarType<T[P], AggregateGymOperatingHour[P]>
  }




  export type GymOperatingHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymOperatingHourWhereInput
    orderBy?: GymOperatingHourOrderByWithAggregationInput | GymOperatingHourOrderByWithAggregationInput[]
    by: GymOperatingHourScalarFieldEnum[] | GymOperatingHourScalarFieldEnum
    having?: GymOperatingHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymOperatingHourCountAggregateInputType | true
    _avg?: GymOperatingHourAvgAggregateInputType
    _sum?: GymOperatingHourSumAggregateInputType
    _min?: GymOperatingHourMinAggregateInputType
    _max?: GymOperatingHourMaxAggregateInputType
  }

  export type GymOperatingHourGroupByOutputType = {
    id: string
    gymId: string
    dayOfWeek: number
    openTime: string | null
    closeTime: string | null
    isClosed: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: GymOperatingHourCountAggregateOutputType | null
    _avg: GymOperatingHourAvgAggregateOutputType | null
    _sum: GymOperatingHourSumAggregateOutputType | null
    _min: GymOperatingHourMinAggregateOutputType | null
    _max: GymOperatingHourMaxAggregateOutputType | null
  }

  type GetGymOperatingHourGroupByPayload<T extends GymOperatingHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymOperatingHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymOperatingHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymOperatingHourGroupByOutputType[P]>
            : GetScalarType<T[P], GymOperatingHourGroupByOutputType[P]>
        }
      >
    >


  export type GymOperatingHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymOperatingHour"]>

  export type GymOperatingHourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymOperatingHour"]>

  export type GymOperatingHourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymOperatingHour"]>

  export type GymOperatingHourSelectScalar = {
    id?: boolean
    gymId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymOperatingHourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "dayOfWeek" | "openTime" | "closeTime" | "isClosed" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["gymOperatingHour"]>
  export type GymOperatingHourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymOperatingHourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymOperatingHourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $GymOperatingHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymOperatingHour"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      dayOfWeek: number
      openTime: string | null
      closeTime: string | null
      isClosed: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymOperatingHour"]>
    composites: {}
  }

  type GymOperatingHourGetPayload<S extends boolean | null | undefined | GymOperatingHourDefaultArgs> = $Result.GetResult<Prisma.$GymOperatingHourPayload, S>

  type GymOperatingHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymOperatingHourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymOperatingHourCountAggregateInputType | true
    }

  export interface GymOperatingHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymOperatingHour'], meta: { name: 'GymOperatingHour' } }
    /**
     * Find zero or one GymOperatingHour that matches the filter.
     * @param {GymOperatingHourFindUniqueArgs} args - Arguments to find a GymOperatingHour
     * @example
     * // Get one GymOperatingHour
     * const gymOperatingHour = await prisma.gymOperatingHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymOperatingHourFindUniqueArgs>(args: SelectSubset<T, GymOperatingHourFindUniqueArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymOperatingHour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymOperatingHourFindUniqueOrThrowArgs} args - Arguments to find a GymOperatingHour
     * @example
     * // Get one GymOperatingHour
     * const gymOperatingHour = await prisma.gymOperatingHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymOperatingHourFindUniqueOrThrowArgs>(args: SelectSubset<T, GymOperatingHourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymOperatingHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourFindFirstArgs} args - Arguments to find a GymOperatingHour
     * @example
     * // Get one GymOperatingHour
     * const gymOperatingHour = await prisma.gymOperatingHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymOperatingHourFindFirstArgs>(args?: SelectSubset<T, GymOperatingHourFindFirstArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymOperatingHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourFindFirstOrThrowArgs} args - Arguments to find a GymOperatingHour
     * @example
     * // Get one GymOperatingHour
     * const gymOperatingHour = await prisma.gymOperatingHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymOperatingHourFindFirstOrThrowArgs>(args?: SelectSubset<T, GymOperatingHourFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymOperatingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymOperatingHours
     * const gymOperatingHours = await prisma.gymOperatingHour.findMany()
     * 
     * // Get first 10 GymOperatingHours
     * const gymOperatingHours = await prisma.gymOperatingHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymOperatingHourWithIdOnly = await prisma.gymOperatingHour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymOperatingHourFindManyArgs>(args?: SelectSubset<T, GymOperatingHourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymOperatingHour.
     * @param {GymOperatingHourCreateArgs} args - Arguments to create a GymOperatingHour.
     * @example
     * // Create one GymOperatingHour
     * const GymOperatingHour = await prisma.gymOperatingHour.create({
     *   data: {
     *     // ... data to create a GymOperatingHour
     *   }
     * })
     * 
     */
    create<T extends GymOperatingHourCreateArgs>(args: SelectSubset<T, GymOperatingHourCreateArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymOperatingHours.
     * @param {GymOperatingHourCreateManyArgs} args - Arguments to create many GymOperatingHours.
     * @example
     * // Create many GymOperatingHours
     * const gymOperatingHour = await prisma.gymOperatingHour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymOperatingHourCreateManyArgs>(args?: SelectSubset<T, GymOperatingHourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymOperatingHours and returns the data saved in the database.
     * @param {GymOperatingHourCreateManyAndReturnArgs} args - Arguments to create many GymOperatingHours.
     * @example
     * // Create many GymOperatingHours
     * const gymOperatingHour = await prisma.gymOperatingHour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymOperatingHours and only return the `id`
     * const gymOperatingHourWithIdOnly = await prisma.gymOperatingHour.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymOperatingHourCreateManyAndReturnArgs>(args?: SelectSubset<T, GymOperatingHourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymOperatingHour.
     * @param {GymOperatingHourDeleteArgs} args - Arguments to delete one GymOperatingHour.
     * @example
     * // Delete one GymOperatingHour
     * const GymOperatingHour = await prisma.gymOperatingHour.delete({
     *   where: {
     *     // ... filter to delete one GymOperatingHour
     *   }
     * })
     * 
     */
    delete<T extends GymOperatingHourDeleteArgs>(args: SelectSubset<T, GymOperatingHourDeleteArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymOperatingHour.
     * @param {GymOperatingHourUpdateArgs} args - Arguments to update one GymOperatingHour.
     * @example
     * // Update one GymOperatingHour
     * const gymOperatingHour = await prisma.gymOperatingHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymOperatingHourUpdateArgs>(args: SelectSubset<T, GymOperatingHourUpdateArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymOperatingHours.
     * @param {GymOperatingHourDeleteManyArgs} args - Arguments to filter GymOperatingHours to delete.
     * @example
     * // Delete a few GymOperatingHours
     * const { count } = await prisma.gymOperatingHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymOperatingHourDeleteManyArgs>(args?: SelectSubset<T, GymOperatingHourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymOperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymOperatingHours
     * const gymOperatingHour = await prisma.gymOperatingHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymOperatingHourUpdateManyArgs>(args: SelectSubset<T, GymOperatingHourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymOperatingHours and returns the data updated in the database.
     * @param {GymOperatingHourUpdateManyAndReturnArgs} args - Arguments to update many GymOperatingHours.
     * @example
     * // Update many GymOperatingHours
     * const gymOperatingHour = await prisma.gymOperatingHour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymOperatingHours and only return the `id`
     * const gymOperatingHourWithIdOnly = await prisma.gymOperatingHour.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymOperatingHourUpdateManyAndReturnArgs>(args: SelectSubset<T, GymOperatingHourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymOperatingHour.
     * @param {GymOperatingHourUpsertArgs} args - Arguments to update or create a GymOperatingHour.
     * @example
     * // Update or create a GymOperatingHour
     * const gymOperatingHour = await prisma.gymOperatingHour.upsert({
     *   create: {
     *     // ... data to create a GymOperatingHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymOperatingHour we want to update
     *   }
     * })
     */
    upsert<T extends GymOperatingHourUpsertArgs>(args: SelectSubset<T, GymOperatingHourUpsertArgs<ExtArgs>>): Prisma__GymOperatingHourClient<$Result.GetResult<Prisma.$GymOperatingHourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymOperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourCountArgs} args - Arguments to filter GymOperatingHours to count.
     * @example
     * // Count the number of GymOperatingHours
     * const count = await prisma.gymOperatingHour.count({
     *   where: {
     *     // ... the filter for the GymOperatingHours we want to count
     *   }
     * })
    **/
    count<T extends GymOperatingHourCountArgs>(
      args?: Subset<T, GymOperatingHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymOperatingHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymOperatingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymOperatingHourAggregateArgs>(args: Subset<T, GymOperatingHourAggregateArgs>): Prisma.PrismaPromise<GetGymOperatingHourAggregateType<T>>

    /**
     * Group by GymOperatingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymOperatingHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymOperatingHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymOperatingHourGroupByArgs['orderBy'] }
        : { orderBy?: GymOperatingHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymOperatingHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymOperatingHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymOperatingHour model
   */
  readonly fields: GymOperatingHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymOperatingHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymOperatingHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymOperatingHour model
   */
  interface GymOperatingHourFieldRefs {
    readonly id: FieldRef<"GymOperatingHour", 'String'>
    readonly gymId: FieldRef<"GymOperatingHour", 'String'>
    readonly dayOfWeek: FieldRef<"GymOperatingHour", 'Int'>
    readonly openTime: FieldRef<"GymOperatingHour", 'String'>
    readonly closeTime: FieldRef<"GymOperatingHour", 'String'>
    readonly isClosed: FieldRef<"GymOperatingHour", 'Boolean'>
    readonly notes: FieldRef<"GymOperatingHour", 'String'>
    readonly createdAt: FieldRef<"GymOperatingHour", 'DateTime'>
    readonly updatedAt: FieldRef<"GymOperatingHour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymOperatingHour findUnique
   */
  export type GymOperatingHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which GymOperatingHour to fetch.
     */
    where: GymOperatingHourWhereUniqueInput
  }

  /**
   * GymOperatingHour findUniqueOrThrow
   */
  export type GymOperatingHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which GymOperatingHour to fetch.
     */
    where: GymOperatingHourWhereUniqueInput
  }

  /**
   * GymOperatingHour findFirst
   */
  export type GymOperatingHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which GymOperatingHour to fetch.
     */
    where?: GymOperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymOperatingHours to fetch.
     */
    orderBy?: GymOperatingHourOrderByWithRelationInput | GymOperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymOperatingHours.
     */
    cursor?: GymOperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymOperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymOperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymOperatingHours.
     */
    distinct?: GymOperatingHourScalarFieldEnum | GymOperatingHourScalarFieldEnum[]
  }

  /**
   * GymOperatingHour findFirstOrThrow
   */
  export type GymOperatingHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which GymOperatingHour to fetch.
     */
    where?: GymOperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymOperatingHours to fetch.
     */
    orderBy?: GymOperatingHourOrderByWithRelationInput | GymOperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymOperatingHours.
     */
    cursor?: GymOperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymOperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymOperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymOperatingHours.
     */
    distinct?: GymOperatingHourScalarFieldEnum | GymOperatingHourScalarFieldEnum[]
  }

  /**
   * GymOperatingHour findMany
   */
  export type GymOperatingHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which GymOperatingHours to fetch.
     */
    where?: GymOperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymOperatingHours to fetch.
     */
    orderBy?: GymOperatingHourOrderByWithRelationInput | GymOperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymOperatingHours.
     */
    cursor?: GymOperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymOperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymOperatingHours.
     */
    skip?: number
    distinct?: GymOperatingHourScalarFieldEnum | GymOperatingHourScalarFieldEnum[]
  }

  /**
   * GymOperatingHour create
   */
  export type GymOperatingHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * The data needed to create a GymOperatingHour.
     */
    data: XOR<GymOperatingHourCreateInput, GymOperatingHourUncheckedCreateInput>
  }

  /**
   * GymOperatingHour createMany
   */
  export type GymOperatingHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymOperatingHours.
     */
    data: GymOperatingHourCreateManyInput | GymOperatingHourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymOperatingHour createManyAndReturn
   */
  export type GymOperatingHourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * The data used to create many GymOperatingHours.
     */
    data: GymOperatingHourCreateManyInput | GymOperatingHourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymOperatingHour update
   */
  export type GymOperatingHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * The data needed to update a GymOperatingHour.
     */
    data: XOR<GymOperatingHourUpdateInput, GymOperatingHourUncheckedUpdateInput>
    /**
     * Choose, which GymOperatingHour to update.
     */
    where: GymOperatingHourWhereUniqueInput
  }

  /**
   * GymOperatingHour updateMany
   */
  export type GymOperatingHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymOperatingHours.
     */
    data: XOR<GymOperatingHourUpdateManyMutationInput, GymOperatingHourUncheckedUpdateManyInput>
    /**
     * Filter which GymOperatingHours to update
     */
    where?: GymOperatingHourWhereInput
    /**
     * Limit how many GymOperatingHours to update.
     */
    limit?: number
  }

  /**
   * GymOperatingHour updateManyAndReturn
   */
  export type GymOperatingHourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * The data used to update GymOperatingHours.
     */
    data: XOR<GymOperatingHourUpdateManyMutationInput, GymOperatingHourUncheckedUpdateManyInput>
    /**
     * Filter which GymOperatingHours to update
     */
    where?: GymOperatingHourWhereInput
    /**
     * Limit how many GymOperatingHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymOperatingHour upsert
   */
  export type GymOperatingHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * The filter to search for the GymOperatingHour to update in case it exists.
     */
    where: GymOperatingHourWhereUniqueInput
    /**
     * In case the GymOperatingHour found by the `where` argument doesn't exist, create a new GymOperatingHour with this data.
     */
    create: XOR<GymOperatingHourCreateInput, GymOperatingHourUncheckedCreateInput>
    /**
     * In case the GymOperatingHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymOperatingHourUpdateInput, GymOperatingHourUncheckedUpdateInput>
  }

  /**
   * GymOperatingHour delete
   */
  export type GymOperatingHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
    /**
     * Filter which GymOperatingHour to delete.
     */
    where: GymOperatingHourWhereUniqueInput
  }

  /**
   * GymOperatingHour deleteMany
   */
  export type GymOperatingHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymOperatingHours to delete
     */
    where?: GymOperatingHourWhereInput
    /**
     * Limit how many GymOperatingHours to delete.
     */
    limit?: number
  }

  /**
   * GymOperatingHour without action
   */
  export type GymOperatingHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymOperatingHour
     */
    select?: GymOperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymOperatingHour
     */
    omit?: GymOperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymOperatingHourInclude<ExtArgs> | null
  }


  /**
   * Model GymCrowdLevel
   */

  export type AggregateGymCrowdLevel = {
    _count: GymCrowdLevelCountAggregateOutputType | null
    _avg: GymCrowdLevelAvgAggregateOutputType | null
    _sum: GymCrowdLevelSumAggregateOutputType | null
    _min: GymCrowdLevelMinAggregateOutputType | null
    _max: GymCrowdLevelMaxAggregateOutputType | null
  }

  export type GymCrowdLevelAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type GymCrowdLevelSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type GymCrowdLevelMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    timeSlot: string | null
    dayOfWeek: number | null
    crowdLevel: string | null
    source: string | null
    reportedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymCrowdLevelMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    timeSlot: string | null
    dayOfWeek: number | null
    crowdLevel: string | null
    source: string | null
    reportedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymCrowdLevelCountAggregateOutputType = {
    id: number
    gymId: number
    timeSlot: number
    dayOfWeek: number
    crowdLevel: number
    source: number
    reportedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymCrowdLevelAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type GymCrowdLevelSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type GymCrowdLevelMinAggregateInputType = {
    id?: true
    gymId?: true
    timeSlot?: true
    dayOfWeek?: true
    crowdLevel?: true
    source?: true
    reportedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymCrowdLevelMaxAggregateInputType = {
    id?: true
    gymId?: true
    timeSlot?: true
    dayOfWeek?: true
    crowdLevel?: true
    source?: true
    reportedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymCrowdLevelCountAggregateInputType = {
    id?: true
    gymId?: true
    timeSlot?: true
    dayOfWeek?: true
    crowdLevel?: true
    source?: true
    reportedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymCrowdLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymCrowdLevel to aggregate.
     */
    where?: GymCrowdLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymCrowdLevels to fetch.
     */
    orderBy?: GymCrowdLevelOrderByWithRelationInput | GymCrowdLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymCrowdLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymCrowdLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymCrowdLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymCrowdLevels
    **/
    _count?: true | GymCrowdLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymCrowdLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymCrowdLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymCrowdLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymCrowdLevelMaxAggregateInputType
  }

  export type GetGymCrowdLevelAggregateType<T extends GymCrowdLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateGymCrowdLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymCrowdLevel[P]>
      : GetScalarType<T[P], AggregateGymCrowdLevel[P]>
  }




  export type GymCrowdLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymCrowdLevelWhereInput
    orderBy?: GymCrowdLevelOrderByWithAggregationInput | GymCrowdLevelOrderByWithAggregationInput[]
    by: GymCrowdLevelScalarFieldEnum[] | GymCrowdLevelScalarFieldEnum
    having?: GymCrowdLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymCrowdLevelCountAggregateInputType | true
    _avg?: GymCrowdLevelAvgAggregateInputType
    _sum?: GymCrowdLevelSumAggregateInputType
    _min?: GymCrowdLevelMinAggregateInputType
    _max?: GymCrowdLevelMaxAggregateInputType
  }

  export type GymCrowdLevelGroupByOutputType = {
    id: string
    gymId: string
    timeSlot: string
    dayOfWeek: number | null
    crowdLevel: string
    source: string
    reportedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GymCrowdLevelCountAggregateOutputType | null
    _avg: GymCrowdLevelAvgAggregateOutputType | null
    _sum: GymCrowdLevelSumAggregateOutputType | null
    _min: GymCrowdLevelMinAggregateOutputType | null
    _max: GymCrowdLevelMaxAggregateOutputType | null
  }

  type GetGymCrowdLevelGroupByPayload<T extends GymCrowdLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymCrowdLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymCrowdLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymCrowdLevelGroupByOutputType[P]>
            : GetScalarType<T[P], GymCrowdLevelGroupByOutputType[P]>
        }
      >
    >


  export type GymCrowdLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    timeSlot?: boolean
    dayOfWeek?: boolean
    crowdLevel?: boolean
    source?: boolean
    reportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymCrowdLevel"]>

  export type GymCrowdLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    timeSlot?: boolean
    dayOfWeek?: boolean
    crowdLevel?: boolean
    source?: boolean
    reportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymCrowdLevel"]>

  export type GymCrowdLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    timeSlot?: boolean
    dayOfWeek?: boolean
    crowdLevel?: boolean
    source?: boolean
    reportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymCrowdLevel"]>

  export type GymCrowdLevelSelectScalar = {
    id?: boolean
    gymId?: boolean
    timeSlot?: boolean
    dayOfWeek?: boolean
    crowdLevel?: boolean
    source?: boolean
    reportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymCrowdLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "timeSlot" | "dayOfWeek" | "crowdLevel" | "source" | "reportedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["gymCrowdLevel"]>
  export type GymCrowdLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymCrowdLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type GymCrowdLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $GymCrowdLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymCrowdLevel"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      timeSlot: string
      dayOfWeek: number | null
      crowdLevel: string
      source: string
      reportedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymCrowdLevel"]>
    composites: {}
  }

  type GymCrowdLevelGetPayload<S extends boolean | null | undefined | GymCrowdLevelDefaultArgs> = $Result.GetResult<Prisma.$GymCrowdLevelPayload, S>

  type GymCrowdLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GymCrowdLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GymCrowdLevelCountAggregateInputType | true
    }

  export interface GymCrowdLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymCrowdLevel'], meta: { name: 'GymCrowdLevel' } }
    /**
     * Find zero or one GymCrowdLevel that matches the filter.
     * @param {GymCrowdLevelFindUniqueArgs} args - Arguments to find a GymCrowdLevel
     * @example
     * // Get one GymCrowdLevel
     * const gymCrowdLevel = await prisma.gymCrowdLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymCrowdLevelFindUniqueArgs>(args: SelectSubset<T, GymCrowdLevelFindUniqueArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GymCrowdLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GymCrowdLevelFindUniqueOrThrowArgs} args - Arguments to find a GymCrowdLevel
     * @example
     * // Get one GymCrowdLevel
     * const gymCrowdLevel = await prisma.gymCrowdLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymCrowdLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, GymCrowdLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymCrowdLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelFindFirstArgs} args - Arguments to find a GymCrowdLevel
     * @example
     * // Get one GymCrowdLevel
     * const gymCrowdLevel = await prisma.gymCrowdLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymCrowdLevelFindFirstArgs>(args?: SelectSubset<T, GymCrowdLevelFindFirstArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GymCrowdLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelFindFirstOrThrowArgs} args - Arguments to find a GymCrowdLevel
     * @example
     * // Get one GymCrowdLevel
     * const gymCrowdLevel = await prisma.gymCrowdLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymCrowdLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, GymCrowdLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GymCrowdLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymCrowdLevels
     * const gymCrowdLevels = await prisma.gymCrowdLevel.findMany()
     * 
     * // Get first 10 GymCrowdLevels
     * const gymCrowdLevels = await prisma.gymCrowdLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymCrowdLevelWithIdOnly = await prisma.gymCrowdLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymCrowdLevelFindManyArgs>(args?: SelectSubset<T, GymCrowdLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GymCrowdLevel.
     * @param {GymCrowdLevelCreateArgs} args - Arguments to create a GymCrowdLevel.
     * @example
     * // Create one GymCrowdLevel
     * const GymCrowdLevel = await prisma.gymCrowdLevel.create({
     *   data: {
     *     // ... data to create a GymCrowdLevel
     *   }
     * })
     * 
     */
    create<T extends GymCrowdLevelCreateArgs>(args: SelectSubset<T, GymCrowdLevelCreateArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GymCrowdLevels.
     * @param {GymCrowdLevelCreateManyArgs} args - Arguments to create many GymCrowdLevels.
     * @example
     * // Create many GymCrowdLevels
     * const gymCrowdLevel = await prisma.gymCrowdLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymCrowdLevelCreateManyArgs>(args?: SelectSubset<T, GymCrowdLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymCrowdLevels and returns the data saved in the database.
     * @param {GymCrowdLevelCreateManyAndReturnArgs} args - Arguments to create many GymCrowdLevels.
     * @example
     * // Create many GymCrowdLevels
     * const gymCrowdLevel = await prisma.gymCrowdLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymCrowdLevels and only return the `id`
     * const gymCrowdLevelWithIdOnly = await prisma.gymCrowdLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymCrowdLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, GymCrowdLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GymCrowdLevel.
     * @param {GymCrowdLevelDeleteArgs} args - Arguments to delete one GymCrowdLevel.
     * @example
     * // Delete one GymCrowdLevel
     * const GymCrowdLevel = await prisma.gymCrowdLevel.delete({
     *   where: {
     *     // ... filter to delete one GymCrowdLevel
     *   }
     * })
     * 
     */
    delete<T extends GymCrowdLevelDeleteArgs>(args: SelectSubset<T, GymCrowdLevelDeleteArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GymCrowdLevel.
     * @param {GymCrowdLevelUpdateArgs} args - Arguments to update one GymCrowdLevel.
     * @example
     * // Update one GymCrowdLevel
     * const gymCrowdLevel = await prisma.gymCrowdLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymCrowdLevelUpdateArgs>(args: SelectSubset<T, GymCrowdLevelUpdateArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GymCrowdLevels.
     * @param {GymCrowdLevelDeleteManyArgs} args - Arguments to filter GymCrowdLevels to delete.
     * @example
     * // Delete a few GymCrowdLevels
     * const { count } = await prisma.gymCrowdLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymCrowdLevelDeleteManyArgs>(args?: SelectSubset<T, GymCrowdLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymCrowdLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymCrowdLevels
     * const gymCrowdLevel = await prisma.gymCrowdLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymCrowdLevelUpdateManyArgs>(args: SelectSubset<T, GymCrowdLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymCrowdLevels and returns the data updated in the database.
     * @param {GymCrowdLevelUpdateManyAndReturnArgs} args - Arguments to update many GymCrowdLevels.
     * @example
     * // Update many GymCrowdLevels
     * const gymCrowdLevel = await prisma.gymCrowdLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GymCrowdLevels and only return the `id`
     * const gymCrowdLevelWithIdOnly = await prisma.gymCrowdLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GymCrowdLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, GymCrowdLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GymCrowdLevel.
     * @param {GymCrowdLevelUpsertArgs} args - Arguments to update or create a GymCrowdLevel.
     * @example
     * // Update or create a GymCrowdLevel
     * const gymCrowdLevel = await prisma.gymCrowdLevel.upsert({
     *   create: {
     *     // ... data to create a GymCrowdLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymCrowdLevel we want to update
     *   }
     * })
     */
    upsert<T extends GymCrowdLevelUpsertArgs>(args: SelectSubset<T, GymCrowdLevelUpsertArgs<ExtArgs>>): Prisma__GymCrowdLevelClient<$Result.GetResult<Prisma.$GymCrowdLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GymCrowdLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelCountArgs} args - Arguments to filter GymCrowdLevels to count.
     * @example
     * // Count the number of GymCrowdLevels
     * const count = await prisma.gymCrowdLevel.count({
     *   where: {
     *     // ... the filter for the GymCrowdLevels we want to count
     *   }
     * })
    **/
    count<T extends GymCrowdLevelCountArgs>(
      args?: Subset<T, GymCrowdLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymCrowdLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymCrowdLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymCrowdLevelAggregateArgs>(args: Subset<T, GymCrowdLevelAggregateArgs>): Prisma.PrismaPromise<GetGymCrowdLevelAggregateType<T>>

    /**
     * Group by GymCrowdLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymCrowdLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymCrowdLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymCrowdLevelGroupByArgs['orderBy'] }
        : { orderBy?: GymCrowdLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymCrowdLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymCrowdLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymCrowdLevel model
   */
  readonly fields: GymCrowdLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymCrowdLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymCrowdLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymCrowdLevel model
   */
  interface GymCrowdLevelFieldRefs {
    readonly id: FieldRef<"GymCrowdLevel", 'String'>
    readonly gymId: FieldRef<"GymCrowdLevel", 'String'>
    readonly timeSlot: FieldRef<"GymCrowdLevel", 'String'>
    readonly dayOfWeek: FieldRef<"GymCrowdLevel", 'Int'>
    readonly crowdLevel: FieldRef<"GymCrowdLevel", 'String'>
    readonly source: FieldRef<"GymCrowdLevel", 'String'>
    readonly reportedAt: FieldRef<"GymCrowdLevel", 'DateTime'>
    readonly createdAt: FieldRef<"GymCrowdLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"GymCrowdLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymCrowdLevel findUnique
   */
  export type GymCrowdLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * Filter, which GymCrowdLevel to fetch.
     */
    where: GymCrowdLevelWhereUniqueInput
  }

  /**
   * GymCrowdLevel findUniqueOrThrow
   */
  export type GymCrowdLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * Filter, which GymCrowdLevel to fetch.
     */
    where: GymCrowdLevelWhereUniqueInput
  }

  /**
   * GymCrowdLevel findFirst
   */
  export type GymCrowdLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * Filter, which GymCrowdLevel to fetch.
     */
    where?: GymCrowdLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymCrowdLevels to fetch.
     */
    orderBy?: GymCrowdLevelOrderByWithRelationInput | GymCrowdLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymCrowdLevels.
     */
    cursor?: GymCrowdLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymCrowdLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymCrowdLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymCrowdLevels.
     */
    distinct?: GymCrowdLevelScalarFieldEnum | GymCrowdLevelScalarFieldEnum[]
  }

  /**
   * GymCrowdLevel findFirstOrThrow
   */
  export type GymCrowdLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * Filter, which GymCrowdLevel to fetch.
     */
    where?: GymCrowdLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymCrowdLevels to fetch.
     */
    orderBy?: GymCrowdLevelOrderByWithRelationInput | GymCrowdLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymCrowdLevels.
     */
    cursor?: GymCrowdLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymCrowdLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymCrowdLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymCrowdLevels.
     */
    distinct?: GymCrowdLevelScalarFieldEnum | GymCrowdLevelScalarFieldEnum[]
  }

  /**
   * GymCrowdLevel findMany
   */
  export type GymCrowdLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * Filter, which GymCrowdLevels to fetch.
     */
    where?: GymCrowdLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymCrowdLevels to fetch.
     */
    orderBy?: GymCrowdLevelOrderByWithRelationInput | GymCrowdLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymCrowdLevels.
     */
    cursor?: GymCrowdLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymCrowdLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymCrowdLevels.
     */
    skip?: number
    distinct?: GymCrowdLevelScalarFieldEnum | GymCrowdLevelScalarFieldEnum[]
  }

  /**
   * GymCrowdLevel create
   */
  export type GymCrowdLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a GymCrowdLevel.
     */
    data: XOR<GymCrowdLevelCreateInput, GymCrowdLevelUncheckedCreateInput>
  }

  /**
   * GymCrowdLevel createMany
   */
  export type GymCrowdLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymCrowdLevels.
     */
    data: GymCrowdLevelCreateManyInput | GymCrowdLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymCrowdLevel createManyAndReturn
   */
  export type GymCrowdLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * The data used to create many GymCrowdLevels.
     */
    data: GymCrowdLevelCreateManyInput | GymCrowdLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymCrowdLevel update
   */
  export type GymCrowdLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a GymCrowdLevel.
     */
    data: XOR<GymCrowdLevelUpdateInput, GymCrowdLevelUncheckedUpdateInput>
    /**
     * Choose, which GymCrowdLevel to update.
     */
    where: GymCrowdLevelWhereUniqueInput
  }

  /**
   * GymCrowdLevel updateMany
   */
  export type GymCrowdLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymCrowdLevels.
     */
    data: XOR<GymCrowdLevelUpdateManyMutationInput, GymCrowdLevelUncheckedUpdateManyInput>
    /**
     * Filter which GymCrowdLevels to update
     */
    where?: GymCrowdLevelWhereInput
    /**
     * Limit how many GymCrowdLevels to update.
     */
    limit?: number
  }

  /**
   * GymCrowdLevel updateManyAndReturn
   */
  export type GymCrowdLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * The data used to update GymCrowdLevels.
     */
    data: XOR<GymCrowdLevelUpdateManyMutationInput, GymCrowdLevelUncheckedUpdateManyInput>
    /**
     * Filter which GymCrowdLevels to update
     */
    where?: GymCrowdLevelWhereInput
    /**
     * Limit how many GymCrowdLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymCrowdLevel upsert
   */
  export type GymCrowdLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the GymCrowdLevel to update in case it exists.
     */
    where: GymCrowdLevelWhereUniqueInput
    /**
     * In case the GymCrowdLevel found by the `where` argument doesn't exist, create a new GymCrowdLevel with this data.
     */
    create: XOR<GymCrowdLevelCreateInput, GymCrowdLevelUncheckedCreateInput>
    /**
     * In case the GymCrowdLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymCrowdLevelUpdateInput, GymCrowdLevelUncheckedUpdateInput>
  }

  /**
   * GymCrowdLevel delete
   */
  export type GymCrowdLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
    /**
     * Filter which GymCrowdLevel to delete.
     */
    where: GymCrowdLevelWhereUniqueInput
  }

  /**
   * GymCrowdLevel deleteMany
   */
  export type GymCrowdLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymCrowdLevels to delete
     */
    where?: GymCrowdLevelWhereInput
    /**
     * Limit how many GymCrowdLevels to delete.
     */
    limit?: number
  }

  /**
   * GymCrowdLevel without action
   */
  export type GymCrowdLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymCrowdLevel
     */
    select?: GymCrowdLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GymCrowdLevel
     */
    omit?: GymCrowdLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymCrowdLevelInclude<ExtArgs> | null
  }


  /**
   * Model ReviewTag
   */

  export type AggregateReviewTag = {
    _count: ReviewTagCountAggregateOutputType | null
    _avg: ReviewTagAvgAggregateOutputType | null
    _sum: ReviewTagSumAggregateOutputType | null
    _min: ReviewTagMinAggregateOutputType | null
    _max: ReviewTagMaxAggregateOutputType | null
  }

  export type ReviewTagAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ReviewTagSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ReviewTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ReviewTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ReviewTagCountAggregateOutputType = {
    id: number
    name: number
    category: number
    displayOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ReviewTagAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ReviewTagSumAggregateInputType = {
    displayOrder?: true
  }

  export type ReviewTagMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type ReviewTagMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type ReviewTagCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewTag to aggregate.
     */
    where?: ReviewTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTags to fetch.
     */
    orderBy?: ReviewTagOrderByWithRelationInput | ReviewTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewTags
    **/
    _count?: true | ReviewTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewTagMaxAggregateInputType
  }

  export type GetReviewTagAggregateType<T extends ReviewTagAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewTag[P]>
      : GetScalarType<T[P], AggregateReviewTag[P]>
  }




  export type ReviewTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewTagWhereInput
    orderBy?: ReviewTagOrderByWithAggregationInput | ReviewTagOrderByWithAggregationInput[]
    by: ReviewTagScalarFieldEnum[] | ReviewTagScalarFieldEnum
    having?: ReviewTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewTagCountAggregateInputType | true
    _avg?: ReviewTagAvgAggregateInputType
    _sum?: ReviewTagSumAggregateInputType
    _min?: ReviewTagMinAggregateInputType
    _max?: ReviewTagMaxAggregateInputType
  }

  export type ReviewTagGroupByOutputType = {
    id: string
    name: string
    category: string | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    _count: ReviewTagCountAggregateOutputType | null
    _avg: ReviewTagAvgAggregateOutputType | null
    _sum: ReviewTagSumAggregateOutputType | null
    _min: ReviewTagMinAggregateOutputType | null
    _max: ReviewTagMaxAggregateOutputType | null
  }

  type GetReviewTagGroupByPayload<T extends ReviewTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewTagGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewTagGroupByOutputType[P]>
        }
      >
    >


  export type ReviewTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    reviewTagMappings?: boolean | ReviewTag$reviewTagMappingsArgs<ExtArgs>
    _count?: boolean | ReviewTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewTag"]>

  export type ReviewTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["reviewTag"]>

  export type ReviewTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["reviewTag"]>

  export type ReviewTagSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ReviewTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "displayOrder" | "isActive" | "createdAt", ExtArgs["result"]["reviewTag"]>
  export type ReviewTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewTagMappings?: boolean | ReviewTag$reviewTagMappingsArgs<ExtArgs>
    _count?: boolean | ReviewTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ReviewTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReviewTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewTag"
    objects: {
      reviewTagMappings: Prisma.$ReviewTagMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["reviewTag"]>
    composites: {}
  }

  type ReviewTagGetPayload<S extends boolean | null | undefined | ReviewTagDefaultArgs> = $Result.GetResult<Prisma.$ReviewTagPayload, S>

  type ReviewTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewTagCountAggregateInputType | true
    }

  export interface ReviewTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewTag'], meta: { name: 'ReviewTag' } }
    /**
     * Find zero or one ReviewTag that matches the filter.
     * @param {ReviewTagFindUniqueArgs} args - Arguments to find a ReviewTag
     * @example
     * // Get one ReviewTag
     * const reviewTag = await prisma.reviewTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewTagFindUniqueArgs>(args: SelectSubset<T, ReviewTagFindUniqueArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewTagFindUniqueOrThrowArgs} args - Arguments to find a ReviewTag
     * @example
     * // Get one ReviewTag
     * const reviewTag = await prisma.reviewTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagFindFirstArgs} args - Arguments to find a ReviewTag
     * @example
     * // Get one ReviewTag
     * const reviewTag = await prisma.reviewTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewTagFindFirstArgs>(args?: SelectSubset<T, ReviewTagFindFirstArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagFindFirstOrThrowArgs} args - Arguments to find a ReviewTag
     * @example
     * // Get one ReviewTag
     * const reviewTag = await prisma.reviewTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewTags
     * const reviewTags = await prisma.reviewTag.findMany()
     * 
     * // Get first 10 ReviewTags
     * const reviewTags = await prisma.reviewTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewTagWithIdOnly = await prisma.reviewTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewTagFindManyArgs>(args?: SelectSubset<T, ReviewTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewTag.
     * @param {ReviewTagCreateArgs} args - Arguments to create a ReviewTag.
     * @example
     * // Create one ReviewTag
     * const ReviewTag = await prisma.reviewTag.create({
     *   data: {
     *     // ... data to create a ReviewTag
     *   }
     * })
     * 
     */
    create<T extends ReviewTagCreateArgs>(args: SelectSubset<T, ReviewTagCreateArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewTags.
     * @param {ReviewTagCreateManyArgs} args - Arguments to create many ReviewTags.
     * @example
     * // Create many ReviewTags
     * const reviewTag = await prisma.reviewTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewTagCreateManyArgs>(args?: SelectSubset<T, ReviewTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewTags and returns the data saved in the database.
     * @param {ReviewTagCreateManyAndReturnArgs} args - Arguments to create many ReviewTags.
     * @example
     * // Create many ReviewTags
     * const reviewTag = await prisma.reviewTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewTags and only return the `id`
     * const reviewTagWithIdOnly = await prisma.reviewTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewTag.
     * @param {ReviewTagDeleteArgs} args - Arguments to delete one ReviewTag.
     * @example
     * // Delete one ReviewTag
     * const ReviewTag = await prisma.reviewTag.delete({
     *   where: {
     *     // ... filter to delete one ReviewTag
     *   }
     * })
     * 
     */
    delete<T extends ReviewTagDeleteArgs>(args: SelectSubset<T, ReviewTagDeleteArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewTag.
     * @param {ReviewTagUpdateArgs} args - Arguments to update one ReviewTag.
     * @example
     * // Update one ReviewTag
     * const reviewTag = await prisma.reviewTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewTagUpdateArgs>(args: SelectSubset<T, ReviewTagUpdateArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewTags.
     * @param {ReviewTagDeleteManyArgs} args - Arguments to filter ReviewTags to delete.
     * @example
     * // Delete a few ReviewTags
     * const { count } = await prisma.reviewTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewTagDeleteManyArgs>(args?: SelectSubset<T, ReviewTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewTags
     * const reviewTag = await prisma.reviewTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewTagUpdateManyArgs>(args: SelectSubset<T, ReviewTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewTags and returns the data updated in the database.
     * @param {ReviewTagUpdateManyAndReturnArgs} args - Arguments to update many ReviewTags.
     * @example
     * // Update many ReviewTags
     * const reviewTag = await prisma.reviewTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewTags and only return the `id`
     * const reviewTagWithIdOnly = await prisma.reviewTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewTag.
     * @param {ReviewTagUpsertArgs} args - Arguments to update or create a ReviewTag.
     * @example
     * // Update or create a ReviewTag
     * const reviewTag = await prisma.reviewTag.upsert({
     *   create: {
     *     // ... data to create a ReviewTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewTag we want to update
     *   }
     * })
     */
    upsert<T extends ReviewTagUpsertArgs>(args: SelectSubset<T, ReviewTagUpsertArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagCountArgs} args - Arguments to filter ReviewTags to count.
     * @example
     * // Count the number of ReviewTags
     * const count = await prisma.reviewTag.count({
     *   where: {
     *     // ... the filter for the ReviewTags we want to count
     *   }
     * })
    **/
    count<T extends ReviewTagCountArgs>(
      args?: Subset<T, ReviewTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewTagAggregateArgs>(args: Subset<T, ReviewTagAggregateArgs>): Prisma.PrismaPromise<GetReviewTagAggregateType<T>>

    /**
     * Group by ReviewTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewTagGroupByArgs['orderBy'] }
        : { orderBy?: ReviewTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewTag model
   */
  readonly fields: ReviewTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewTagMappings<T extends ReviewTag$reviewTagMappingsArgs<ExtArgs> = {}>(args?: Subset<T, ReviewTag$reviewTagMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewTag model
   */
  interface ReviewTagFieldRefs {
    readonly id: FieldRef<"ReviewTag", 'String'>
    readonly name: FieldRef<"ReviewTag", 'String'>
    readonly category: FieldRef<"ReviewTag", 'String'>
    readonly displayOrder: FieldRef<"ReviewTag", 'Int'>
    readonly isActive: FieldRef<"ReviewTag", 'Boolean'>
    readonly createdAt: FieldRef<"ReviewTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewTag findUnique
   */
  export type ReviewTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTag to fetch.
     */
    where: ReviewTagWhereUniqueInput
  }

  /**
   * ReviewTag findUniqueOrThrow
   */
  export type ReviewTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTag to fetch.
     */
    where: ReviewTagWhereUniqueInput
  }

  /**
   * ReviewTag findFirst
   */
  export type ReviewTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTag to fetch.
     */
    where?: ReviewTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTags to fetch.
     */
    orderBy?: ReviewTagOrderByWithRelationInput | ReviewTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewTags.
     */
    cursor?: ReviewTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewTags.
     */
    distinct?: ReviewTagScalarFieldEnum | ReviewTagScalarFieldEnum[]
  }

  /**
   * ReviewTag findFirstOrThrow
   */
  export type ReviewTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTag to fetch.
     */
    where?: ReviewTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTags to fetch.
     */
    orderBy?: ReviewTagOrderByWithRelationInput | ReviewTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewTags.
     */
    cursor?: ReviewTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewTags.
     */
    distinct?: ReviewTagScalarFieldEnum | ReviewTagScalarFieldEnum[]
  }

  /**
   * ReviewTag findMany
   */
  export type ReviewTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTags to fetch.
     */
    where?: ReviewTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTags to fetch.
     */
    orderBy?: ReviewTagOrderByWithRelationInput | ReviewTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewTags.
     */
    cursor?: ReviewTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTags.
     */
    skip?: number
    distinct?: ReviewTagScalarFieldEnum | ReviewTagScalarFieldEnum[]
  }

  /**
   * ReviewTag create
   */
  export type ReviewTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewTag.
     */
    data: XOR<ReviewTagCreateInput, ReviewTagUncheckedCreateInput>
  }

  /**
   * ReviewTag createMany
   */
  export type ReviewTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewTags.
     */
    data: ReviewTagCreateManyInput | ReviewTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewTag createManyAndReturn
   */
  export type ReviewTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewTags.
     */
    data: ReviewTagCreateManyInput | ReviewTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewTag update
   */
  export type ReviewTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewTag.
     */
    data: XOR<ReviewTagUpdateInput, ReviewTagUncheckedUpdateInput>
    /**
     * Choose, which ReviewTag to update.
     */
    where: ReviewTagWhereUniqueInput
  }

  /**
   * ReviewTag updateMany
   */
  export type ReviewTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewTags.
     */
    data: XOR<ReviewTagUpdateManyMutationInput, ReviewTagUncheckedUpdateManyInput>
    /**
     * Filter which ReviewTags to update
     */
    where?: ReviewTagWhereInput
    /**
     * Limit how many ReviewTags to update.
     */
    limit?: number
  }

  /**
   * ReviewTag updateManyAndReturn
   */
  export type ReviewTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * The data used to update ReviewTags.
     */
    data: XOR<ReviewTagUpdateManyMutationInput, ReviewTagUncheckedUpdateManyInput>
    /**
     * Filter which ReviewTags to update
     */
    where?: ReviewTagWhereInput
    /**
     * Limit how many ReviewTags to update.
     */
    limit?: number
  }

  /**
   * ReviewTag upsert
   */
  export type ReviewTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewTag to update in case it exists.
     */
    where: ReviewTagWhereUniqueInput
    /**
     * In case the ReviewTag found by the `where` argument doesn't exist, create a new ReviewTag with this data.
     */
    create: XOR<ReviewTagCreateInput, ReviewTagUncheckedCreateInput>
    /**
     * In case the ReviewTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewTagUpdateInput, ReviewTagUncheckedUpdateInput>
  }

  /**
   * ReviewTag delete
   */
  export type ReviewTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
    /**
     * Filter which ReviewTag to delete.
     */
    where: ReviewTagWhereUniqueInput
  }

  /**
   * ReviewTag deleteMany
   */
  export type ReviewTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewTags to delete
     */
    where?: ReviewTagWhereInput
    /**
     * Limit how many ReviewTags to delete.
     */
    limit?: number
  }

  /**
   * ReviewTag.reviewTagMappings
   */
  export type ReviewTag$reviewTagMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    where?: ReviewTagMappingWhereInput
    orderBy?: ReviewTagMappingOrderByWithRelationInput | ReviewTagMappingOrderByWithRelationInput[]
    cursor?: ReviewTagMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewTagMappingScalarFieldEnum | ReviewTagMappingScalarFieldEnum[]
  }

  /**
   * ReviewTag without action
   */
  export type ReviewTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTag
     */
    select?: ReviewTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTag
     */
    omit?: ReviewTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    gymId: string | null
    userId: string | null
    comment: string | null
    isAdminReview: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    gymId: string | null
    userId: string | null
    comment: string | null
    isAdminReview: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    gymId: number
    userId: number
    comment: number
    isAdminReview: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewMinAggregateInputType = {
    id?: true
    gymId?: true
    userId?: true
    comment?: true
    isAdminReview?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    gymId?: true
    userId?: true
    comment?: true
    isAdminReview?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    gymId?: true
    userId?: true
    comment?: true
    isAdminReview?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    gymId: string
    userId: string | null
    comment: string | null
    isAdminReview: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    userId?: boolean
    comment?: boolean
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
    reviewTagMappings?: boolean | Review$reviewTagMappingsArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    userId?: boolean
    comment?: boolean
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gymId?: boolean
    userId?: boolean
    comment?: boolean
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gym?: boolean | GymDefaultArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    gymId?: boolean
    userId?: boolean
    comment?: boolean
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gymId" | "userId" | "comment" | "isAdminReview" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
    reviewTagMappings?: boolean | Review$reviewTagMappingsArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gym?: boolean | GymDefaultArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      gym: Prisma.$GymPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      reviewTagMappings: Prisma.$ReviewTagMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gymId: string
      userId: string | null
      comment: string | null
      isAdminReview: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Review$userArgs<ExtArgs> = {}>(args?: Subset<T, Review$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviewTagMappings<T extends Review$reviewTagMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Review$reviewTagMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly gymId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly isAdminReview: FieldRef<"Review", 'Boolean'>
    readonly isDeleted: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.user
   */
  export type Review$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Review.reviewTagMappings
   */
  export type Review$reviewTagMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    where?: ReviewTagMappingWhereInput
    orderBy?: ReviewTagMappingOrderByWithRelationInput | ReviewTagMappingOrderByWithRelationInput[]
    cursor?: ReviewTagMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewTagMappingScalarFieldEnum | ReviewTagMappingScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewTagMapping
   */

  export type AggregateReviewTagMapping = {
    _count: ReviewTagMappingCountAggregateOutputType | null
    _min: ReviewTagMappingMinAggregateOutputType | null
    _max: ReviewTagMappingMaxAggregateOutputType | null
  }

  export type ReviewTagMappingMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    reviewTagId: string | null
    createdAt: Date | null
  }

  export type ReviewTagMappingMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    reviewTagId: string | null
    createdAt: Date | null
  }

  export type ReviewTagMappingCountAggregateOutputType = {
    id: number
    reviewId: number
    reviewTagId: number
    createdAt: number
    _all: number
  }


  export type ReviewTagMappingMinAggregateInputType = {
    id?: true
    reviewId?: true
    reviewTagId?: true
    createdAt?: true
  }

  export type ReviewTagMappingMaxAggregateInputType = {
    id?: true
    reviewId?: true
    reviewTagId?: true
    createdAt?: true
  }

  export type ReviewTagMappingCountAggregateInputType = {
    id?: true
    reviewId?: true
    reviewTagId?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewTagMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewTagMapping to aggregate.
     */
    where?: ReviewTagMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTagMappings to fetch.
     */
    orderBy?: ReviewTagMappingOrderByWithRelationInput | ReviewTagMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewTagMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTagMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTagMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewTagMappings
    **/
    _count?: true | ReviewTagMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewTagMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewTagMappingMaxAggregateInputType
  }

  export type GetReviewTagMappingAggregateType<T extends ReviewTagMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewTagMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewTagMapping[P]>
      : GetScalarType<T[P], AggregateReviewTagMapping[P]>
  }




  export type ReviewTagMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewTagMappingWhereInput
    orderBy?: ReviewTagMappingOrderByWithAggregationInput | ReviewTagMappingOrderByWithAggregationInput[]
    by: ReviewTagMappingScalarFieldEnum[] | ReviewTagMappingScalarFieldEnum
    having?: ReviewTagMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewTagMappingCountAggregateInputType | true
    _min?: ReviewTagMappingMinAggregateInputType
    _max?: ReviewTagMappingMaxAggregateInputType
  }

  export type ReviewTagMappingGroupByOutputType = {
    id: string
    reviewId: string
    reviewTagId: string
    createdAt: Date
    _count: ReviewTagMappingCountAggregateOutputType | null
    _min: ReviewTagMappingMinAggregateOutputType | null
    _max: ReviewTagMappingMaxAggregateOutputType | null
  }

  type GetReviewTagMappingGroupByPayload<T extends ReviewTagMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewTagMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewTagMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewTagMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewTagMappingGroupByOutputType[P]>
        }
      >
    >


  export type ReviewTagMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    reviewTagId?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    reviewTag?: boolean | ReviewTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewTagMapping"]>

  export type ReviewTagMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    reviewTagId?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    reviewTag?: boolean | ReviewTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewTagMapping"]>

  export type ReviewTagMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    reviewTagId?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    reviewTag?: boolean | ReviewTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewTagMapping"]>

  export type ReviewTagMappingSelectScalar = {
    id?: boolean
    reviewId?: boolean
    reviewTagId?: boolean
    createdAt?: boolean
  }

  export type ReviewTagMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "reviewTagId" | "createdAt", ExtArgs["result"]["reviewTagMapping"]>
  export type ReviewTagMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    reviewTag?: boolean | ReviewTagDefaultArgs<ExtArgs>
  }
  export type ReviewTagMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    reviewTag?: boolean | ReviewTagDefaultArgs<ExtArgs>
  }
  export type ReviewTagMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    reviewTag?: boolean | ReviewTagDefaultArgs<ExtArgs>
  }

  export type $ReviewTagMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewTagMapping"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      reviewTag: Prisma.$ReviewTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      reviewTagId: string
      createdAt: Date
    }, ExtArgs["result"]["reviewTagMapping"]>
    composites: {}
  }

  type ReviewTagMappingGetPayload<S extends boolean | null | undefined | ReviewTagMappingDefaultArgs> = $Result.GetResult<Prisma.$ReviewTagMappingPayload, S>

  type ReviewTagMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewTagMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewTagMappingCountAggregateInputType | true
    }

  export interface ReviewTagMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewTagMapping'], meta: { name: 'ReviewTagMapping' } }
    /**
     * Find zero or one ReviewTagMapping that matches the filter.
     * @param {ReviewTagMappingFindUniqueArgs} args - Arguments to find a ReviewTagMapping
     * @example
     * // Get one ReviewTagMapping
     * const reviewTagMapping = await prisma.reviewTagMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewTagMappingFindUniqueArgs>(args: SelectSubset<T, ReviewTagMappingFindUniqueArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewTagMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewTagMappingFindUniqueOrThrowArgs} args - Arguments to find a ReviewTagMapping
     * @example
     * // Get one ReviewTagMapping
     * const reviewTagMapping = await prisma.reviewTagMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewTagMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewTagMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewTagMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingFindFirstArgs} args - Arguments to find a ReviewTagMapping
     * @example
     * // Get one ReviewTagMapping
     * const reviewTagMapping = await prisma.reviewTagMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewTagMappingFindFirstArgs>(args?: SelectSubset<T, ReviewTagMappingFindFirstArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewTagMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingFindFirstOrThrowArgs} args - Arguments to find a ReviewTagMapping
     * @example
     * // Get one ReviewTagMapping
     * const reviewTagMapping = await prisma.reviewTagMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewTagMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewTagMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewTagMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewTagMappings
     * const reviewTagMappings = await prisma.reviewTagMapping.findMany()
     * 
     * // Get first 10 ReviewTagMappings
     * const reviewTagMappings = await prisma.reviewTagMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewTagMappingWithIdOnly = await prisma.reviewTagMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewTagMappingFindManyArgs>(args?: SelectSubset<T, ReviewTagMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewTagMapping.
     * @param {ReviewTagMappingCreateArgs} args - Arguments to create a ReviewTagMapping.
     * @example
     * // Create one ReviewTagMapping
     * const ReviewTagMapping = await prisma.reviewTagMapping.create({
     *   data: {
     *     // ... data to create a ReviewTagMapping
     *   }
     * })
     * 
     */
    create<T extends ReviewTagMappingCreateArgs>(args: SelectSubset<T, ReviewTagMappingCreateArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewTagMappings.
     * @param {ReviewTagMappingCreateManyArgs} args - Arguments to create many ReviewTagMappings.
     * @example
     * // Create many ReviewTagMappings
     * const reviewTagMapping = await prisma.reviewTagMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewTagMappingCreateManyArgs>(args?: SelectSubset<T, ReviewTagMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewTagMappings and returns the data saved in the database.
     * @param {ReviewTagMappingCreateManyAndReturnArgs} args - Arguments to create many ReviewTagMappings.
     * @example
     * // Create many ReviewTagMappings
     * const reviewTagMapping = await prisma.reviewTagMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewTagMappings and only return the `id`
     * const reviewTagMappingWithIdOnly = await prisma.reviewTagMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewTagMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewTagMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewTagMapping.
     * @param {ReviewTagMappingDeleteArgs} args - Arguments to delete one ReviewTagMapping.
     * @example
     * // Delete one ReviewTagMapping
     * const ReviewTagMapping = await prisma.reviewTagMapping.delete({
     *   where: {
     *     // ... filter to delete one ReviewTagMapping
     *   }
     * })
     * 
     */
    delete<T extends ReviewTagMappingDeleteArgs>(args: SelectSubset<T, ReviewTagMappingDeleteArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewTagMapping.
     * @param {ReviewTagMappingUpdateArgs} args - Arguments to update one ReviewTagMapping.
     * @example
     * // Update one ReviewTagMapping
     * const reviewTagMapping = await prisma.reviewTagMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewTagMappingUpdateArgs>(args: SelectSubset<T, ReviewTagMappingUpdateArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewTagMappings.
     * @param {ReviewTagMappingDeleteManyArgs} args - Arguments to filter ReviewTagMappings to delete.
     * @example
     * // Delete a few ReviewTagMappings
     * const { count } = await prisma.reviewTagMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewTagMappingDeleteManyArgs>(args?: SelectSubset<T, ReviewTagMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewTagMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewTagMappings
     * const reviewTagMapping = await prisma.reviewTagMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewTagMappingUpdateManyArgs>(args: SelectSubset<T, ReviewTagMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewTagMappings and returns the data updated in the database.
     * @param {ReviewTagMappingUpdateManyAndReturnArgs} args - Arguments to update many ReviewTagMappings.
     * @example
     * // Update many ReviewTagMappings
     * const reviewTagMapping = await prisma.reviewTagMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewTagMappings and only return the `id`
     * const reviewTagMappingWithIdOnly = await prisma.reviewTagMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewTagMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewTagMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewTagMapping.
     * @param {ReviewTagMappingUpsertArgs} args - Arguments to update or create a ReviewTagMapping.
     * @example
     * // Update or create a ReviewTagMapping
     * const reviewTagMapping = await prisma.reviewTagMapping.upsert({
     *   create: {
     *     // ... data to create a ReviewTagMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewTagMapping we want to update
     *   }
     * })
     */
    upsert<T extends ReviewTagMappingUpsertArgs>(args: SelectSubset<T, ReviewTagMappingUpsertArgs<ExtArgs>>): Prisma__ReviewTagMappingClient<$Result.GetResult<Prisma.$ReviewTagMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewTagMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingCountArgs} args - Arguments to filter ReviewTagMappings to count.
     * @example
     * // Count the number of ReviewTagMappings
     * const count = await prisma.reviewTagMapping.count({
     *   where: {
     *     // ... the filter for the ReviewTagMappings we want to count
     *   }
     * })
    **/
    count<T extends ReviewTagMappingCountArgs>(
      args?: Subset<T, ReviewTagMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewTagMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewTagMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewTagMappingAggregateArgs>(args: Subset<T, ReviewTagMappingAggregateArgs>): Prisma.PrismaPromise<GetReviewTagMappingAggregateType<T>>

    /**
     * Group by ReviewTagMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTagMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewTagMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewTagMappingGroupByArgs['orderBy'] }
        : { orderBy?: ReviewTagMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewTagMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewTagMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewTagMapping model
   */
  readonly fields: ReviewTagMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewTagMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewTagMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewTag<T extends ReviewTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewTagDefaultArgs<ExtArgs>>): Prisma__ReviewTagClient<$Result.GetResult<Prisma.$ReviewTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewTagMapping model
   */
  interface ReviewTagMappingFieldRefs {
    readonly id: FieldRef<"ReviewTagMapping", 'String'>
    readonly reviewId: FieldRef<"ReviewTagMapping", 'String'>
    readonly reviewTagId: FieldRef<"ReviewTagMapping", 'String'>
    readonly createdAt: FieldRef<"ReviewTagMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewTagMapping findUnique
   */
  export type ReviewTagMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTagMapping to fetch.
     */
    where: ReviewTagMappingWhereUniqueInput
  }

  /**
   * ReviewTagMapping findUniqueOrThrow
   */
  export type ReviewTagMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTagMapping to fetch.
     */
    where: ReviewTagMappingWhereUniqueInput
  }

  /**
   * ReviewTagMapping findFirst
   */
  export type ReviewTagMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTagMapping to fetch.
     */
    where?: ReviewTagMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTagMappings to fetch.
     */
    orderBy?: ReviewTagMappingOrderByWithRelationInput | ReviewTagMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewTagMappings.
     */
    cursor?: ReviewTagMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTagMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTagMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewTagMappings.
     */
    distinct?: ReviewTagMappingScalarFieldEnum | ReviewTagMappingScalarFieldEnum[]
  }

  /**
   * ReviewTagMapping findFirstOrThrow
   */
  export type ReviewTagMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTagMapping to fetch.
     */
    where?: ReviewTagMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTagMappings to fetch.
     */
    orderBy?: ReviewTagMappingOrderByWithRelationInput | ReviewTagMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewTagMappings.
     */
    cursor?: ReviewTagMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTagMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTagMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewTagMappings.
     */
    distinct?: ReviewTagMappingScalarFieldEnum | ReviewTagMappingScalarFieldEnum[]
  }

  /**
   * ReviewTagMapping findMany
   */
  export type ReviewTagMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTagMappings to fetch.
     */
    where?: ReviewTagMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTagMappings to fetch.
     */
    orderBy?: ReviewTagMappingOrderByWithRelationInput | ReviewTagMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewTagMappings.
     */
    cursor?: ReviewTagMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTagMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTagMappings.
     */
    skip?: number
    distinct?: ReviewTagMappingScalarFieldEnum | ReviewTagMappingScalarFieldEnum[]
  }

  /**
   * ReviewTagMapping create
   */
  export type ReviewTagMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewTagMapping.
     */
    data: XOR<ReviewTagMappingCreateInput, ReviewTagMappingUncheckedCreateInput>
  }

  /**
   * ReviewTagMapping createMany
   */
  export type ReviewTagMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewTagMappings.
     */
    data: ReviewTagMappingCreateManyInput | ReviewTagMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewTagMapping createManyAndReturn
   */
  export type ReviewTagMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewTagMappings.
     */
    data: ReviewTagMappingCreateManyInput | ReviewTagMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewTagMapping update
   */
  export type ReviewTagMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewTagMapping.
     */
    data: XOR<ReviewTagMappingUpdateInput, ReviewTagMappingUncheckedUpdateInput>
    /**
     * Choose, which ReviewTagMapping to update.
     */
    where: ReviewTagMappingWhereUniqueInput
  }

  /**
   * ReviewTagMapping updateMany
   */
  export type ReviewTagMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewTagMappings.
     */
    data: XOR<ReviewTagMappingUpdateManyMutationInput, ReviewTagMappingUncheckedUpdateManyInput>
    /**
     * Filter which ReviewTagMappings to update
     */
    where?: ReviewTagMappingWhereInput
    /**
     * Limit how many ReviewTagMappings to update.
     */
    limit?: number
  }

  /**
   * ReviewTagMapping updateManyAndReturn
   */
  export type ReviewTagMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * The data used to update ReviewTagMappings.
     */
    data: XOR<ReviewTagMappingUpdateManyMutationInput, ReviewTagMappingUncheckedUpdateManyInput>
    /**
     * Filter which ReviewTagMappings to update
     */
    where?: ReviewTagMappingWhereInput
    /**
     * Limit how many ReviewTagMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewTagMapping upsert
   */
  export type ReviewTagMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewTagMapping to update in case it exists.
     */
    where: ReviewTagMappingWhereUniqueInput
    /**
     * In case the ReviewTagMapping found by the `where` argument doesn't exist, create a new ReviewTagMapping with this data.
     */
    create: XOR<ReviewTagMappingCreateInput, ReviewTagMappingUncheckedCreateInput>
    /**
     * In case the ReviewTagMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewTagMappingUpdateInput, ReviewTagMappingUncheckedUpdateInput>
  }

  /**
   * ReviewTagMapping delete
   */
  export type ReviewTagMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
    /**
     * Filter which ReviewTagMapping to delete.
     */
    where: ReviewTagMappingWhereUniqueInput
  }

  /**
   * ReviewTagMapping deleteMany
   */
  export type ReviewTagMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewTagMappings to delete
     */
    where?: ReviewTagMappingWhereInput
    /**
     * Limit how many ReviewTagMappings to delete.
     */
    limit?: number
  }

  /**
   * ReviewTagMapping without action
   */
  export type ReviewTagMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTagMapping
     */
    select?: ReviewTagMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewTagMapping
     */
    omit?: ReviewTagMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTagMappingInclude<ExtArgs> | null
  }


  /**
   * Model BodyPart
   */

  export type AggregateBodyPart = {
    _count: BodyPartCountAggregateOutputType | null
    _avg: BodyPartAvgAggregateOutputType | null
    _sum: BodyPartSumAggregateOutputType | null
    _min: BodyPartMinAggregateOutputType | null
    _max: BodyPartMaxAggregateOutputType | null
  }

  export type BodyPartAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type BodyPartSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type BodyPartMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BodyPartMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BodyPartCountAggregateOutputType = {
    id: number
    name: number
    displayOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type BodyPartAvgAggregateInputType = {
    displayOrder?: true
  }

  export type BodyPartSumAggregateInputType = {
    displayOrder?: true
  }

  export type BodyPartMinAggregateInputType = {
    id?: true
    name?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type BodyPartMaxAggregateInputType = {
    id?: true
    name?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type BodyPartCountAggregateInputType = {
    id?: true
    name?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type BodyPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyPart to aggregate.
     */
    where?: BodyPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyParts to fetch.
     */
    orderBy?: BodyPartOrderByWithRelationInput | BodyPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodyPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BodyParts
    **/
    _count?: true | BodyPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BodyPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BodyPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodyPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodyPartMaxAggregateInputType
  }

  export type GetBodyPartAggregateType<T extends BodyPartAggregateArgs> = {
        [P in keyof T & keyof AggregateBodyPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodyPart[P]>
      : GetScalarType<T[P], AggregateBodyPart[P]>
  }




  export type BodyPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodyPartWhereInput
    orderBy?: BodyPartOrderByWithAggregationInput | BodyPartOrderByWithAggregationInput[]
    by: BodyPartScalarFieldEnum[] | BodyPartScalarFieldEnum
    having?: BodyPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodyPartCountAggregateInputType | true
    _avg?: BodyPartAvgAggregateInputType
    _sum?: BodyPartSumAggregateInputType
    _min?: BodyPartMinAggregateInputType
    _max?: BodyPartMaxAggregateInputType
  }

  export type BodyPartGroupByOutputType = {
    id: string
    name: string
    displayOrder: number
    isActive: boolean
    createdAt: Date
    _count: BodyPartCountAggregateOutputType | null
    _avg: BodyPartAvgAggregateOutputType | null
    _sum: BodyPartSumAggregateOutputType | null
    _min: BodyPartMinAggregateOutputType | null
    _max: BodyPartMaxAggregateOutputType | null
  }

  type GetBodyPartGroupByPayload<T extends BodyPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodyPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodyPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodyPartGroupByOutputType[P]>
            : GetScalarType<T[P], BodyPartGroupByOutputType[P]>
        }
      >
    >


  export type BodyPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    exerciseTemplates?: boolean | BodyPart$exerciseTemplatesArgs<ExtArgs>
    userPainProfiles?: boolean | BodyPart$userPainProfilesArgs<ExtArgs>
    _count?: boolean | BodyPartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodyPart"]>

  export type BodyPartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["bodyPart"]>

  export type BodyPartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["bodyPart"]>

  export type BodyPartSelectScalar = {
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type BodyPartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayOrder" | "isActive" | "createdAt", ExtArgs["result"]["bodyPart"]>
  export type BodyPartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTemplates?: boolean | BodyPart$exerciseTemplatesArgs<ExtArgs>
    userPainProfiles?: boolean | BodyPart$userPainProfilesArgs<ExtArgs>
    _count?: boolean | BodyPartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BodyPartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BodyPartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BodyPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BodyPart"
    objects: {
      exerciseTemplates: Prisma.$ExerciseTemplatePayload<ExtArgs>[]
      userPainProfiles: Prisma.$UserPainProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["bodyPart"]>
    composites: {}
  }

  type BodyPartGetPayload<S extends boolean | null | undefined | BodyPartDefaultArgs> = $Result.GetResult<Prisma.$BodyPartPayload, S>

  type BodyPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BodyPartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BodyPartCountAggregateInputType | true
    }

  export interface BodyPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BodyPart'], meta: { name: 'BodyPart' } }
    /**
     * Find zero or one BodyPart that matches the filter.
     * @param {BodyPartFindUniqueArgs} args - Arguments to find a BodyPart
     * @example
     * // Get one BodyPart
     * const bodyPart = await prisma.bodyPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BodyPartFindUniqueArgs>(args: SelectSubset<T, BodyPartFindUniqueArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BodyPart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BodyPartFindUniqueOrThrowArgs} args - Arguments to find a BodyPart
     * @example
     * // Get one BodyPart
     * const bodyPart = await prisma.bodyPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BodyPartFindUniqueOrThrowArgs>(args: SelectSubset<T, BodyPartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BodyPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartFindFirstArgs} args - Arguments to find a BodyPart
     * @example
     * // Get one BodyPart
     * const bodyPart = await prisma.bodyPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BodyPartFindFirstArgs>(args?: SelectSubset<T, BodyPartFindFirstArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BodyPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartFindFirstOrThrowArgs} args - Arguments to find a BodyPart
     * @example
     * // Get one BodyPart
     * const bodyPart = await prisma.bodyPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BodyPartFindFirstOrThrowArgs>(args?: SelectSubset<T, BodyPartFindFirstOrThrowArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BodyParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BodyParts
     * const bodyParts = await prisma.bodyPart.findMany()
     * 
     * // Get first 10 BodyParts
     * const bodyParts = await prisma.bodyPart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bodyPartWithIdOnly = await prisma.bodyPart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BodyPartFindManyArgs>(args?: SelectSubset<T, BodyPartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BodyPart.
     * @param {BodyPartCreateArgs} args - Arguments to create a BodyPart.
     * @example
     * // Create one BodyPart
     * const BodyPart = await prisma.bodyPart.create({
     *   data: {
     *     // ... data to create a BodyPart
     *   }
     * })
     * 
     */
    create<T extends BodyPartCreateArgs>(args: SelectSubset<T, BodyPartCreateArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BodyParts.
     * @param {BodyPartCreateManyArgs} args - Arguments to create many BodyParts.
     * @example
     * // Create many BodyParts
     * const bodyPart = await prisma.bodyPart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BodyPartCreateManyArgs>(args?: SelectSubset<T, BodyPartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BodyParts and returns the data saved in the database.
     * @param {BodyPartCreateManyAndReturnArgs} args - Arguments to create many BodyParts.
     * @example
     * // Create many BodyParts
     * const bodyPart = await prisma.bodyPart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BodyParts and only return the `id`
     * const bodyPartWithIdOnly = await prisma.bodyPart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BodyPartCreateManyAndReturnArgs>(args?: SelectSubset<T, BodyPartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BodyPart.
     * @param {BodyPartDeleteArgs} args - Arguments to delete one BodyPart.
     * @example
     * // Delete one BodyPart
     * const BodyPart = await prisma.bodyPart.delete({
     *   where: {
     *     // ... filter to delete one BodyPart
     *   }
     * })
     * 
     */
    delete<T extends BodyPartDeleteArgs>(args: SelectSubset<T, BodyPartDeleteArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BodyPart.
     * @param {BodyPartUpdateArgs} args - Arguments to update one BodyPart.
     * @example
     * // Update one BodyPart
     * const bodyPart = await prisma.bodyPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BodyPartUpdateArgs>(args: SelectSubset<T, BodyPartUpdateArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BodyParts.
     * @param {BodyPartDeleteManyArgs} args - Arguments to filter BodyParts to delete.
     * @example
     * // Delete a few BodyParts
     * const { count } = await prisma.bodyPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BodyPartDeleteManyArgs>(args?: SelectSubset<T, BodyPartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodyParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BodyParts
     * const bodyPart = await prisma.bodyPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BodyPartUpdateManyArgs>(args: SelectSubset<T, BodyPartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodyParts and returns the data updated in the database.
     * @param {BodyPartUpdateManyAndReturnArgs} args - Arguments to update many BodyParts.
     * @example
     * // Update many BodyParts
     * const bodyPart = await prisma.bodyPart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BodyParts and only return the `id`
     * const bodyPartWithIdOnly = await prisma.bodyPart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BodyPartUpdateManyAndReturnArgs>(args: SelectSubset<T, BodyPartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BodyPart.
     * @param {BodyPartUpsertArgs} args - Arguments to update or create a BodyPart.
     * @example
     * // Update or create a BodyPart
     * const bodyPart = await prisma.bodyPart.upsert({
     *   create: {
     *     // ... data to create a BodyPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BodyPart we want to update
     *   }
     * })
     */
    upsert<T extends BodyPartUpsertArgs>(args: SelectSubset<T, BodyPartUpsertArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BodyParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartCountArgs} args - Arguments to filter BodyParts to count.
     * @example
     * // Count the number of BodyParts
     * const count = await prisma.bodyPart.count({
     *   where: {
     *     // ... the filter for the BodyParts we want to count
     *   }
     * })
    **/
    count<T extends BodyPartCountArgs>(
      args?: Subset<T, BodyPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodyPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BodyPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodyPartAggregateArgs>(args: Subset<T, BodyPartAggregateArgs>): Prisma.PrismaPromise<GetBodyPartAggregateType<T>>

    /**
     * Group by BodyPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodyPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodyPartGroupByArgs['orderBy'] }
        : { orderBy?: BodyPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodyPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodyPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BodyPart model
   */
  readonly fields: BodyPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BodyPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodyPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exerciseTemplates<T extends BodyPart$exerciseTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, BodyPart$exerciseTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPainProfiles<T extends BodyPart$userPainProfilesArgs<ExtArgs> = {}>(args?: Subset<T, BodyPart$userPainProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BodyPart model
   */
  interface BodyPartFieldRefs {
    readonly id: FieldRef<"BodyPart", 'String'>
    readonly name: FieldRef<"BodyPart", 'String'>
    readonly displayOrder: FieldRef<"BodyPart", 'Int'>
    readonly isActive: FieldRef<"BodyPart", 'Boolean'>
    readonly createdAt: FieldRef<"BodyPart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BodyPart findUnique
   */
  export type BodyPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * Filter, which BodyPart to fetch.
     */
    where: BodyPartWhereUniqueInput
  }

  /**
   * BodyPart findUniqueOrThrow
   */
  export type BodyPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * Filter, which BodyPart to fetch.
     */
    where: BodyPartWhereUniqueInput
  }

  /**
   * BodyPart findFirst
   */
  export type BodyPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * Filter, which BodyPart to fetch.
     */
    where?: BodyPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyParts to fetch.
     */
    orderBy?: BodyPartOrderByWithRelationInput | BodyPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyParts.
     */
    cursor?: BodyPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyParts.
     */
    distinct?: BodyPartScalarFieldEnum | BodyPartScalarFieldEnum[]
  }

  /**
   * BodyPart findFirstOrThrow
   */
  export type BodyPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * Filter, which BodyPart to fetch.
     */
    where?: BodyPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyParts to fetch.
     */
    orderBy?: BodyPartOrderByWithRelationInput | BodyPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyParts.
     */
    cursor?: BodyPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyParts.
     */
    distinct?: BodyPartScalarFieldEnum | BodyPartScalarFieldEnum[]
  }

  /**
   * BodyPart findMany
   */
  export type BodyPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * Filter, which BodyParts to fetch.
     */
    where?: BodyPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyParts to fetch.
     */
    orderBy?: BodyPartOrderByWithRelationInput | BodyPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BodyParts.
     */
    cursor?: BodyPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyParts.
     */
    skip?: number
    distinct?: BodyPartScalarFieldEnum | BodyPartScalarFieldEnum[]
  }

  /**
   * BodyPart create
   */
  export type BodyPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * The data needed to create a BodyPart.
     */
    data: XOR<BodyPartCreateInput, BodyPartUncheckedCreateInput>
  }

  /**
   * BodyPart createMany
   */
  export type BodyPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BodyParts.
     */
    data: BodyPartCreateManyInput | BodyPartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BodyPart createManyAndReturn
   */
  export type BodyPartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * The data used to create many BodyParts.
     */
    data: BodyPartCreateManyInput | BodyPartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BodyPart update
   */
  export type BodyPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * The data needed to update a BodyPart.
     */
    data: XOR<BodyPartUpdateInput, BodyPartUncheckedUpdateInput>
    /**
     * Choose, which BodyPart to update.
     */
    where: BodyPartWhereUniqueInput
  }

  /**
   * BodyPart updateMany
   */
  export type BodyPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BodyParts.
     */
    data: XOR<BodyPartUpdateManyMutationInput, BodyPartUncheckedUpdateManyInput>
    /**
     * Filter which BodyParts to update
     */
    where?: BodyPartWhereInput
    /**
     * Limit how many BodyParts to update.
     */
    limit?: number
  }

  /**
   * BodyPart updateManyAndReturn
   */
  export type BodyPartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * The data used to update BodyParts.
     */
    data: XOR<BodyPartUpdateManyMutationInput, BodyPartUncheckedUpdateManyInput>
    /**
     * Filter which BodyParts to update
     */
    where?: BodyPartWhereInput
    /**
     * Limit how many BodyParts to update.
     */
    limit?: number
  }

  /**
   * BodyPart upsert
   */
  export type BodyPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * The filter to search for the BodyPart to update in case it exists.
     */
    where: BodyPartWhereUniqueInput
    /**
     * In case the BodyPart found by the `where` argument doesn't exist, create a new BodyPart with this data.
     */
    create: XOR<BodyPartCreateInput, BodyPartUncheckedCreateInput>
    /**
     * In case the BodyPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodyPartUpdateInput, BodyPartUncheckedUpdateInput>
  }

  /**
   * BodyPart delete
   */
  export type BodyPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
    /**
     * Filter which BodyPart to delete.
     */
    where: BodyPartWhereUniqueInput
  }

  /**
   * BodyPart deleteMany
   */
  export type BodyPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyParts to delete
     */
    where?: BodyPartWhereInput
    /**
     * Limit how many BodyParts to delete.
     */
    limit?: number
  }

  /**
   * BodyPart.exerciseTemplates
   */
  export type BodyPart$exerciseTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    where?: ExerciseTemplateWhereInput
    orderBy?: ExerciseTemplateOrderByWithRelationInput | ExerciseTemplateOrderByWithRelationInput[]
    cursor?: ExerciseTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseTemplateScalarFieldEnum | ExerciseTemplateScalarFieldEnum[]
  }

  /**
   * BodyPart.userPainProfiles
   */
  export type BodyPart$userPainProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    where?: UserPainProfileWhereInput
    orderBy?: UserPainProfileOrderByWithRelationInput | UserPainProfileOrderByWithRelationInput[]
    cursor?: UserPainProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPainProfileScalarFieldEnum | UserPainProfileScalarFieldEnum[]
  }

  /**
   * BodyPart without action
   */
  export type BodyPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyPart
     */
    select?: BodyPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyPart
     */
    omit?: BodyPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyPartInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentType
   */

  export type AggregateEquipmentType = {
    _count: EquipmentTypeCountAggregateOutputType | null
    _avg: EquipmentTypeAvgAggregateOutputType | null
    _sum: EquipmentTypeSumAggregateOutputType | null
    _min: EquipmentTypeMinAggregateOutputType | null
    _max: EquipmentTypeMaxAggregateOutputType | null
  }

  export type EquipmentTypeAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type EquipmentTypeSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type EquipmentTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type EquipmentTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type EquipmentTypeCountAggregateOutputType = {
    id: number
    name: number
    displayOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type EquipmentTypeAvgAggregateInputType = {
    displayOrder?: true
  }

  export type EquipmentTypeSumAggregateInputType = {
    displayOrder?: true
  }

  export type EquipmentTypeMinAggregateInputType = {
    id?: true
    name?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type EquipmentTypeMaxAggregateInputType = {
    id?: true
    name?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type EquipmentTypeCountAggregateInputType = {
    id?: true
    name?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type EquipmentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentType to aggregate.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentTypes
    **/
    _count?: true | EquipmentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentTypeMaxAggregateInputType
  }

  export type GetEquipmentTypeAggregateType<T extends EquipmentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentType[P]>
      : GetScalarType<T[P], AggregateEquipmentType[P]>
  }




  export type EquipmentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentTypeWhereInput
    orderBy?: EquipmentTypeOrderByWithAggregationInput | EquipmentTypeOrderByWithAggregationInput[]
    by: EquipmentTypeScalarFieldEnum[] | EquipmentTypeScalarFieldEnum
    having?: EquipmentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentTypeCountAggregateInputType | true
    _avg?: EquipmentTypeAvgAggregateInputType
    _sum?: EquipmentTypeSumAggregateInputType
    _min?: EquipmentTypeMinAggregateInputType
    _max?: EquipmentTypeMaxAggregateInputType
  }

  export type EquipmentTypeGroupByOutputType = {
    id: string
    name: string
    displayOrder: number
    isActive: boolean
    createdAt: Date
    _count: EquipmentTypeCountAggregateOutputType | null
    _avg: EquipmentTypeAvgAggregateOutputType | null
    _sum: EquipmentTypeSumAggregateOutputType | null
    _min: EquipmentTypeMinAggregateOutputType | null
    _max: EquipmentTypeMaxAggregateOutputType | null
  }

  type GetEquipmentTypeGroupByPayload<T extends EquipmentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentTypeGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    exerciseEquipmentMappings?: boolean | EquipmentType$exerciseEquipmentMappingsArgs<ExtArgs>
    _count?: boolean | EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentType"]>

  export type EquipmentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["equipmentType"]>

  export type EquipmentTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["equipmentType"]>

  export type EquipmentTypeSelectScalar = {
    id?: boolean
    name?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type EquipmentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayOrder" | "isActive" | "createdAt", ExtArgs["result"]["equipmentType"]>
  export type EquipmentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseEquipmentMappings?: boolean | EquipmentType$exerciseEquipmentMappingsArgs<ExtArgs>
    _count?: boolean | EquipmentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EquipmentTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipmentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentType"
    objects: {
      exerciseEquipmentMappings: Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["equipmentType"]>
    composites: {}
  }

  type EquipmentTypeGetPayload<S extends boolean | null | undefined | EquipmentTypeDefaultArgs> = $Result.GetResult<Prisma.$EquipmentTypePayload, S>

  type EquipmentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentTypeCountAggregateInputType | true
    }

  export interface EquipmentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentType'], meta: { name: 'EquipmentType' } }
    /**
     * Find zero or one EquipmentType that matches the filter.
     * @param {EquipmentTypeFindUniqueArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentTypeFindUniqueArgs>(args: SelectSubset<T, EquipmentTypeFindUniqueArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentTypeFindUniqueOrThrowArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeFindFirstArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentTypeFindFirstArgs>(args?: SelectSubset<T, EquipmentTypeFindFirstArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeFindFirstOrThrowArgs} args - Arguments to find a EquipmentType
     * @example
     * // Get one EquipmentType
     * const equipmentType = await prisma.equipmentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentTypes
     * const equipmentTypes = await prisma.equipmentType.findMany()
     * 
     * // Get first 10 EquipmentTypes
     * const equipmentTypes = await prisma.equipmentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentTypeWithIdOnly = await prisma.equipmentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentTypeFindManyArgs>(args?: SelectSubset<T, EquipmentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentType.
     * @param {EquipmentTypeCreateArgs} args - Arguments to create a EquipmentType.
     * @example
     * // Create one EquipmentType
     * const EquipmentType = await prisma.equipmentType.create({
     *   data: {
     *     // ... data to create a EquipmentType
     *   }
     * })
     * 
     */
    create<T extends EquipmentTypeCreateArgs>(args: SelectSubset<T, EquipmentTypeCreateArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentTypes.
     * @param {EquipmentTypeCreateManyArgs} args - Arguments to create many EquipmentTypes.
     * @example
     * // Create many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentTypeCreateManyArgs>(args?: SelectSubset<T, EquipmentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentTypes and returns the data saved in the database.
     * @param {EquipmentTypeCreateManyAndReturnArgs} args - Arguments to create many EquipmentTypes.
     * @example
     * // Create many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentTypes and only return the `id`
     * const equipmentTypeWithIdOnly = await prisma.equipmentType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentType.
     * @param {EquipmentTypeDeleteArgs} args - Arguments to delete one EquipmentType.
     * @example
     * // Delete one EquipmentType
     * const EquipmentType = await prisma.equipmentType.delete({
     *   where: {
     *     // ... filter to delete one EquipmentType
     *   }
     * })
     * 
     */
    delete<T extends EquipmentTypeDeleteArgs>(args: SelectSubset<T, EquipmentTypeDeleteArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentType.
     * @param {EquipmentTypeUpdateArgs} args - Arguments to update one EquipmentType.
     * @example
     * // Update one EquipmentType
     * const equipmentType = await prisma.equipmentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentTypeUpdateArgs>(args: SelectSubset<T, EquipmentTypeUpdateArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentTypes.
     * @param {EquipmentTypeDeleteManyArgs} args - Arguments to filter EquipmentTypes to delete.
     * @example
     * // Delete a few EquipmentTypes
     * const { count } = await prisma.equipmentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentTypeDeleteManyArgs>(args?: SelectSubset<T, EquipmentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentTypeUpdateManyArgs>(args: SelectSubset<T, EquipmentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentTypes and returns the data updated in the database.
     * @param {EquipmentTypeUpdateManyAndReturnArgs} args - Arguments to update many EquipmentTypes.
     * @example
     * // Update many EquipmentTypes
     * const equipmentType = await prisma.equipmentType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentTypes and only return the `id`
     * const equipmentTypeWithIdOnly = await prisma.equipmentType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentType.
     * @param {EquipmentTypeUpsertArgs} args - Arguments to update or create a EquipmentType.
     * @example
     * // Update or create a EquipmentType
     * const equipmentType = await prisma.equipmentType.upsert({
     *   create: {
     *     // ... data to create a EquipmentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentType we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentTypeUpsertArgs>(args: SelectSubset<T, EquipmentTypeUpsertArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeCountArgs} args - Arguments to filter EquipmentTypes to count.
     * @example
     * // Count the number of EquipmentTypes
     * const count = await prisma.equipmentType.count({
     *   where: {
     *     // ... the filter for the EquipmentTypes we want to count
     *   }
     * })
    **/
    count<T extends EquipmentTypeCountArgs>(
      args?: Subset<T, EquipmentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentTypeAggregateArgs>(args: Subset<T, EquipmentTypeAggregateArgs>): Prisma.PrismaPromise<GetEquipmentTypeAggregateType<T>>

    /**
     * Group by EquipmentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentTypeGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentType model
   */
  readonly fields: EquipmentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exerciseEquipmentMappings<T extends EquipmentType$exerciseEquipmentMappingsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentType$exerciseEquipmentMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentType model
   */
  interface EquipmentTypeFieldRefs {
    readonly id: FieldRef<"EquipmentType", 'String'>
    readonly name: FieldRef<"EquipmentType", 'String'>
    readonly displayOrder: FieldRef<"EquipmentType", 'Int'>
    readonly isActive: FieldRef<"EquipmentType", 'Boolean'>
    readonly createdAt: FieldRef<"EquipmentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentType findUnique
   */
  export type EquipmentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType findUniqueOrThrow
   */
  export type EquipmentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType findFirst
   */
  export type EquipmentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentTypes.
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentTypes.
     */
    distinct?: EquipmentTypeScalarFieldEnum | EquipmentTypeScalarFieldEnum[]
  }

  /**
   * EquipmentType findFirstOrThrow
   */
  export type EquipmentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentType to fetch.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentTypes.
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentTypes.
     */
    distinct?: EquipmentTypeScalarFieldEnum | EquipmentTypeScalarFieldEnum[]
  }

  /**
   * EquipmentType findMany
   */
  export type EquipmentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentTypes to fetch.
     */
    where?: EquipmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentTypes to fetch.
     */
    orderBy?: EquipmentTypeOrderByWithRelationInput | EquipmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentTypes.
     */
    cursor?: EquipmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentTypes.
     */
    skip?: number
    distinct?: EquipmentTypeScalarFieldEnum | EquipmentTypeScalarFieldEnum[]
  }

  /**
   * EquipmentType create
   */
  export type EquipmentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentType.
     */
    data: XOR<EquipmentTypeCreateInput, EquipmentTypeUncheckedCreateInput>
  }

  /**
   * EquipmentType createMany
   */
  export type EquipmentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentTypes.
     */
    data: EquipmentTypeCreateManyInput | EquipmentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentType createManyAndReturn
   */
  export type EquipmentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentTypes.
     */
    data: EquipmentTypeCreateManyInput | EquipmentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentType update
   */
  export type EquipmentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentType.
     */
    data: XOR<EquipmentTypeUpdateInput, EquipmentTypeUncheckedUpdateInput>
    /**
     * Choose, which EquipmentType to update.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType updateMany
   */
  export type EquipmentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentTypes.
     */
    data: XOR<EquipmentTypeUpdateManyMutationInput, EquipmentTypeUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentTypes to update
     */
    where?: EquipmentTypeWhereInput
    /**
     * Limit how many EquipmentTypes to update.
     */
    limit?: number
  }

  /**
   * EquipmentType updateManyAndReturn
   */
  export type EquipmentTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentTypes.
     */
    data: XOR<EquipmentTypeUpdateManyMutationInput, EquipmentTypeUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentTypes to update
     */
    where?: EquipmentTypeWhereInput
    /**
     * Limit how many EquipmentTypes to update.
     */
    limit?: number
  }

  /**
   * EquipmentType upsert
   */
  export type EquipmentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentType to update in case it exists.
     */
    where: EquipmentTypeWhereUniqueInput
    /**
     * In case the EquipmentType found by the `where` argument doesn't exist, create a new EquipmentType with this data.
     */
    create: XOR<EquipmentTypeCreateInput, EquipmentTypeUncheckedCreateInput>
    /**
     * In case the EquipmentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentTypeUpdateInput, EquipmentTypeUncheckedUpdateInput>
  }

  /**
   * EquipmentType delete
   */
  export type EquipmentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
    /**
     * Filter which EquipmentType to delete.
     */
    where: EquipmentTypeWhereUniqueInput
  }

  /**
   * EquipmentType deleteMany
   */
  export type EquipmentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentTypes to delete
     */
    where?: EquipmentTypeWhereInput
    /**
     * Limit how many EquipmentTypes to delete.
     */
    limit?: number
  }

  /**
   * EquipmentType.exerciseEquipmentMappings
   */
  export type EquipmentType$exerciseEquipmentMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    where?: ExerciseEquipmentMappingWhereInput
    orderBy?: ExerciseEquipmentMappingOrderByWithRelationInput | ExerciseEquipmentMappingOrderByWithRelationInput[]
    cursor?: ExerciseEquipmentMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseEquipmentMappingScalarFieldEnum | ExerciseEquipmentMappingScalarFieldEnum[]
  }

  /**
   * EquipmentType without action
   */
  export type EquipmentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentType
     */
    select?: EquipmentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentType
     */
    omit?: EquipmentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentTypeInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseTemplate
   */

  export type AggregateExerciseTemplate = {
    _count: ExerciseTemplateCountAggregateOutputType | null
    _avg: ExerciseTemplateAvgAggregateOutputType | null
    _sum: ExerciseTemplateSumAggregateOutputType | null
    _min: ExerciseTemplateMinAggregateOutputType | null
    _max: ExerciseTemplateMaxAggregateOutputType | null
  }

  export type ExerciseTemplateAvgAggregateOutputType = {
    intensityLevel: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    difficultyScore: number | null
  }

  export type ExerciseTemplateSumAggregateOutputType = {
    intensityLevel: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    difficultyScore: number | null
  }

  export type ExerciseTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    bodyPartId: string | null
    intensityLevel: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    difficultyScore: number | null
    instructions: string | null
    precautions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    bodyPartId: string | null
    intensityLevel: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    difficultyScore: number | null
    instructions: string | null
    precautions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    bodyPartId: number
    intensityLevel: number
    durationMinutes: number
    reps: number
    sets: number
    restSeconds: number
    difficultyScore: number
    contraindications: number
    instructions: number
    precautions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseTemplateAvgAggregateInputType = {
    intensityLevel?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    difficultyScore?: true
  }

  export type ExerciseTemplateSumAggregateInputType = {
    intensityLevel?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    difficultyScore?: true
  }

  export type ExerciseTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    bodyPartId?: true
    intensityLevel?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    difficultyScore?: true
    instructions?: true
    precautions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    bodyPartId?: true
    intensityLevel?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    difficultyScore?: true
    instructions?: true
    precautions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    bodyPartId?: true
    intensityLevel?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    difficultyScore?: true
    contraindications?: true
    instructions?: true
    precautions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseTemplate to aggregate.
     */
    where?: ExerciseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTemplates to fetch.
     */
    orderBy?: ExerciseTemplateOrderByWithRelationInput | ExerciseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseTemplates
    **/
    _count?: true | ExerciseTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseTemplateMaxAggregateInputType
  }

  export type GetExerciseTemplateAggregateType<T extends ExerciseTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseTemplate[P]>
      : GetScalarType<T[P], AggregateExerciseTemplate[P]>
  }




  export type ExerciseTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseTemplateWhereInput
    orderBy?: ExerciseTemplateOrderByWithAggregationInput | ExerciseTemplateOrderByWithAggregationInput[]
    by: ExerciseTemplateScalarFieldEnum[] | ExerciseTemplateScalarFieldEnum
    having?: ExerciseTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseTemplateCountAggregateInputType | true
    _avg?: ExerciseTemplateAvgAggregateInputType
    _sum?: ExerciseTemplateSumAggregateInputType
    _min?: ExerciseTemplateMinAggregateInputType
    _max?: ExerciseTemplateMaxAggregateInputType
  }

  export type ExerciseTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    bodyPartId: string
    intensityLevel: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    difficultyScore: number | null
    contraindications: string[]
    instructions: string | null
    precautions: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExerciseTemplateCountAggregateOutputType | null
    _avg: ExerciseTemplateAvgAggregateOutputType | null
    _sum: ExerciseTemplateSumAggregateOutputType | null
    _min: ExerciseTemplateMinAggregateOutputType | null
    _max: ExerciseTemplateMaxAggregateOutputType | null
  }

  type GetExerciseTemplateGroupByPayload<T extends ExerciseTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    bodyPartId?: boolean
    intensityLevel?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    difficultyScore?: boolean
    contraindications?: boolean
    instructions?: boolean
    precautions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
    exerciseEquipmentMappings?: boolean | ExerciseTemplate$exerciseEquipmentMappingsArgs<ExtArgs>
    courseExercises?: boolean | ExerciseTemplate$courseExercisesArgs<ExtArgs>
    _count?: boolean | ExerciseTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseTemplate"]>

  export type ExerciseTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    bodyPartId?: boolean
    intensityLevel?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    difficultyScore?: boolean
    contraindications?: boolean
    instructions?: boolean
    precautions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseTemplate"]>

  export type ExerciseTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    bodyPartId?: boolean
    intensityLevel?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    difficultyScore?: boolean
    contraindications?: boolean
    instructions?: boolean
    precautions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseTemplate"]>

  export type ExerciseTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    bodyPartId?: boolean
    intensityLevel?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    difficultyScore?: boolean
    contraindications?: boolean
    instructions?: boolean
    precautions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "bodyPartId" | "intensityLevel" | "durationMinutes" | "reps" | "sets" | "restSeconds" | "difficultyScore" | "contraindications" | "instructions" | "precautions" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["exerciseTemplate"]>
  export type ExerciseTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
    exerciseEquipmentMappings?: boolean | ExerciseTemplate$exerciseEquipmentMappingsArgs<ExtArgs>
    courseExercises?: boolean | ExerciseTemplate$courseExercisesArgs<ExtArgs>
    _count?: boolean | ExerciseTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }
  export type ExerciseTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }

  export type $ExerciseTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseTemplate"
    objects: {
      bodyPart: Prisma.$BodyPartPayload<ExtArgs>
      exerciseEquipmentMappings: Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>[]
      courseExercises: Prisma.$CourseExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      bodyPartId: string
      intensityLevel: number | null
      durationMinutes: number | null
      reps: number | null
      sets: number | null
      restSeconds: number | null
      difficultyScore: number | null
      contraindications: string[]
      instructions: string | null
      precautions: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exerciseTemplate"]>
    composites: {}
  }

  type ExerciseTemplateGetPayload<S extends boolean | null | undefined | ExerciseTemplateDefaultArgs> = $Result.GetResult<Prisma.$ExerciseTemplatePayload, S>

  type ExerciseTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseTemplateCountAggregateInputType | true
    }

  export interface ExerciseTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseTemplate'], meta: { name: 'ExerciseTemplate' } }
    /**
     * Find zero or one ExerciseTemplate that matches the filter.
     * @param {ExerciseTemplateFindUniqueArgs} args - Arguments to find a ExerciseTemplate
     * @example
     * // Get one ExerciseTemplate
     * const exerciseTemplate = await prisma.exerciseTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseTemplateFindUniqueArgs>(args: SelectSubset<T, ExerciseTemplateFindUniqueArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseTemplateFindUniqueOrThrowArgs} args - Arguments to find a ExerciseTemplate
     * @example
     * // Get one ExerciseTemplate
     * const exerciseTemplate = await prisma.exerciseTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateFindFirstArgs} args - Arguments to find a ExerciseTemplate
     * @example
     * // Get one ExerciseTemplate
     * const exerciseTemplate = await prisma.exerciseTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseTemplateFindFirstArgs>(args?: SelectSubset<T, ExerciseTemplateFindFirstArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateFindFirstOrThrowArgs} args - Arguments to find a ExerciseTemplate
     * @example
     * // Get one ExerciseTemplate
     * const exerciseTemplate = await prisma.exerciseTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExerciseTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseTemplates
     * const exerciseTemplates = await prisma.exerciseTemplate.findMany()
     * 
     * // Get first 10 ExerciseTemplates
     * const exerciseTemplates = await prisma.exerciseTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseTemplateWithIdOnly = await prisma.exerciseTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseTemplateFindManyArgs>(args?: SelectSubset<T, ExerciseTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseTemplate.
     * @param {ExerciseTemplateCreateArgs} args - Arguments to create a ExerciseTemplate.
     * @example
     * // Create one ExerciseTemplate
     * const ExerciseTemplate = await prisma.exerciseTemplate.create({
     *   data: {
     *     // ... data to create a ExerciseTemplate
     *   }
     * })
     * 
     */
    create<T extends ExerciseTemplateCreateArgs>(args: SelectSubset<T, ExerciseTemplateCreateArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExerciseTemplates.
     * @param {ExerciseTemplateCreateManyArgs} args - Arguments to create many ExerciseTemplates.
     * @example
     * // Create many ExerciseTemplates
     * const exerciseTemplate = await prisma.exerciseTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseTemplateCreateManyArgs>(args?: SelectSubset<T, ExerciseTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseTemplates and returns the data saved in the database.
     * @param {ExerciseTemplateCreateManyAndReturnArgs} args - Arguments to create many ExerciseTemplates.
     * @example
     * // Create many ExerciseTemplates
     * const exerciseTemplate = await prisma.exerciseTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseTemplates and only return the `id`
     * const exerciseTemplateWithIdOnly = await prisma.exerciseTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseTemplate.
     * @param {ExerciseTemplateDeleteArgs} args - Arguments to delete one ExerciseTemplate.
     * @example
     * // Delete one ExerciseTemplate
     * const ExerciseTemplate = await prisma.exerciseTemplate.delete({
     *   where: {
     *     // ... filter to delete one ExerciseTemplate
     *   }
     * })
     * 
     */
    delete<T extends ExerciseTemplateDeleteArgs>(args: SelectSubset<T, ExerciseTemplateDeleteArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseTemplate.
     * @param {ExerciseTemplateUpdateArgs} args - Arguments to update one ExerciseTemplate.
     * @example
     * // Update one ExerciseTemplate
     * const exerciseTemplate = await prisma.exerciseTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseTemplateUpdateArgs>(args: SelectSubset<T, ExerciseTemplateUpdateArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExerciseTemplates.
     * @param {ExerciseTemplateDeleteManyArgs} args - Arguments to filter ExerciseTemplates to delete.
     * @example
     * // Delete a few ExerciseTemplates
     * const { count } = await prisma.exerciseTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseTemplateDeleteManyArgs>(args?: SelectSubset<T, ExerciseTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseTemplates
     * const exerciseTemplate = await prisma.exerciseTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseTemplateUpdateManyArgs>(args: SelectSubset<T, ExerciseTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseTemplates and returns the data updated in the database.
     * @param {ExerciseTemplateUpdateManyAndReturnArgs} args - Arguments to update many ExerciseTemplates.
     * @example
     * // Update many ExerciseTemplates
     * const exerciseTemplate = await prisma.exerciseTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciseTemplates and only return the `id`
     * const exerciseTemplateWithIdOnly = await prisma.exerciseTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseTemplate.
     * @param {ExerciseTemplateUpsertArgs} args - Arguments to update or create a ExerciseTemplate.
     * @example
     * // Update or create a ExerciseTemplate
     * const exerciseTemplate = await prisma.exerciseTemplate.upsert({
     *   create: {
     *     // ... data to create a ExerciseTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseTemplateUpsertArgs>(args: SelectSubset<T, ExerciseTemplateUpsertArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExerciseTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateCountArgs} args - Arguments to filter ExerciseTemplates to count.
     * @example
     * // Count the number of ExerciseTemplates
     * const count = await prisma.exerciseTemplate.count({
     *   where: {
     *     // ... the filter for the ExerciseTemplates we want to count
     *   }
     * })
    **/
    count<T extends ExerciseTemplateCountArgs>(
      args?: Subset<T, ExerciseTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseTemplateAggregateArgs>(args: Subset<T, ExerciseTemplateAggregateArgs>): Prisma.PrismaPromise<GetExerciseTemplateAggregateType<T>>

    /**
     * Group by ExerciseTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseTemplate model
   */
  readonly fields: ExerciseTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bodyPart<T extends BodyPartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodyPartDefaultArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exerciseEquipmentMappings<T extends ExerciseTemplate$exerciseEquipmentMappingsArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseTemplate$exerciseEquipmentMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseExercises<T extends ExerciseTemplate$courseExercisesArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseTemplate$courseExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseTemplate model
   */
  interface ExerciseTemplateFieldRefs {
    readonly id: FieldRef<"ExerciseTemplate", 'String'>
    readonly name: FieldRef<"ExerciseTemplate", 'String'>
    readonly description: FieldRef<"ExerciseTemplate", 'String'>
    readonly bodyPartId: FieldRef<"ExerciseTemplate", 'String'>
    readonly intensityLevel: FieldRef<"ExerciseTemplate", 'Int'>
    readonly durationMinutes: FieldRef<"ExerciseTemplate", 'Int'>
    readonly reps: FieldRef<"ExerciseTemplate", 'Int'>
    readonly sets: FieldRef<"ExerciseTemplate", 'Int'>
    readonly restSeconds: FieldRef<"ExerciseTemplate", 'Int'>
    readonly difficultyScore: FieldRef<"ExerciseTemplate", 'Int'>
    readonly contraindications: FieldRef<"ExerciseTemplate", 'String[]'>
    readonly instructions: FieldRef<"ExerciseTemplate", 'String'>
    readonly precautions: FieldRef<"ExerciseTemplate", 'String'>
    readonly isActive: FieldRef<"ExerciseTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"ExerciseTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ExerciseTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseTemplate findUnique
   */
  export type ExerciseTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTemplate to fetch.
     */
    where: ExerciseTemplateWhereUniqueInput
  }

  /**
   * ExerciseTemplate findUniqueOrThrow
   */
  export type ExerciseTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTemplate to fetch.
     */
    where: ExerciseTemplateWhereUniqueInput
  }

  /**
   * ExerciseTemplate findFirst
   */
  export type ExerciseTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTemplate to fetch.
     */
    where?: ExerciseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTemplates to fetch.
     */
    orderBy?: ExerciseTemplateOrderByWithRelationInput | ExerciseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseTemplates.
     */
    cursor?: ExerciseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseTemplates.
     */
    distinct?: ExerciseTemplateScalarFieldEnum | ExerciseTemplateScalarFieldEnum[]
  }

  /**
   * ExerciseTemplate findFirstOrThrow
   */
  export type ExerciseTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTemplate to fetch.
     */
    where?: ExerciseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTemplates to fetch.
     */
    orderBy?: ExerciseTemplateOrderByWithRelationInput | ExerciseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseTemplates.
     */
    cursor?: ExerciseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseTemplates.
     */
    distinct?: ExerciseTemplateScalarFieldEnum | ExerciseTemplateScalarFieldEnum[]
  }

  /**
   * ExerciseTemplate findMany
   */
  export type ExerciseTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTemplates to fetch.
     */
    where?: ExerciseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTemplates to fetch.
     */
    orderBy?: ExerciseTemplateOrderByWithRelationInput | ExerciseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseTemplates.
     */
    cursor?: ExerciseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTemplates.
     */
    skip?: number
    distinct?: ExerciseTemplateScalarFieldEnum | ExerciseTemplateScalarFieldEnum[]
  }

  /**
   * ExerciseTemplate create
   */
  export type ExerciseTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseTemplate.
     */
    data: XOR<ExerciseTemplateCreateInput, ExerciseTemplateUncheckedCreateInput>
  }

  /**
   * ExerciseTemplate createMany
   */
  export type ExerciseTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseTemplates.
     */
    data: ExerciseTemplateCreateManyInput | ExerciseTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseTemplate createManyAndReturn
   */
  export type ExerciseTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciseTemplates.
     */
    data: ExerciseTemplateCreateManyInput | ExerciseTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseTemplate update
   */
  export type ExerciseTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseTemplate.
     */
    data: XOR<ExerciseTemplateUpdateInput, ExerciseTemplateUncheckedUpdateInput>
    /**
     * Choose, which ExerciseTemplate to update.
     */
    where: ExerciseTemplateWhereUniqueInput
  }

  /**
   * ExerciseTemplate updateMany
   */
  export type ExerciseTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseTemplates.
     */
    data: XOR<ExerciseTemplateUpdateManyMutationInput, ExerciseTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseTemplates to update
     */
    where?: ExerciseTemplateWhereInput
    /**
     * Limit how many ExerciseTemplates to update.
     */
    limit?: number
  }

  /**
   * ExerciseTemplate updateManyAndReturn
   */
  export type ExerciseTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ExerciseTemplates.
     */
    data: XOR<ExerciseTemplateUpdateManyMutationInput, ExerciseTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseTemplates to update
     */
    where?: ExerciseTemplateWhereInput
    /**
     * Limit how many ExerciseTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseTemplate upsert
   */
  export type ExerciseTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseTemplate to update in case it exists.
     */
    where: ExerciseTemplateWhereUniqueInput
    /**
     * In case the ExerciseTemplate found by the `where` argument doesn't exist, create a new ExerciseTemplate with this data.
     */
    create: XOR<ExerciseTemplateCreateInput, ExerciseTemplateUncheckedCreateInput>
    /**
     * In case the ExerciseTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseTemplateUpdateInput, ExerciseTemplateUncheckedUpdateInput>
  }

  /**
   * ExerciseTemplate delete
   */
  export type ExerciseTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
    /**
     * Filter which ExerciseTemplate to delete.
     */
    where: ExerciseTemplateWhereUniqueInput
  }

  /**
   * ExerciseTemplate deleteMany
   */
  export type ExerciseTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseTemplates to delete
     */
    where?: ExerciseTemplateWhereInput
    /**
     * Limit how many ExerciseTemplates to delete.
     */
    limit?: number
  }

  /**
   * ExerciseTemplate.exerciseEquipmentMappings
   */
  export type ExerciseTemplate$exerciseEquipmentMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    where?: ExerciseEquipmentMappingWhereInput
    orderBy?: ExerciseEquipmentMappingOrderByWithRelationInput | ExerciseEquipmentMappingOrderByWithRelationInput[]
    cursor?: ExerciseEquipmentMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseEquipmentMappingScalarFieldEnum | ExerciseEquipmentMappingScalarFieldEnum[]
  }

  /**
   * ExerciseTemplate.courseExercises
   */
  export type ExerciseTemplate$courseExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    where?: CourseExerciseWhereInput
    orderBy?: CourseExerciseOrderByWithRelationInput | CourseExerciseOrderByWithRelationInput[]
    cursor?: CourseExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseExerciseScalarFieldEnum | CourseExerciseScalarFieldEnum[]
  }

  /**
   * ExerciseTemplate without action
   */
  export type ExerciseTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTemplate
     */
    select?: ExerciseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTemplate
     */
    omit?: ExerciseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseEquipmentMapping
   */

  export type AggregateExerciseEquipmentMapping = {
    _count: ExerciseEquipmentMappingCountAggregateOutputType | null
    _min: ExerciseEquipmentMappingMinAggregateOutputType | null
    _max: ExerciseEquipmentMappingMaxAggregateOutputType | null
  }

  export type ExerciseEquipmentMappingMinAggregateOutputType = {
    id: string | null
    exerciseTemplateId: string | null
    equipmentTypeId: string | null
    isRequired: boolean | null
    createdAt: Date | null
  }

  export type ExerciseEquipmentMappingMaxAggregateOutputType = {
    id: string | null
    exerciseTemplateId: string | null
    equipmentTypeId: string | null
    isRequired: boolean | null
    createdAt: Date | null
  }

  export type ExerciseEquipmentMappingCountAggregateOutputType = {
    id: number
    exerciseTemplateId: number
    equipmentTypeId: number
    isRequired: number
    createdAt: number
    _all: number
  }


  export type ExerciseEquipmentMappingMinAggregateInputType = {
    id?: true
    exerciseTemplateId?: true
    equipmentTypeId?: true
    isRequired?: true
    createdAt?: true
  }

  export type ExerciseEquipmentMappingMaxAggregateInputType = {
    id?: true
    exerciseTemplateId?: true
    equipmentTypeId?: true
    isRequired?: true
    createdAt?: true
  }

  export type ExerciseEquipmentMappingCountAggregateInputType = {
    id?: true
    exerciseTemplateId?: true
    equipmentTypeId?: true
    isRequired?: true
    createdAt?: true
    _all?: true
  }

  export type ExerciseEquipmentMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseEquipmentMapping to aggregate.
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseEquipmentMappings to fetch.
     */
    orderBy?: ExerciseEquipmentMappingOrderByWithRelationInput | ExerciseEquipmentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseEquipmentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseEquipmentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseEquipmentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseEquipmentMappings
    **/
    _count?: true | ExerciseEquipmentMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseEquipmentMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseEquipmentMappingMaxAggregateInputType
  }

  export type GetExerciseEquipmentMappingAggregateType<T extends ExerciseEquipmentMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseEquipmentMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseEquipmentMapping[P]>
      : GetScalarType<T[P], AggregateExerciseEquipmentMapping[P]>
  }




  export type ExerciseEquipmentMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseEquipmentMappingWhereInput
    orderBy?: ExerciseEquipmentMappingOrderByWithAggregationInput | ExerciseEquipmentMappingOrderByWithAggregationInput[]
    by: ExerciseEquipmentMappingScalarFieldEnum[] | ExerciseEquipmentMappingScalarFieldEnum
    having?: ExerciseEquipmentMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseEquipmentMappingCountAggregateInputType | true
    _min?: ExerciseEquipmentMappingMinAggregateInputType
    _max?: ExerciseEquipmentMappingMaxAggregateInputType
  }

  export type ExerciseEquipmentMappingGroupByOutputType = {
    id: string
    exerciseTemplateId: string
    equipmentTypeId: string
    isRequired: boolean
    createdAt: Date
    _count: ExerciseEquipmentMappingCountAggregateOutputType | null
    _min: ExerciseEquipmentMappingMinAggregateOutputType | null
    _max: ExerciseEquipmentMappingMaxAggregateOutputType | null
  }

  type GetExerciseEquipmentMappingGroupByPayload<T extends ExerciseEquipmentMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseEquipmentMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseEquipmentMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseEquipmentMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseEquipmentMappingGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseEquipmentMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseTemplateId?: boolean
    equipmentTypeId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
    equipmentType?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseEquipmentMapping"]>

  export type ExerciseEquipmentMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseTemplateId?: boolean
    equipmentTypeId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
    equipmentType?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseEquipmentMapping"]>

  export type ExerciseEquipmentMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseTemplateId?: boolean
    equipmentTypeId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
    equipmentType?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseEquipmentMapping"]>

  export type ExerciseEquipmentMappingSelectScalar = {
    id?: boolean
    exerciseTemplateId?: boolean
    equipmentTypeId?: boolean
    isRequired?: boolean
    createdAt?: boolean
  }

  export type ExerciseEquipmentMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exerciseTemplateId" | "equipmentTypeId" | "isRequired" | "createdAt", ExtArgs["result"]["exerciseEquipmentMapping"]>
  export type ExerciseEquipmentMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
    equipmentType?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseEquipmentMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
    equipmentType?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseEquipmentMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
    equipmentType?: boolean | EquipmentTypeDefaultArgs<ExtArgs>
  }

  export type $ExerciseEquipmentMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseEquipmentMapping"
    objects: {
      exerciseTemplate: Prisma.$ExerciseTemplatePayload<ExtArgs>
      equipmentType: Prisma.$EquipmentTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exerciseTemplateId: string
      equipmentTypeId: string
      isRequired: boolean
      createdAt: Date
    }, ExtArgs["result"]["exerciseEquipmentMapping"]>
    composites: {}
  }

  type ExerciseEquipmentMappingGetPayload<S extends boolean | null | undefined | ExerciseEquipmentMappingDefaultArgs> = $Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload, S>

  type ExerciseEquipmentMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseEquipmentMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseEquipmentMappingCountAggregateInputType | true
    }

  export interface ExerciseEquipmentMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseEquipmentMapping'], meta: { name: 'ExerciseEquipmentMapping' } }
    /**
     * Find zero or one ExerciseEquipmentMapping that matches the filter.
     * @param {ExerciseEquipmentMappingFindUniqueArgs} args - Arguments to find a ExerciseEquipmentMapping
     * @example
     * // Get one ExerciseEquipmentMapping
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseEquipmentMappingFindUniqueArgs>(args: SelectSubset<T, ExerciseEquipmentMappingFindUniqueArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseEquipmentMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseEquipmentMappingFindUniqueOrThrowArgs} args - Arguments to find a ExerciseEquipmentMapping
     * @example
     * // Get one ExerciseEquipmentMapping
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseEquipmentMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseEquipmentMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseEquipmentMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingFindFirstArgs} args - Arguments to find a ExerciseEquipmentMapping
     * @example
     * // Get one ExerciseEquipmentMapping
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseEquipmentMappingFindFirstArgs>(args?: SelectSubset<T, ExerciseEquipmentMappingFindFirstArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseEquipmentMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingFindFirstOrThrowArgs} args - Arguments to find a ExerciseEquipmentMapping
     * @example
     * // Get one ExerciseEquipmentMapping
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseEquipmentMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseEquipmentMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExerciseEquipmentMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseEquipmentMappings
     * const exerciseEquipmentMappings = await prisma.exerciseEquipmentMapping.findMany()
     * 
     * // Get first 10 ExerciseEquipmentMappings
     * const exerciseEquipmentMappings = await prisma.exerciseEquipmentMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseEquipmentMappingWithIdOnly = await prisma.exerciseEquipmentMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseEquipmentMappingFindManyArgs>(args?: SelectSubset<T, ExerciseEquipmentMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseEquipmentMapping.
     * @param {ExerciseEquipmentMappingCreateArgs} args - Arguments to create a ExerciseEquipmentMapping.
     * @example
     * // Create one ExerciseEquipmentMapping
     * const ExerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.create({
     *   data: {
     *     // ... data to create a ExerciseEquipmentMapping
     *   }
     * })
     * 
     */
    create<T extends ExerciseEquipmentMappingCreateArgs>(args: SelectSubset<T, ExerciseEquipmentMappingCreateArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExerciseEquipmentMappings.
     * @param {ExerciseEquipmentMappingCreateManyArgs} args - Arguments to create many ExerciseEquipmentMappings.
     * @example
     * // Create many ExerciseEquipmentMappings
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseEquipmentMappingCreateManyArgs>(args?: SelectSubset<T, ExerciseEquipmentMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseEquipmentMappings and returns the data saved in the database.
     * @param {ExerciseEquipmentMappingCreateManyAndReturnArgs} args - Arguments to create many ExerciseEquipmentMappings.
     * @example
     * // Create many ExerciseEquipmentMappings
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseEquipmentMappings and only return the `id`
     * const exerciseEquipmentMappingWithIdOnly = await prisma.exerciseEquipmentMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseEquipmentMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseEquipmentMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseEquipmentMapping.
     * @param {ExerciseEquipmentMappingDeleteArgs} args - Arguments to delete one ExerciseEquipmentMapping.
     * @example
     * // Delete one ExerciseEquipmentMapping
     * const ExerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.delete({
     *   where: {
     *     // ... filter to delete one ExerciseEquipmentMapping
     *   }
     * })
     * 
     */
    delete<T extends ExerciseEquipmentMappingDeleteArgs>(args: SelectSubset<T, ExerciseEquipmentMappingDeleteArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseEquipmentMapping.
     * @param {ExerciseEquipmentMappingUpdateArgs} args - Arguments to update one ExerciseEquipmentMapping.
     * @example
     * // Update one ExerciseEquipmentMapping
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseEquipmentMappingUpdateArgs>(args: SelectSubset<T, ExerciseEquipmentMappingUpdateArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExerciseEquipmentMappings.
     * @param {ExerciseEquipmentMappingDeleteManyArgs} args - Arguments to filter ExerciseEquipmentMappings to delete.
     * @example
     * // Delete a few ExerciseEquipmentMappings
     * const { count } = await prisma.exerciseEquipmentMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseEquipmentMappingDeleteManyArgs>(args?: SelectSubset<T, ExerciseEquipmentMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseEquipmentMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseEquipmentMappings
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseEquipmentMappingUpdateManyArgs>(args: SelectSubset<T, ExerciseEquipmentMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseEquipmentMappings and returns the data updated in the database.
     * @param {ExerciseEquipmentMappingUpdateManyAndReturnArgs} args - Arguments to update many ExerciseEquipmentMappings.
     * @example
     * // Update many ExerciseEquipmentMappings
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciseEquipmentMappings and only return the `id`
     * const exerciseEquipmentMappingWithIdOnly = await prisma.exerciseEquipmentMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseEquipmentMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseEquipmentMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseEquipmentMapping.
     * @param {ExerciseEquipmentMappingUpsertArgs} args - Arguments to update or create a ExerciseEquipmentMapping.
     * @example
     * // Update or create a ExerciseEquipmentMapping
     * const exerciseEquipmentMapping = await prisma.exerciseEquipmentMapping.upsert({
     *   create: {
     *     // ... data to create a ExerciseEquipmentMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseEquipmentMapping we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseEquipmentMappingUpsertArgs>(args: SelectSubset<T, ExerciseEquipmentMappingUpsertArgs<ExtArgs>>): Prisma__ExerciseEquipmentMappingClient<$Result.GetResult<Prisma.$ExerciseEquipmentMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExerciseEquipmentMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingCountArgs} args - Arguments to filter ExerciseEquipmentMappings to count.
     * @example
     * // Count the number of ExerciseEquipmentMappings
     * const count = await prisma.exerciseEquipmentMapping.count({
     *   where: {
     *     // ... the filter for the ExerciseEquipmentMappings we want to count
     *   }
     * })
    **/
    count<T extends ExerciseEquipmentMappingCountArgs>(
      args?: Subset<T, ExerciseEquipmentMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseEquipmentMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseEquipmentMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseEquipmentMappingAggregateArgs>(args: Subset<T, ExerciseEquipmentMappingAggregateArgs>): Prisma.PrismaPromise<GetExerciseEquipmentMappingAggregateType<T>>

    /**
     * Group by ExerciseEquipmentMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseEquipmentMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseEquipmentMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseEquipmentMappingGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseEquipmentMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseEquipmentMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseEquipmentMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseEquipmentMapping model
   */
  readonly fields: ExerciseEquipmentMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseEquipmentMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseEquipmentMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exerciseTemplate<T extends ExerciseTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseTemplateDefaultArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipmentType<T extends EquipmentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentTypeDefaultArgs<ExtArgs>>): Prisma__EquipmentTypeClient<$Result.GetResult<Prisma.$EquipmentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseEquipmentMapping model
   */
  interface ExerciseEquipmentMappingFieldRefs {
    readonly id: FieldRef<"ExerciseEquipmentMapping", 'String'>
    readonly exerciseTemplateId: FieldRef<"ExerciseEquipmentMapping", 'String'>
    readonly equipmentTypeId: FieldRef<"ExerciseEquipmentMapping", 'String'>
    readonly isRequired: FieldRef<"ExerciseEquipmentMapping", 'Boolean'>
    readonly createdAt: FieldRef<"ExerciseEquipmentMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseEquipmentMapping findUnique
   */
  export type ExerciseEquipmentMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseEquipmentMapping to fetch.
     */
    where: ExerciseEquipmentMappingWhereUniqueInput
  }

  /**
   * ExerciseEquipmentMapping findUniqueOrThrow
   */
  export type ExerciseEquipmentMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseEquipmentMapping to fetch.
     */
    where: ExerciseEquipmentMappingWhereUniqueInput
  }

  /**
   * ExerciseEquipmentMapping findFirst
   */
  export type ExerciseEquipmentMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseEquipmentMapping to fetch.
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseEquipmentMappings to fetch.
     */
    orderBy?: ExerciseEquipmentMappingOrderByWithRelationInput | ExerciseEquipmentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseEquipmentMappings.
     */
    cursor?: ExerciseEquipmentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseEquipmentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseEquipmentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseEquipmentMappings.
     */
    distinct?: ExerciseEquipmentMappingScalarFieldEnum | ExerciseEquipmentMappingScalarFieldEnum[]
  }

  /**
   * ExerciseEquipmentMapping findFirstOrThrow
   */
  export type ExerciseEquipmentMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseEquipmentMapping to fetch.
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseEquipmentMappings to fetch.
     */
    orderBy?: ExerciseEquipmentMappingOrderByWithRelationInput | ExerciseEquipmentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseEquipmentMappings.
     */
    cursor?: ExerciseEquipmentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseEquipmentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseEquipmentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseEquipmentMappings.
     */
    distinct?: ExerciseEquipmentMappingScalarFieldEnum | ExerciseEquipmentMappingScalarFieldEnum[]
  }

  /**
   * ExerciseEquipmentMapping findMany
   */
  export type ExerciseEquipmentMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseEquipmentMappings to fetch.
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseEquipmentMappings to fetch.
     */
    orderBy?: ExerciseEquipmentMappingOrderByWithRelationInput | ExerciseEquipmentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseEquipmentMappings.
     */
    cursor?: ExerciseEquipmentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseEquipmentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseEquipmentMappings.
     */
    skip?: number
    distinct?: ExerciseEquipmentMappingScalarFieldEnum | ExerciseEquipmentMappingScalarFieldEnum[]
  }

  /**
   * ExerciseEquipmentMapping create
   */
  export type ExerciseEquipmentMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseEquipmentMapping.
     */
    data: XOR<ExerciseEquipmentMappingCreateInput, ExerciseEquipmentMappingUncheckedCreateInput>
  }

  /**
   * ExerciseEquipmentMapping createMany
   */
  export type ExerciseEquipmentMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseEquipmentMappings.
     */
    data: ExerciseEquipmentMappingCreateManyInput | ExerciseEquipmentMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseEquipmentMapping createManyAndReturn
   */
  export type ExerciseEquipmentMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciseEquipmentMappings.
     */
    data: ExerciseEquipmentMappingCreateManyInput | ExerciseEquipmentMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseEquipmentMapping update
   */
  export type ExerciseEquipmentMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseEquipmentMapping.
     */
    data: XOR<ExerciseEquipmentMappingUpdateInput, ExerciseEquipmentMappingUncheckedUpdateInput>
    /**
     * Choose, which ExerciseEquipmentMapping to update.
     */
    where: ExerciseEquipmentMappingWhereUniqueInput
  }

  /**
   * ExerciseEquipmentMapping updateMany
   */
  export type ExerciseEquipmentMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseEquipmentMappings.
     */
    data: XOR<ExerciseEquipmentMappingUpdateManyMutationInput, ExerciseEquipmentMappingUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseEquipmentMappings to update
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * Limit how many ExerciseEquipmentMappings to update.
     */
    limit?: number
  }

  /**
   * ExerciseEquipmentMapping updateManyAndReturn
   */
  export type ExerciseEquipmentMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * The data used to update ExerciseEquipmentMappings.
     */
    data: XOR<ExerciseEquipmentMappingUpdateManyMutationInput, ExerciseEquipmentMappingUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseEquipmentMappings to update
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * Limit how many ExerciseEquipmentMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseEquipmentMapping upsert
   */
  export type ExerciseEquipmentMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseEquipmentMapping to update in case it exists.
     */
    where: ExerciseEquipmentMappingWhereUniqueInput
    /**
     * In case the ExerciseEquipmentMapping found by the `where` argument doesn't exist, create a new ExerciseEquipmentMapping with this data.
     */
    create: XOR<ExerciseEquipmentMappingCreateInput, ExerciseEquipmentMappingUncheckedCreateInput>
    /**
     * In case the ExerciseEquipmentMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseEquipmentMappingUpdateInput, ExerciseEquipmentMappingUncheckedUpdateInput>
  }

  /**
   * ExerciseEquipmentMapping delete
   */
  export type ExerciseEquipmentMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
    /**
     * Filter which ExerciseEquipmentMapping to delete.
     */
    where: ExerciseEquipmentMappingWhereUniqueInput
  }

  /**
   * ExerciseEquipmentMapping deleteMany
   */
  export type ExerciseEquipmentMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseEquipmentMappings to delete
     */
    where?: ExerciseEquipmentMappingWhereInput
    /**
     * Limit how many ExerciseEquipmentMappings to delete.
     */
    limit?: number
  }

  /**
   * ExerciseEquipmentMapping without action
   */
  export type ExerciseEquipmentMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseEquipmentMapping
     */
    select?: ExerciseEquipmentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseEquipmentMapping
     */
    omit?: ExerciseEquipmentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseEquipmentMappingInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    totalDurationMinutes: number | null
    painLevel: number | null
  }

  export type CourseSumAggregateOutputType = {
    totalDurationMinutes: number | null
    painLevel: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalDurationMinutes: number | null
    painLevel: number | null
    experienceLevel: string | null
    courseType: string | null
    isTemplate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalDurationMinutes: number | null
    painLevel: number | null
    experienceLevel: string | null
    courseType: string | null
    isTemplate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    userId: number
    totalDurationMinutes: number
    painLevel: number
    experienceLevel: number
    bodyParts: number
    equipmentAvailable: number
    courseType: number
    isTemplate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    totalDurationMinutes?: true
    painLevel?: true
  }

  export type CourseSumAggregateInputType = {
    totalDurationMinutes?: true
    painLevel?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    userId?: true
    totalDurationMinutes?: true
    painLevel?: true
    experienceLevel?: true
    courseType?: true
    isTemplate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    userId?: true
    totalDurationMinutes?: true
    painLevel?: true
    experienceLevel?: true
    courseType?: true
    isTemplate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    userId?: true
    totalDurationMinutes?: true
    painLevel?: true
    experienceLevel?: true
    bodyParts?: true
    equipmentAvailable?: true
    courseType?: true
    isTemplate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    userId: string | null
    totalDurationMinutes: number
    painLevel: number | null
    experienceLevel: string | null
    bodyParts: string[]
    equipmentAvailable: string[]
    courseType: string
    isTemplate: boolean
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalDurationMinutes?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    bodyParts?: boolean
    equipmentAvailable?: boolean
    courseType?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Course$userArgs<ExtArgs>
    courseExercises?: boolean | Course$courseExercisesArgs<ExtArgs>
    userCourseHistory?: boolean | Course$userCourseHistoryArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalDurationMinutes?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    bodyParts?: boolean
    equipmentAvailable?: boolean
    courseType?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Course$userArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalDurationMinutes?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    bodyParts?: boolean
    equipmentAvailable?: boolean
    courseType?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Course$userArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    userId?: boolean
    totalDurationMinutes?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    bodyParts?: boolean
    equipmentAvailable?: boolean
    courseType?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalDurationMinutes" | "painLevel" | "experienceLevel" | "bodyParts" | "equipmentAvailable" | "courseType" | "isTemplate" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Course$userArgs<ExtArgs>
    courseExercises?: boolean | Course$courseExercisesArgs<ExtArgs>
    userCourseHistory?: boolean | Course$userCourseHistoryArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Course$userArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Course$userArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      courseExercises: Prisma.$CourseExercisePayload<ExtArgs>[]
      userCourseHistory: Prisma.$UserCourseHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      totalDurationMinutes: number
      painLevel: number | null
      experienceLevel: string | null
      bodyParts: string[]
      equipmentAvailable: string[]
      courseType: string
      isTemplate: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Course$userArgs<ExtArgs> = {}>(args?: Subset<T, Course$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    courseExercises<T extends Course$courseExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Course$courseExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCourseHistory<T extends Course$userCourseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Course$userCourseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly userId: FieldRef<"Course", 'String'>
    readonly totalDurationMinutes: FieldRef<"Course", 'Int'>
    readonly painLevel: FieldRef<"Course", 'Int'>
    readonly experienceLevel: FieldRef<"Course", 'String'>
    readonly bodyParts: FieldRef<"Course", 'String[]'>
    readonly equipmentAvailable: FieldRef<"Course", 'String[]'>
    readonly courseType: FieldRef<"Course", 'String'>
    readonly isTemplate: FieldRef<"Course", 'Boolean'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.user
   */
  export type Course$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Course.courseExercises
   */
  export type Course$courseExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    where?: CourseExerciseWhereInput
    orderBy?: CourseExerciseOrderByWithRelationInput | CourseExerciseOrderByWithRelationInput[]
    cursor?: CourseExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseExerciseScalarFieldEnum | CourseExerciseScalarFieldEnum[]
  }

  /**
   * Course.userCourseHistory
   */
  export type Course$userCourseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    where?: UserCourseHistoryWhereInput
    orderBy?: UserCourseHistoryOrderByWithRelationInput | UserCourseHistoryOrderByWithRelationInput[]
    cursor?: UserCourseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseHistoryScalarFieldEnum | UserCourseHistoryScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseExercise
   */

  export type AggregateCourseExercise = {
    _count: CourseExerciseCountAggregateOutputType | null
    _avg: CourseExerciseAvgAggregateOutputType | null
    _sum: CourseExerciseSumAggregateOutputType | null
    _min: CourseExerciseMinAggregateOutputType | null
    _max: CourseExerciseMaxAggregateOutputType | null
  }

  export type CourseExerciseAvgAggregateOutputType = {
    orderInSection: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
  }

  export type CourseExerciseSumAggregateOutputType = {
    orderInSection: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
  }

  export type CourseExerciseMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    exerciseTemplateId: string | null
    section: string | null
    orderInSection: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type CourseExerciseMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    exerciseTemplateId: string | null
    section: string | null
    orderInSection: number | null
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type CourseExerciseCountAggregateOutputType = {
    id: number
    courseId: number
    exerciseTemplateId: number
    section: number
    orderInSection: number
    durationMinutes: number
    reps: number
    sets: number
    restSeconds: number
    notes: number
    createdAt: number
    _all: number
  }


  export type CourseExerciseAvgAggregateInputType = {
    orderInSection?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
  }

  export type CourseExerciseSumAggregateInputType = {
    orderInSection?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
  }

  export type CourseExerciseMinAggregateInputType = {
    id?: true
    courseId?: true
    exerciseTemplateId?: true
    section?: true
    orderInSection?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    notes?: true
    createdAt?: true
  }

  export type CourseExerciseMaxAggregateInputType = {
    id?: true
    courseId?: true
    exerciseTemplateId?: true
    section?: true
    orderInSection?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    notes?: true
    createdAt?: true
  }

  export type CourseExerciseCountAggregateInputType = {
    id?: true
    courseId?: true
    exerciseTemplateId?: true
    section?: true
    orderInSection?: true
    durationMinutes?: true
    reps?: true
    sets?: true
    restSeconds?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type CourseExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseExercise to aggregate.
     */
    where?: CourseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseExercises to fetch.
     */
    orderBy?: CourseExerciseOrderByWithRelationInput | CourseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseExercises
    **/
    _count?: true | CourseExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseExerciseMaxAggregateInputType
  }

  export type GetCourseExerciseAggregateType<T extends CourseExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseExercise[P]>
      : GetScalarType<T[P], AggregateCourseExercise[P]>
  }




  export type CourseExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseExerciseWhereInput
    orderBy?: CourseExerciseOrderByWithAggregationInput | CourseExerciseOrderByWithAggregationInput[]
    by: CourseExerciseScalarFieldEnum[] | CourseExerciseScalarFieldEnum
    having?: CourseExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseExerciseCountAggregateInputType | true
    _avg?: CourseExerciseAvgAggregateInputType
    _sum?: CourseExerciseSumAggregateInputType
    _min?: CourseExerciseMinAggregateInputType
    _max?: CourseExerciseMaxAggregateInputType
  }

  export type CourseExerciseGroupByOutputType = {
    id: string
    courseId: string
    exerciseTemplateId: string
    section: string
    orderInSection: number
    durationMinutes: number | null
    reps: number | null
    sets: number | null
    restSeconds: number | null
    notes: string | null
    createdAt: Date
    _count: CourseExerciseCountAggregateOutputType | null
    _avg: CourseExerciseAvgAggregateOutputType | null
    _sum: CourseExerciseSumAggregateOutputType | null
    _min: CourseExerciseMinAggregateOutputType | null
    _max: CourseExerciseMaxAggregateOutputType | null
  }

  type GetCourseExerciseGroupByPayload<T extends CourseExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseExerciseGroupByOutputType[P]>
        }
      >
    >


  export type CourseExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    exerciseTemplateId?: boolean
    section?: boolean
    orderInSection?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    notes?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseExercise"]>

  export type CourseExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    exerciseTemplateId?: boolean
    section?: boolean
    orderInSection?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    notes?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseExercise"]>

  export type CourseExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    exerciseTemplateId?: boolean
    section?: boolean
    orderInSection?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    notes?: boolean
    createdAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseExercise"]>

  export type CourseExerciseSelectScalar = {
    id?: boolean
    courseId?: boolean
    exerciseTemplateId?: boolean
    section?: boolean
    orderInSection?: boolean
    durationMinutes?: boolean
    reps?: boolean
    sets?: boolean
    restSeconds?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type CourseExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "exerciseTemplateId" | "section" | "orderInSection" | "durationMinutes" | "reps" | "sets" | "restSeconds" | "notes" | "createdAt", ExtArgs["result"]["courseExercise"]>
  export type CourseExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
  }
  export type CourseExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
  }
  export type CourseExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    exerciseTemplate?: boolean | ExerciseTemplateDefaultArgs<ExtArgs>
  }

  export type $CourseExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseExercise"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      exerciseTemplate: Prisma.$ExerciseTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      exerciseTemplateId: string
      section: string
      orderInSection: number
      durationMinutes: number | null
      reps: number | null
      sets: number | null
      restSeconds: number | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["courseExercise"]>
    composites: {}
  }

  type CourseExerciseGetPayload<S extends boolean | null | undefined | CourseExerciseDefaultArgs> = $Result.GetResult<Prisma.$CourseExercisePayload, S>

  type CourseExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseExerciseCountAggregateInputType | true
    }

  export interface CourseExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseExercise'], meta: { name: 'CourseExercise' } }
    /**
     * Find zero or one CourseExercise that matches the filter.
     * @param {CourseExerciseFindUniqueArgs} args - Arguments to find a CourseExercise
     * @example
     * // Get one CourseExercise
     * const courseExercise = await prisma.courseExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseExerciseFindUniqueArgs>(args: SelectSubset<T, CourseExerciseFindUniqueArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseExerciseFindUniqueOrThrowArgs} args - Arguments to find a CourseExercise
     * @example
     * // Get one CourseExercise
     * const courseExercise = await prisma.courseExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseFindFirstArgs} args - Arguments to find a CourseExercise
     * @example
     * // Get one CourseExercise
     * const courseExercise = await prisma.courseExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseExerciseFindFirstArgs>(args?: SelectSubset<T, CourseExerciseFindFirstArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseFindFirstOrThrowArgs} args - Arguments to find a CourseExercise
     * @example
     * // Get one CourseExercise
     * const courseExercise = await prisma.courseExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseExercises
     * const courseExercises = await prisma.courseExercise.findMany()
     * 
     * // Get first 10 CourseExercises
     * const courseExercises = await prisma.courseExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseExerciseWithIdOnly = await prisma.courseExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseExerciseFindManyArgs>(args?: SelectSubset<T, CourseExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseExercise.
     * @param {CourseExerciseCreateArgs} args - Arguments to create a CourseExercise.
     * @example
     * // Create one CourseExercise
     * const CourseExercise = await prisma.courseExercise.create({
     *   data: {
     *     // ... data to create a CourseExercise
     *   }
     * })
     * 
     */
    create<T extends CourseExerciseCreateArgs>(args: SelectSubset<T, CourseExerciseCreateArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseExercises.
     * @param {CourseExerciseCreateManyArgs} args - Arguments to create many CourseExercises.
     * @example
     * // Create many CourseExercises
     * const courseExercise = await prisma.courseExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseExerciseCreateManyArgs>(args?: SelectSubset<T, CourseExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseExercises and returns the data saved in the database.
     * @param {CourseExerciseCreateManyAndReturnArgs} args - Arguments to create many CourseExercises.
     * @example
     * // Create many CourseExercises
     * const courseExercise = await prisma.courseExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseExercises and only return the `id`
     * const courseExerciseWithIdOnly = await prisma.courseExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseExercise.
     * @param {CourseExerciseDeleteArgs} args - Arguments to delete one CourseExercise.
     * @example
     * // Delete one CourseExercise
     * const CourseExercise = await prisma.courseExercise.delete({
     *   where: {
     *     // ... filter to delete one CourseExercise
     *   }
     * })
     * 
     */
    delete<T extends CourseExerciseDeleteArgs>(args: SelectSubset<T, CourseExerciseDeleteArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseExercise.
     * @param {CourseExerciseUpdateArgs} args - Arguments to update one CourseExercise.
     * @example
     * // Update one CourseExercise
     * const courseExercise = await prisma.courseExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseExerciseUpdateArgs>(args: SelectSubset<T, CourseExerciseUpdateArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseExercises.
     * @param {CourseExerciseDeleteManyArgs} args - Arguments to filter CourseExercises to delete.
     * @example
     * // Delete a few CourseExercises
     * const { count } = await prisma.courseExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseExerciseDeleteManyArgs>(args?: SelectSubset<T, CourseExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseExercises
     * const courseExercise = await prisma.courseExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseExerciseUpdateManyArgs>(args: SelectSubset<T, CourseExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseExercises and returns the data updated in the database.
     * @param {CourseExerciseUpdateManyAndReturnArgs} args - Arguments to update many CourseExercises.
     * @example
     * // Update many CourseExercises
     * const courseExercise = await prisma.courseExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseExercises and only return the `id`
     * const courseExerciseWithIdOnly = await prisma.courseExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseExercise.
     * @param {CourseExerciseUpsertArgs} args - Arguments to update or create a CourseExercise.
     * @example
     * // Update or create a CourseExercise
     * const courseExercise = await prisma.courseExercise.upsert({
     *   create: {
     *     // ... data to create a CourseExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseExercise we want to update
     *   }
     * })
     */
    upsert<T extends CourseExerciseUpsertArgs>(args: SelectSubset<T, CourseExerciseUpsertArgs<ExtArgs>>): Prisma__CourseExerciseClient<$Result.GetResult<Prisma.$CourseExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseCountArgs} args - Arguments to filter CourseExercises to count.
     * @example
     * // Count the number of CourseExercises
     * const count = await prisma.courseExercise.count({
     *   where: {
     *     // ... the filter for the CourseExercises we want to count
     *   }
     * })
    **/
    count<T extends CourseExerciseCountArgs>(
      args?: Subset<T, CourseExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseExerciseAggregateArgs>(args: Subset<T, CourseExerciseAggregateArgs>): Prisma.PrismaPromise<GetCourseExerciseAggregateType<T>>

    /**
     * Group by CourseExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseExerciseGroupByArgs['orderBy'] }
        : { orderBy?: CourseExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseExercise model
   */
  readonly fields: CourseExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exerciseTemplate<T extends ExerciseTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseTemplateDefaultArgs<ExtArgs>>): Prisma__ExerciseTemplateClient<$Result.GetResult<Prisma.$ExerciseTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseExercise model
   */
  interface CourseExerciseFieldRefs {
    readonly id: FieldRef<"CourseExercise", 'String'>
    readonly courseId: FieldRef<"CourseExercise", 'String'>
    readonly exerciseTemplateId: FieldRef<"CourseExercise", 'String'>
    readonly section: FieldRef<"CourseExercise", 'String'>
    readonly orderInSection: FieldRef<"CourseExercise", 'Int'>
    readonly durationMinutes: FieldRef<"CourseExercise", 'Int'>
    readonly reps: FieldRef<"CourseExercise", 'Int'>
    readonly sets: FieldRef<"CourseExercise", 'Int'>
    readonly restSeconds: FieldRef<"CourseExercise", 'Int'>
    readonly notes: FieldRef<"CourseExercise", 'String'>
    readonly createdAt: FieldRef<"CourseExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseExercise findUnique
   */
  export type CourseExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which CourseExercise to fetch.
     */
    where: CourseExerciseWhereUniqueInput
  }

  /**
   * CourseExercise findUniqueOrThrow
   */
  export type CourseExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which CourseExercise to fetch.
     */
    where: CourseExerciseWhereUniqueInput
  }

  /**
   * CourseExercise findFirst
   */
  export type CourseExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which CourseExercise to fetch.
     */
    where?: CourseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseExercises to fetch.
     */
    orderBy?: CourseExerciseOrderByWithRelationInput | CourseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseExercises.
     */
    cursor?: CourseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseExercises.
     */
    distinct?: CourseExerciseScalarFieldEnum | CourseExerciseScalarFieldEnum[]
  }

  /**
   * CourseExercise findFirstOrThrow
   */
  export type CourseExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which CourseExercise to fetch.
     */
    where?: CourseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseExercises to fetch.
     */
    orderBy?: CourseExerciseOrderByWithRelationInput | CourseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseExercises.
     */
    cursor?: CourseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseExercises.
     */
    distinct?: CourseExerciseScalarFieldEnum | CourseExerciseScalarFieldEnum[]
  }

  /**
   * CourseExercise findMany
   */
  export type CourseExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which CourseExercises to fetch.
     */
    where?: CourseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseExercises to fetch.
     */
    orderBy?: CourseExerciseOrderByWithRelationInput | CourseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseExercises.
     */
    cursor?: CourseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseExercises.
     */
    skip?: number
    distinct?: CourseExerciseScalarFieldEnum | CourseExerciseScalarFieldEnum[]
  }

  /**
   * CourseExercise create
   */
  export type CourseExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseExercise.
     */
    data: XOR<CourseExerciseCreateInput, CourseExerciseUncheckedCreateInput>
  }

  /**
   * CourseExercise createMany
   */
  export type CourseExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseExercises.
     */
    data: CourseExerciseCreateManyInput | CourseExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseExercise createManyAndReturn
   */
  export type CourseExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many CourseExercises.
     */
    data: CourseExerciseCreateManyInput | CourseExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseExercise update
   */
  export type CourseExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseExercise.
     */
    data: XOR<CourseExerciseUpdateInput, CourseExerciseUncheckedUpdateInput>
    /**
     * Choose, which CourseExercise to update.
     */
    where: CourseExerciseWhereUniqueInput
  }

  /**
   * CourseExercise updateMany
   */
  export type CourseExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseExercises.
     */
    data: XOR<CourseExerciseUpdateManyMutationInput, CourseExerciseUncheckedUpdateManyInput>
    /**
     * Filter which CourseExercises to update
     */
    where?: CourseExerciseWhereInput
    /**
     * Limit how many CourseExercises to update.
     */
    limit?: number
  }

  /**
   * CourseExercise updateManyAndReturn
   */
  export type CourseExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * The data used to update CourseExercises.
     */
    data: XOR<CourseExerciseUpdateManyMutationInput, CourseExerciseUncheckedUpdateManyInput>
    /**
     * Filter which CourseExercises to update
     */
    where?: CourseExerciseWhereInput
    /**
     * Limit how many CourseExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseExercise upsert
   */
  export type CourseExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseExercise to update in case it exists.
     */
    where: CourseExerciseWhereUniqueInput
    /**
     * In case the CourseExercise found by the `where` argument doesn't exist, create a new CourseExercise with this data.
     */
    create: XOR<CourseExerciseCreateInput, CourseExerciseUncheckedCreateInput>
    /**
     * In case the CourseExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseExerciseUpdateInput, CourseExerciseUncheckedUpdateInput>
  }

  /**
   * CourseExercise delete
   */
  export type CourseExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
    /**
     * Filter which CourseExercise to delete.
     */
    where: CourseExerciseWhereUniqueInput
  }

  /**
   * CourseExercise deleteMany
   */
  export type CourseExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseExercises to delete
     */
    where?: CourseExerciseWhereInput
    /**
     * Limit how many CourseExercises to delete.
     */
    limit?: number
  }

  /**
   * CourseExercise without action
   */
  export type CourseExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseExercise
     */
    select?: CourseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseExercise
     */
    omit?: CourseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseExerciseInclude<ExtArgs> | null
  }


  /**
   * Model UserPainProfile
   */

  export type AggregateUserPainProfile = {
    _count: UserPainProfileCountAggregateOutputType | null
    _avg: UserPainProfileAvgAggregateOutputType | null
    _sum: UserPainProfileSumAggregateOutputType | null
    _min: UserPainProfileMinAggregateOutputType | null
    _max: UserPainProfileMaxAggregateOutputType | null
  }

  export type UserPainProfileAvgAggregateOutputType = {
    painLevel: number | null
  }

  export type UserPainProfileSumAggregateOutputType = {
    painLevel: number | null
  }

  export type UserPainProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bodyPartId: string | null
    painLevel: number | null
    experienceLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPainProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bodyPartId: string | null
    painLevel: number | null
    experienceLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPainProfileCountAggregateOutputType = {
    id: number
    userId: number
    bodyPartId: number
    painLevel: number
    experienceLevel: number
    equipmentAvailable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPainProfileAvgAggregateInputType = {
    painLevel?: true
  }

  export type UserPainProfileSumAggregateInputType = {
    painLevel?: true
  }

  export type UserPainProfileMinAggregateInputType = {
    id?: true
    userId?: true
    bodyPartId?: true
    painLevel?: true
    experienceLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPainProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    bodyPartId?: true
    painLevel?: true
    experienceLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPainProfileCountAggregateInputType = {
    id?: true
    userId?: true
    bodyPartId?: true
    painLevel?: true
    experienceLevel?: true
    equipmentAvailable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPainProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPainProfile to aggregate.
     */
    where?: UserPainProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPainProfiles to fetch.
     */
    orderBy?: UserPainProfileOrderByWithRelationInput | UserPainProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPainProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPainProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPainProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPainProfiles
    **/
    _count?: true | UserPainProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPainProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPainProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPainProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPainProfileMaxAggregateInputType
  }

  export type GetUserPainProfileAggregateType<T extends UserPainProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPainProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPainProfile[P]>
      : GetScalarType<T[P], AggregateUserPainProfile[P]>
  }




  export type UserPainProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPainProfileWhereInput
    orderBy?: UserPainProfileOrderByWithAggregationInput | UserPainProfileOrderByWithAggregationInput[]
    by: UserPainProfileScalarFieldEnum[] | UserPainProfileScalarFieldEnum
    having?: UserPainProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPainProfileCountAggregateInputType | true
    _avg?: UserPainProfileAvgAggregateInputType
    _sum?: UserPainProfileSumAggregateInputType
    _min?: UserPainProfileMinAggregateInputType
    _max?: UserPainProfileMaxAggregateInputType
  }

  export type UserPainProfileGroupByOutputType = {
    id: string
    userId: string | null
    bodyPartId: string
    painLevel: number | null
    experienceLevel: string | null
    equipmentAvailable: string[]
    createdAt: Date
    updatedAt: Date
    _count: UserPainProfileCountAggregateOutputType | null
    _avg: UserPainProfileAvgAggregateOutputType | null
    _sum: UserPainProfileSumAggregateOutputType | null
    _min: UserPainProfileMinAggregateOutputType | null
    _max: UserPainProfileMaxAggregateOutputType | null
  }

  type GetUserPainProfileGroupByPayload<T extends UserPainProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPainProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPainProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPainProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserPainProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserPainProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bodyPartId?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    equipmentAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserPainProfile$userArgs<ExtArgs>
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPainProfile"]>

  export type UserPainProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bodyPartId?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    equipmentAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserPainProfile$userArgs<ExtArgs>
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPainProfile"]>

  export type UserPainProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bodyPartId?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    equipmentAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserPainProfile$userArgs<ExtArgs>
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPainProfile"]>

  export type UserPainProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    bodyPartId?: boolean
    painLevel?: boolean
    experienceLevel?: boolean
    equipmentAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPainProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bodyPartId" | "painLevel" | "experienceLevel" | "equipmentAvailable" | "createdAt" | "updatedAt", ExtArgs["result"]["userPainProfile"]>
  export type UserPainProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPainProfile$userArgs<ExtArgs>
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }
  export type UserPainProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPainProfile$userArgs<ExtArgs>
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }
  export type UserPainProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPainProfile$userArgs<ExtArgs>
    bodyPart?: boolean | BodyPartDefaultArgs<ExtArgs>
  }

  export type $UserPainProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPainProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      bodyPart: Prisma.$BodyPartPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      bodyPartId: string
      painLevel: number | null
      experienceLevel: string | null
      equipmentAvailable: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPainProfile"]>
    composites: {}
  }

  type UserPainProfileGetPayload<S extends boolean | null | undefined | UserPainProfileDefaultArgs> = $Result.GetResult<Prisma.$UserPainProfilePayload, S>

  type UserPainProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPainProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPainProfileCountAggregateInputType | true
    }

  export interface UserPainProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPainProfile'], meta: { name: 'UserPainProfile' } }
    /**
     * Find zero or one UserPainProfile that matches the filter.
     * @param {UserPainProfileFindUniqueArgs} args - Arguments to find a UserPainProfile
     * @example
     * // Get one UserPainProfile
     * const userPainProfile = await prisma.userPainProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPainProfileFindUniqueArgs>(args: SelectSubset<T, UserPainProfileFindUniqueArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPainProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPainProfileFindUniqueOrThrowArgs} args - Arguments to find a UserPainProfile
     * @example
     * // Get one UserPainProfile
     * const userPainProfile = await prisma.userPainProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPainProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPainProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPainProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileFindFirstArgs} args - Arguments to find a UserPainProfile
     * @example
     * // Get one UserPainProfile
     * const userPainProfile = await prisma.userPainProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPainProfileFindFirstArgs>(args?: SelectSubset<T, UserPainProfileFindFirstArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPainProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileFindFirstOrThrowArgs} args - Arguments to find a UserPainProfile
     * @example
     * // Get one UserPainProfile
     * const userPainProfile = await prisma.userPainProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPainProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPainProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPainProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPainProfiles
     * const userPainProfiles = await prisma.userPainProfile.findMany()
     * 
     * // Get first 10 UserPainProfiles
     * const userPainProfiles = await prisma.userPainProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPainProfileWithIdOnly = await prisma.userPainProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPainProfileFindManyArgs>(args?: SelectSubset<T, UserPainProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPainProfile.
     * @param {UserPainProfileCreateArgs} args - Arguments to create a UserPainProfile.
     * @example
     * // Create one UserPainProfile
     * const UserPainProfile = await prisma.userPainProfile.create({
     *   data: {
     *     // ... data to create a UserPainProfile
     *   }
     * })
     * 
     */
    create<T extends UserPainProfileCreateArgs>(args: SelectSubset<T, UserPainProfileCreateArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPainProfiles.
     * @param {UserPainProfileCreateManyArgs} args - Arguments to create many UserPainProfiles.
     * @example
     * // Create many UserPainProfiles
     * const userPainProfile = await prisma.userPainProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPainProfileCreateManyArgs>(args?: SelectSubset<T, UserPainProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPainProfiles and returns the data saved in the database.
     * @param {UserPainProfileCreateManyAndReturnArgs} args - Arguments to create many UserPainProfiles.
     * @example
     * // Create many UserPainProfiles
     * const userPainProfile = await prisma.userPainProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPainProfiles and only return the `id`
     * const userPainProfileWithIdOnly = await prisma.userPainProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPainProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPainProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPainProfile.
     * @param {UserPainProfileDeleteArgs} args - Arguments to delete one UserPainProfile.
     * @example
     * // Delete one UserPainProfile
     * const UserPainProfile = await prisma.userPainProfile.delete({
     *   where: {
     *     // ... filter to delete one UserPainProfile
     *   }
     * })
     * 
     */
    delete<T extends UserPainProfileDeleteArgs>(args: SelectSubset<T, UserPainProfileDeleteArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPainProfile.
     * @param {UserPainProfileUpdateArgs} args - Arguments to update one UserPainProfile.
     * @example
     * // Update one UserPainProfile
     * const userPainProfile = await prisma.userPainProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPainProfileUpdateArgs>(args: SelectSubset<T, UserPainProfileUpdateArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPainProfiles.
     * @param {UserPainProfileDeleteManyArgs} args - Arguments to filter UserPainProfiles to delete.
     * @example
     * // Delete a few UserPainProfiles
     * const { count } = await prisma.userPainProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPainProfileDeleteManyArgs>(args?: SelectSubset<T, UserPainProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPainProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPainProfiles
     * const userPainProfile = await prisma.userPainProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPainProfileUpdateManyArgs>(args: SelectSubset<T, UserPainProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPainProfiles and returns the data updated in the database.
     * @param {UserPainProfileUpdateManyAndReturnArgs} args - Arguments to update many UserPainProfiles.
     * @example
     * // Update many UserPainProfiles
     * const userPainProfile = await prisma.userPainProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPainProfiles and only return the `id`
     * const userPainProfileWithIdOnly = await prisma.userPainProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPainProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPainProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPainProfile.
     * @param {UserPainProfileUpsertArgs} args - Arguments to update or create a UserPainProfile.
     * @example
     * // Update or create a UserPainProfile
     * const userPainProfile = await prisma.userPainProfile.upsert({
     *   create: {
     *     // ... data to create a UserPainProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPainProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserPainProfileUpsertArgs>(args: SelectSubset<T, UserPainProfileUpsertArgs<ExtArgs>>): Prisma__UserPainProfileClient<$Result.GetResult<Prisma.$UserPainProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPainProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileCountArgs} args - Arguments to filter UserPainProfiles to count.
     * @example
     * // Count the number of UserPainProfiles
     * const count = await prisma.userPainProfile.count({
     *   where: {
     *     // ... the filter for the UserPainProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserPainProfileCountArgs>(
      args?: Subset<T, UserPainProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPainProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPainProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPainProfileAggregateArgs>(args: Subset<T, UserPainProfileAggregateArgs>): Prisma.PrismaPromise<GetUserPainProfileAggregateType<T>>

    /**
     * Group by UserPainProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPainProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPainProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPainProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserPainProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPainProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPainProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPainProfile model
   */
  readonly fields: UserPainProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPainProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPainProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserPainProfile$userArgs<ExtArgs> = {}>(args?: Subset<T, UserPainProfile$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bodyPart<T extends BodyPartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodyPartDefaultArgs<ExtArgs>>): Prisma__BodyPartClient<$Result.GetResult<Prisma.$BodyPartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPainProfile model
   */
  interface UserPainProfileFieldRefs {
    readonly id: FieldRef<"UserPainProfile", 'String'>
    readonly userId: FieldRef<"UserPainProfile", 'String'>
    readonly bodyPartId: FieldRef<"UserPainProfile", 'String'>
    readonly painLevel: FieldRef<"UserPainProfile", 'Int'>
    readonly experienceLevel: FieldRef<"UserPainProfile", 'String'>
    readonly equipmentAvailable: FieldRef<"UserPainProfile", 'String[]'>
    readonly createdAt: FieldRef<"UserPainProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPainProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPainProfile findUnique
   */
  export type UserPainProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserPainProfile to fetch.
     */
    where: UserPainProfileWhereUniqueInput
  }

  /**
   * UserPainProfile findUniqueOrThrow
   */
  export type UserPainProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserPainProfile to fetch.
     */
    where: UserPainProfileWhereUniqueInput
  }

  /**
   * UserPainProfile findFirst
   */
  export type UserPainProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserPainProfile to fetch.
     */
    where?: UserPainProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPainProfiles to fetch.
     */
    orderBy?: UserPainProfileOrderByWithRelationInput | UserPainProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPainProfiles.
     */
    cursor?: UserPainProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPainProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPainProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPainProfiles.
     */
    distinct?: UserPainProfileScalarFieldEnum | UserPainProfileScalarFieldEnum[]
  }

  /**
   * UserPainProfile findFirstOrThrow
   */
  export type UserPainProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserPainProfile to fetch.
     */
    where?: UserPainProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPainProfiles to fetch.
     */
    orderBy?: UserPainProfileOrderByWithRelationInput | UserPainProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPainProfiles.
     */
    cursor?: UserPainProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPainProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPainProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPainProfiles.
     */
    distinct?: UserPainProfileScalarFieldEnum | UserPainProfileScalarFieldEnum[]
  }

  /**
   * UserPainProfile findMany
   */
  export type UserPainProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserPainProfiles to fetch.
     */
    where?: UserPainProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPainProfiles to fetch.
     */
    orderBy?: UserPainProfileOrderByWithRelationInput | UserPainProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPainProfiles.
     */
    cursor?: UserPainProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPainProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPainProfiles.
     */
    skip?: number
    distinct?: UserPainProfileScalarFieldEnum | UserPainProfileScalarFieldEnum[]
  }

  /**
   * UserPainProfile create
   */
  export type UserPainProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPainProfile.
     */
    data: XOR<UserPainProfileCreateInput, UserPainProfileUncheckedCreateInput>
  }

  /**
   * UserPainProfile createMany
   */
  export type UserPainProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPainProfiles.
     */
    data: UserPainProfileCreateManyInput | UserPainProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPainProfile createManyAndReturn
   */
  export type UserPainProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserPainProfiles.
     */
    data: UserPainProfileCreateManyInput | UserPainProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPainProfile update
   */
  export type UserPainProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPainProfile.
     */
    data: XOR<UserPainProfileUpdateInput, UserPainProfileUncheckedUpdateInput>
    /**
     * Choose, which UserPainProfile to update.
     */
    where: UserPainProfileWhereUniqueInput
  }

  /**
   * UserPainProfile updateMany
   */
  export type UserPainProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPainProfiles.
     */
    data: XOR<UserPainProfileUpdateManyMutationInput, UserPainProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserPainProfiles to update
     */
    where?: UserPainProfileWhereInput
    /**
     * Limit how many UserPainProfiles to update.
     */
    limit?: number
  }

  /**
   * UserPainProfile updateManyAndReturn
   */
  export type UserPainProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserPainProfiles.
     */
    data: XOR<UserPainProfileUpdateManyMutationInput, UserPainProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserPainProfiles to update
     */
    where?: UserPainProfileWhereInput
    /**
     * Limit how many UserPainProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPainProfile upsert
   */
  export type UserPainProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPainProfile to update in case it exists.
     */
    where: UserPainProfileWhereUniqueInput
    /**
     * In case the UserPainProfile found by the `where` argument doesn't exist, create a new UserPainProfile with this data.
     */
    create: XOR<UserPainProfileCreateInput, UserPainProfileUncheckedCreateInput>
    /**
     * In case the UserPainProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPainProfileUpdateInput, UserPainProfileUncheckedUpdateInput>
  }

  /**
   * UserPainProfile delete
   */
  export type UserPainProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
    /**
     * Filter which UserPainProfile to delete.
     */
    where: UserPainProfileWhereUniqueInput
  }

  /**
   * UserPainProfile deleteMany
   */
  export type UserPainProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPainProfiles to delete
     */
    where?: UserPainProfileWhereInput
    /**
     * Limit how many UserPainProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserPainProfile.user
   */
  export type UserPainProfile$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserPainProfile without action
   */
  export type UserPainProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPainProfile
     */
    select?: UserPainProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPainProfile
     */
    omit?: UserPainProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPainProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserCourseHistory
   */

  export type AggregateUserCourseHistory = {
    _count: UserCourseHistoryCountAggregateOutputType | null
    _min: UserCourseHistoryMinAggregateOutputType | null
    _max: UserCourseHistoryMaxAggregateOutputType | null
  }

  export type UserCourseHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    completedAt: Date | null
    savedAt: Date | null
    isFavorite: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCourseHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    completedAt: Date | null
    savedAt: Date | null
    isFavorite: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCourseHistoryCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    completedAt: number
    savedAt: number
    isFavorite: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserCourseHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedAt?: true
    savedAt?: true
    isFavorite?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCourseHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedAt?: true
    savedAt?: true
    isFavorite?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCourseHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedAt?: true
    savedAt?: true
    isFavorite?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserCourseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseHistory to aggregate.
     */
    where?: UserCourseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseHistories to fetch.
     */
    orderBy?: UserCourseHistoryOrderByWithRelationInput | UserCourseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCourseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCourseHistories
    **/
    _count?: true | UserCourseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCourseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCourseHistoryMaxAggregateInputType
  }

  export type GetUserCourseHistoryAggregateType<T extends UserCourseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCourseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCourseHistory[P]>
      : GetScalarType<T[P], AggregateUserCourseHistory[P]>
  }




  export type UserCourseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseHistoryWhereInput
    orderBy?: UserCourseHistoryOrderByWithAggregationInput | UserCourseHistoryOrderByWithAggregationInput[]
    by: UserCourseHistoryScalarFieldEnum[] | UserCourseHistoryScalarFieldEnum
    having?: UserCourseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCourseHistoryCountAggregateInputType | true
    _min?: UserCourseHistoryMinAggregateInputType
    _max?: UserCourseHistoryMaxAggregateInputType
  }

  export type UserCourseHistoryGroupByOutputType = {
    id: string
    userId: string | null
    courseId: string
    completedAt: Date | null
    savedAt: Date
    isFavorite: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCourseHistoryCountAggregateOutputType | null
    _min: UserCourseHistoryMinAggregateOutputType | null
    _max: UserCourseHistoryMaxAggregateOutputType | null
  }

  type GetUserCourseHistoryGroupByPayload<T extends UserCourseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCourseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCourseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCourseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserCourseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserCourseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    completedAt?: boolean
    savedAt?: boolean
    isFavorite?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserCourseHistory$userArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseHistory"]>

  export type UserCourseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    completedAt?: boolean
    savedAt?: boolean
    isFavorite?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserCourseHistory$userArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseHistory"]>

  export type UserCourseHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    completedAt?: boolean
    savedAt?: boolean
    isFavorite?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserCourseHistory$userArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseHistory"]>

  export type UserCourseHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    completedAt?: boolean
    savedAt?: boolean
    isFavorite?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserCourseHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "completedAt" | "savedAt" | "isFavorite" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["userCourseHistory"]>
  export type UserCourseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserCourseHistory$userArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UserCourseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserCourseHistory$userArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UserCourseHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserCourseHistory$userArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $UserCourseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCourseHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      courseId: string
      completedAt: Date | null
      savedAt: Date
      isFavorite: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userCourseHistory"]>
    composites: {}
  }

  type UserCourseHistoryGetPayload<S extends boolean | null | undefined | UserCourseHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserCourseHistoryPayload, S>

  type UserCourseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCourseHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCourseHistoryCountAggregateInputType | true
    }

  export interface UserCourseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCourseHistory'], meta: { name: 'UserCourseHistory' } }
    /**
     * Find zero or one UserCourseHistory that matches the filter.
     * @param {UserCourseHistoryFindUniqueArgs} args - Arguments to find a UserCourseHistory
     * @example
     * // Get one UserCourseHistory
     * const userCourseHistory = await prisma.userCourseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCourseHistoryFindUniqueArgs>(args: SelectSubset<T, UserCourseHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCourseHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCourseHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserCourseHistory
     * @example
     * // Get one UserCourseHistory
     * const userCourseHistory = await prisma.userCourseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCourseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCourseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryFindFirstArgs} args - Arguments to find a UserCourseHistory
     * @example
     * // Get one UserCourseHistory
     * const userCourseHistory = await prisma.userCourseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCourseHistoryFindFirstArgs>(args?: SelectSubset<T, UserCourseHistoryFindFirstArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryFindFirstOrThrowArgs} args - Arguments to find a UserCourseHistory
     * @example
     * // Get one UserCourseHistory
     * const userCourseHistory = await prisma.userCourseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCourseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCourseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCourseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCourseHistories
     * const userCourseHistories = await prisma.userCourseHistory.findMany()
     * 
     * // Get first 10 UserCourseHistories
     * const userCourseHistories = await prisma.userCourseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCourseHistoryWithIdOnly = await prisma.userCourseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCourseHistoryFindManyArgs>(args?: SelectSubset<T, UserCourseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCourseHistory.
     * @param {UserCourseHistoryCreateArgs} args - Arguments to create a UserCourseHistory.
     * @example
     * // Create one UserCourseHistory
     * const UserCourseHistory = await prisma.userCourseHistory.create({
     *   data: {
     *     // ... data to create a UserCourseHistory
     *   }
     * })
     * 
     */
    create<T extends UserCourseHistoryCreateArgs>(args: SelectSubset<T, UserCourseHistoryCreateArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCourseHistories.
     * @param {UserCourseHistoryCreateManyArgs} args - Arguments to create many UserCourseHistories.
     * @example
     * // Create many UserCourseHistories
     * const userCourseHistory = await prisma.userCourseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCourseHistoryCreateManyArgs>(args?: SelectSubset<T, UserCourseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCourseHistories and returns the data saved in the database.
     * @param {UserCourseHistoryCreateManyAndReturnArgs} args - Arguments to create many UserCourseHistories.
     * @example
     * // Create many UserCourseHistories
     * const userCourseHistory = await prisma.userCourseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCourseHistories and only return the `id`
     * const userCourseHistoryWithIdOnly = await prisma.userCourseHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCourseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCourseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCourseHistory.
     * @param {UserCourseHistoryDeleteArgs} args - Arguments to delete one UserCourseHistory.
     * @example
     * // Delete one UserCourseHistory
     * const UserCourseHistory = await prisma.userCourseHistory.delete({
     *   where: {
     *     // ... filter to delete one UserCourseHistory
     *   }
     * })
     * 
     */
    delete<T extends UserCourseHistoryDeleteArgs>(args: SelectSubset<T, UserCourseHistoryDeleteArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCourseHistory.
     * @param {UserCourseHistoryUpdateArgs} args - Arguments to update one UserCourseHistory.
     * @example
     * // Update one UserCourseHistory
     * const userCourseHistory = await prisma.userCourseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCourseHistoryUpdateArgs>(args: SelectSubset<T, UserCourseHistoryUpdateArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCourseHistories.
     * @param {UserCourseHistoryDeleteManyArgs} args - Arguments to filter UserCourseHistories to delete.
     * @example
     * // Delete a few UserCourseHistories
     * const { count } = await prisma.userCourseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCourseHistoryDeleteManyArgs>(args?: SelectSubset<T, UserCourseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCourseHistories
     * const userCourseHistory = await prisma.userCourseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCourseHistoryUpdateManyArgs>(args: SelectSubset<T, UserCourseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseHistories and returns the data updated in the database.
     * @param {UserCourseHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserCourseHistories.
     * @example
     * // Update many UserCourseHistories
     * const userCourseHistory = await prisma.userCourseHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCourseHistories and only return the `id`
     * const userCourseHistoryWithIdOnly = await prisma.userCourseHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCourseHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCourseHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCourseHistory.
     * @param {UserCourseHistoryUpsertArgs} args - Arguments to update or create a UserCourseHistory.
     * @example
     * // Update or create a UserCourseHistory
     * const userCourseHistory = await prisma.userCourseHistory.upsert({
     *   create: {
     *     // ... data to create a UserCourseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCourseHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserCourseHistoryUpsertArgs>(args: SelectSubset<T, UserCourseHistoryUpsertArgs<ExtArgs>>): Prisma__UserCourseHistoryClient<$Result.GetResult<Prisma.$UserCourseHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCourseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryCountArgs} args - Arguments to filter UserCourseHistories to count.
     * @example
     * // Count the number of UserCourseHistories
     * const count = await prisma.userCourseHistory.count({
     *   where: {
     *     // ... the filter for the UserCourseHistories we want to count
     *   }
     * })
    **/
    count<T extends UserCourseHistoryCountArgs>(
      args?: Subset<T, UserCourseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCourseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCourseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCourseHistoryAggregateArgs>(args: Subset<T, UserCourseHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserCourseHistoryAggregateType<T>>

    /**
     * Group by UserCourseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCourseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCourseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserCourseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCourseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCourseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCourseHistory model
   */
  readonly fields: UserCourseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCourseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCourseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserCourseHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, UserCourseHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCourseHistory model
   */
  interface UserCourseHistoryFieldRefs {
    readonly id: FieldRef<"UserCourseHistory", 'String'>
    readonly userId: FieldRef<"UserCourseHistory", 'String'>
    readonly courseId: FieldRef<"UserCourseHistory", 'String'>
    readonly completedAt: FieldRef<"UserCourseHistory", 'DateTime'>
    readonly savedAt: FieldRef<"UserCourseHistory", 'DateTime'>
    readonly isFavorite: FieldRef<"UserCourseHistory", 'Boolean'>
    readonly notes: FieldRef<"UserCourseHistory", 'String'>
    readonly createdAt: FieldRef<"UserCourseHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"UserCourseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCourseHistory findUnique
   */
  export type UserCourseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseHistory to fetch.
     */
    where: UserCourseHistoryWhereUniqueInput
  }

  /**
   * UserCourseHistory findUniqueOrThrow
   */
  export type UserCourseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseHistory to fetch.
     */
    where: UserCourseHistoryWhereUniqueInput
  }

  /**
   * UserCourseHistory findFirst
   */
  export type UserCourseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseHistory to fetch.
     */
    where?: UserCourseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseHistories to fetch.
     */
    orderBy?: UserCourseHistoryOrderByWithRelationInput | UserCourseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseHistories.
     */
    cursor?: UserCourseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseHistories.
     */
    distinct?: UserCourseHistoryScalarFieldEnum | UserCourseHistoryScalarFieldEnum[]
  }

  /**
   * UserCourseHistory findFirstOrThrow
   */
  export type UserCourseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseHistory to fetch.
     */
    where?: UserCourseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseHistories to fetch.
     */
    orderBy?: UserCourseHistoryOrderByWithRelationInput | UserCourseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseHistories.
     */
    cursor?: UserCourseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseHistories.
     */
    distinct?: UserCourseHistoryScalarFieldEnum | UserCourseHistoryScalarFieldEnum[]
  }

  /**
   * UserCourseHistory findMany
   */
  export type UserCourseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseHistories to fetch.
     */
    where?: UserCourseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseHistories to fetch.
     */
    orderBy?: UserCourseHistoryOrderByWithRelationInput | UserCourseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCourseHistories.
     */
    cursor?: UserCourseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseHistories.
     */
    skip?: number
    distinct?: UserCourseHistoryScalarFieldEnum | UserCourseHistoryScalarFieldEnum[]
  }

  /**
   * UserCourseHistory create
   */
  export type UserCourseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCourseHistory.
     */
    data: XOR<UserCourseHistoryCreateInput, UserCourseHistoryUncheckedCreateInput>
  }

  /**
   * UserCourseHistory createMany
   */
  export type UserCourseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCourseHistories.
     */
    data: UserCourseHistoryCreateManyInput | UserCourseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCourseHistory createManyAndReturn
   */
  export type UserCourseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserCourseHistories.
     */
    data: UserCourseHistoryCreateManyInput | UserCourseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourseHistory update
   */
  export type UserCourseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCourseHistory.
     */
    data: XOR<UserCourseHistoryUpdateInput, UserCourseHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserCourseHistory to update.
     */
    where: UserCourseHistoryWhereUniqueInput
  }

  /**
   * UserCourseHistory updateMany
   */
  export type UserCourseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCourseHistories.
     */
    data: XOR<UserCourseHistoryUpdateManyMutationInput, UserCourseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseHistories to update
     */
    where?: UserCourseHistoryWhereInput
    /**
     * Limit how many UserCourseHistories to update.
     */
    limit?: number
  }

  /**
   * UserCourseHistory updateManyAndReturn
   */
  export type UserCourseHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserCourseHistories.
     */
    data: XOR<UserCourseHistoryUpdateManyMutationInput, UserCourseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseHistories to update
     */
    where?: UserCourseHistoryWhereInput
    /**
     * Limit how many UserCourseHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourseHistory upsert
   */
  export type UserCourseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCourseHistory to update in case it exists.
     */
    where: UserCourseHistoryWhereUniqueInput
    /**
     * In case the UserCourseHistory found by the `where` argument doesn't exist, create a new UserCourseHistory with this data.
     */
    create: XOR<UserCourseHistoryCreateInput, UserCourseHistoryUncheckedCreateInput>
    /**
     * In case the UserCourseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCourseHistoryUpdateInput, UserCourseHistoryUncheckedUpdateInput>
  }

  /**
   * UserCourseHistory delete
   */
  export type UserCourseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserCourseHistory to delete.
     */
    where: UserCourseHistoryWhereUniqueInput
  }

  /**
   * UserCourseHistory deleteMany
   */
  export type UserCourseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseHistories to delete
     */
    where?: UserCourseHistoryWhereInput
    /**
     * Limit how many UserCourseHistories to delete.
     */
    limit?: number
  }

  /**
   * UserCourseHistory.user
   */
  export type UserCourseHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserCourseHistory without action
   */
  export type UserCourseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseHistory
     */
    select?: UserCourseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseHistory
     */
    omit?: UserCourseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorite
   */

  export type AggregateUserFavorite = {
    _count: UserFavoriteCountAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  export type UserFavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gymId: string | null
    savedAt: Date | null
    createdAt: Date | null
  }

  export type UserFavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gymId: string | null
    savedAt: Date | null
    createdAt: Date | null
  }

  export type UserFavoriteCountAggregateOutputType = {
    id: number
    userId: number
    gymId: number
    savedAt: number
    createdAt: number
    _all: number
  }


  export type UserFavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    gymId?: true
    savedAt?: true
    createdAt?: true
  }

  export type UserFavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    gymId?: true
    savedAt?: true
    createdAt?: true
  }

  export type UserFavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    gymId?: true
    savedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorite to aggregate.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorites
    **/
    _count?: true | UserFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type GetUserFavoriteAggregateType<T extends UserFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorite[P]>
      : GetScalarType<T[P], AggregateUserFavorite[P]>
  }




  export type UserFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithAggregationInput | UserFavoriteOrderByWithAggregationInput[]
    by: UserFavoriteScalarFieldEnum[] | UserFavoriteScalarFieldEnum
    having?: UserFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteCountAggregateInputType | true
    _min?: UserFavoriteMinAggregateInputType
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type UserFavoriteGroupByOutputType = {
    id: string
    userId: string | null
    gymId: string
    savedAt: Date
    createdAt: Date
    _count: UserFavoriteCountAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  type GetUserFavoriteGroupByPayload<T extends UserFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gymId?: boolean
    savedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserFavorite$userArgs<ExtArgs>
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gymId?: boolean
    savedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserFavorite$userArgs<ExtArgs>
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gymId?: boolean
    savedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserFavorite$userArgs<ExtArgs>
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    gymId?: boolean
    savedAt?: boolean
    createdAt?: boolean
  }

  export type UserFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gymId" | "savedAt" | "createdAt", ExtArgs["result"]["userFavorite"]>
  export type UserFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFavorite$userArgs<ExtArgs>
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFavorite$userArgs<ExtArgs>
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFavorite$userArgs<ExtArgs>
    gym?: boolean | GymDefaultArgs<ExtArgs>
  }

  export type $UserFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      gym: Prisma.$GymPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      gymId: string
      savedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["userFavorite"]>
    composites: {}
  }

  type UserFavoriteGetPayload<S extends boolean | null | undefined | UserFavoriteDefaultArgs> = $Result.GetResult<Prisma.$UserFavoritePayload, S>

  type UserFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteCountAggregateInputType | true
    }

  export interface UserFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorite'], meta: { name: 'UserFavorite' } }
    /**
     * Find zero or one UserFavorite that matches the filter.
     * @param {UserFavoriteFindUniqueArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteFindUniqueArgs>(args: SelectSubset<T, UserFavoriteFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteFindUniqueOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteFindFirstArgs>(args?: SelectSubset<T, UserFavoriteFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany()
     * 
     * // Get first 10 UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavoriteFindManyArgs>(args?: SelectSubset<T, UserFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorite.
     * @param {UserFavoriteCreateArgs} args - Arguments to create a UserFavorite.
     * @example
     * // Create one UserFavorite
     * const UserFavorite = await prisma.userFavorite.create({
     *   data: {
     *     // ... data to create a UserFavorite
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteCreateArgs>(args: SelectSubset<T, UserFavoriteCreateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorites.
     * @param {UserFavoriteCreateManyArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteCreateManyArgs>(args?: SelectSubset<T, UserFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavorites and returns the data saved in the database.
     * @param {UserFavoriteCreateManyAndReturnArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavorite.
     * @param {UserFavoriteDeleteArgs} args - Arguments to delete one UserFavorite.
     * @example
     * // Delete one UserFavorite
     * const UserFavorite = await prisma.userFavorite.delete({
     *   where: {
     *     // ... filter to delete one UserFavorite
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteDeleteArgs>(args: SelectSubset<T, UserFavoriteDeleteArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorite.
     * @param {UserFavoriteUpdateArgs} args - Arguments to update one UserFavorite.
     * @example
     * // Update one UserFavorite
     * const userFavorite = await prisma.userFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteUpdateArgs>(args: SelectSubset<T, UserFavoriteUpdateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorites.
     * @param {UserFavoriteDeleteManyArgs} args - Arguments to filter UserFavorites to delete.
     * @example
     * // Delete a few UserFavorites
     * const { count } = await prisma.userFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteUpdateManyArgs>(args: SelectSubset<T, UserFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites and returns the data updated in the database.
     * @param {UserFavoriteUpdateManyAndReturnArgs} args - Arguments to update many UserFavorites.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavorite.
     * @param {UserFavoriteUpsertArgs} args - Arguments to update or create a UserFavorite.
     * @example
     * // Update or create a UserFavorite
     * const userFavorite = await prisma.userFavorite.upsert({
     *   create: {
     *     // ... data to create a UserFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorite we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteUpsertArgs>(args: SelectSubset<T, UserFavoriteUpsertArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteCountArgs} args - Arguments to filter UserFavorites to count.
     * @example
     * // Count the number of UserFavorites
     * const count = await prisma.userFavorite.count({
     *   where: {
     *     // ... the filter for the UserFavorites we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteCountArgs>(
      args?: Subset<T, UserFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteAggregateArgs>(args: Subset<T, UserFavoriteAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteAggregateType<T>>

    /**
     * Group by UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorite model
   */
  readonly fields: UserFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFavorite$userArgs<ExtArgs> = {}>(args?: Subset<T, UserFavorite$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gym<T extends GymDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymDefaultArgs<ExtArgs>>): Prisma__GymClient<$Result.GetResult<Prisma.$GymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorite model
   */
  interface UserFavoriteFieldRefs {
    readonly id: FieldRef<"UserFavorite", 'String'>
    readonly userId: FieldRef<"UserFavorite", 'String'>
    readonly gymId: FieldRef<"UserFavorite", 'String'>
    readonly savedAt: FieldRef<"UserFavorite", 'DateTime'>
    readonly createdAt: FieldRef<"UserFavorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorite findUnique
   */
  export type UserFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findUniqueOrThrow
   */
  export type UserFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findFirst
   */
  export type UserFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findFirstOrThrow
   */
  export type UserFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findMany
   */
  export type UserFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorites to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite create
   */
  export type UserFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorite.
     */
    data: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
  }

  /**
   * UserFavorite createMany
   */
  export type UserFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorite createManyAndReturn
   */
  export type UserFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite update
   */
  export type UserFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorite.
     */
    data: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
    /**
     * Choose, which UserFavorite to update.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite updateMany
   */
  export type UserFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
  }

  /**
   * UserFavorite updateManyAndReturn
   */
  export type UserFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite upsert
   */
  export type UserFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorite to update in case it exists.
     */
    where: UserFavoriteWhereUniqueInput
    /**
     * In case the UserFavorite found by the `where` argument doesn't exist, create a new UserFavorite with this data.
     */
    create: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
    /**
     * In case the UserFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
  }

  /**
   * UserFavorite delete
   */
  export type UserFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter which UserFavorite to delete.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite deleteMany
   */
  export type UserFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorites to delete
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to delete.
     */
    limit?: number
  }

  /**
   * UserFavorite.user
   */
  export type UserFavorite$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserFavorite without action
   */
  export type UserFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    eventName: string | null
    eventTime: Date | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    eventName: string | null
    eventTime: Date | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    userId: number
    anonymousId: number
    eventName: number
    eventData: number
    eventTime: number
    createdAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    eventName?: true
    eventTime?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    eventName?: true
    eventTime?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    eventName?: true
    eventData?: true
    eventTime?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    userId: string | null
    anonymousId: string | null
    eventName: string
    eventData: JsonValue | null
    eventTime: Date
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    eventName?: boolean
    eventData?: boolean
    eventTime?: boolean
    createdAt?: boolean
    user?: boolean | Event$userArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    eventName?: boolean
    eventData?: boolean
    eventTime?: boolean
    createdAt?: boolean
    user?: boolean | Event$userArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    eventName?: boolean
    eventData?: boolean
    eventTime?: boolean
    createdAt?: boolean
    user?: boolean | Event$userArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    eventName?: boolean
    eventData?: boolean
    eventTime?: boolean
    createdAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "anonymousId" | "eventName" | "eventData" | "eventTime" | "createdAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Event$userArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Event$userArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Event$userArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      anonymousId: string | null
      eventName: string
      eventData: Prisma.JsonValue | null
      eventTime: Date
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Event$userArgs<ExtArgs> = {}>(args?: Subset<T, Event$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly userId: FieldRef<"Event", 'String'>
    readonly anonymousId: FieldRef<"Event", 'String'>
    readonly eventName: FieldRef<"Event", 'String'>
    readonly eventData: FieldRef<"Event", 'Json'>
    readonly eventTime: FieldRef<"Event", 'DateTime'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.user
   */
  export type Event$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    name: string | null
    age: number | null
    gender: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    age: number | null
    gender: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    name: number
    age: number
    gender: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    name: string
    age: number
    gender: string
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "age" | "gender" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      age: number
      gender: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly age: FieldRef<"Patient", 'Int'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    displayName: 'displayName',
    isAdmin: 'isAdmin',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GymScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    phone: 'phone',
    website: 'website',
    priceRange: 'priceRange',
    description: 'description',
    isActive: 'isActive',
    facilityInfoCount: 'facilityInfoCount',
    lastUpdatedAt: 'lastUpdatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymScalarFieldEnum = (typeof GymScalarFieldEnum)[keyof typeof GymScalarFieldEnum]


  export const GymFacilityScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    isQuiet: 'isQuiet',
    hasRehabEquipment: 'hasRehabEquipment',
    hasPtCoach: 'hasPtCoach',
    hasShower: 'hasShower',
    hasParking: 'hasParking',
    hasLocker: 'hasLocker',
    hasWaterDispenser: 'hasWaterDispenser',
    hasAirConditioning: 'hasAirConditioning',
    otherFacilities: 'otherFacilities',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymFacilityScalarFieldEnum = (typeof GymFacilityScalarFieldEnum)[keyof typeof GymFacilityScalarFieldEnum]


  export const GymOperatingHourScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    dayOfWeek: 'dayOfWeek',
    openTime: 'openTime',
    closeTime: 'closeTime',
    isClosed: 'isClosed',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymOperatingHourScalarFieldEnum = (typeof GymOperatingHourScalarFieldEnum)[keyof typeof GymOperatingHourScalarFieldEnum]


  export const GymCrowdLevelScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    timeSlot: 'timeSlot',
    dayOfWeek: 'dayOfWeek',
    crowdLevel: 'crowdLevel',
    source: 'source',
    reportedAt: 'reportedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymCrowdLevelScalarFieldEnum = (typeof GymCrowdLevelScalarFieldEnum)[keyof typeof GymCrowdLevelScalarFieldEnum]


  export const ReviewTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ReviewTagScalarFieldEnum = (typeof ReviewTagScalarFieldEnum)[keyof typeof ReviewTagScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    gymId: 'gymId',
    userId: 'userId',
    comment: 'comment',
    isAdminReview: 'isAdminReview',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewTagMappingScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    reviewTagId: 'reviewTagId',
    createdAt: 'createdAt'
  };

  export type ReviewTagMappingScalarFieldEnum = (typeof ReviewTagMappingScalarFieldEnum)[keyof typeof ReviewTagMappingScalarFieldEnum]


  export const BodyPartScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type BodyPartScalarFieldEnum = (typeof BodyPartScalarFieldEnum)[keyof typeof BodyPartScalarFieldEnum]


  export const EquipmentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type EquipmentTypeScalarFieldEnum = (typeof EquipmentTypeScalarFieldEnum)[keyof typeof EquipmentTypeScalarFieldEnum]


  export const ExerciseTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    bodyPartId: 'bodyPartId',
    intensityLevel: 'intensityLevel',
    durationMinutes: 'durationMinutes',
    reps: 'reps',
    sets: 'sets',
    restSeconds: 'restSeconds',
    difficultyScore: 'difficultyScore',
    contraindications: 'contraindications',
    instructions: 'instructions',
    precautions: 'precautions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseTemplateScalarFieldEnum = (typeof ExerciseTemplateScalarFieldEnum)[keyof typeof ExerciseTemplateScalarFieldEnum]


  export const ExerciseEquipmentMappingScalarFieldEnum: {
    id: 'id',
    exerciseTemplateId: 'exerciseTemplateId',
    equipmentTypeId: 'equipmentTypeId',
    isRequired: 'isRequired',
    createdAt: 'createdAt'
  };

  export type ExerciseEquipmentMappingScalarFieldEnum = (typeof ExerciseEquipmentMappingScalarFieldEnum)[keyof typeof ExerciseEquipmentMappingScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalDurationMinutes: 'totalDurationMinutes',
    painLevel: 'painLevel',
    experienceLevel: 'experienceLevel',
    bodyParts: 'bodyParts',
    equipmentAvailable: 'equipmentAvailable',
    courseType: 'courseType',
    isTemplate: 'isTemplate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseExerciseScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    exerciseTemplateId: 'exerciseTemplateId',
    section: 'section',
    orderInSection: 'orderInSection',
    durationMinutes: 'durationMinutes',
    reps: 'reps',
    sets: 'sets',
    restSeconds: 'restSeconds',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type CourseExerciseScalarFieldEnum = (typeof CourseExerciseScalarFieldEnum)[keyof typeof CourseExerciseScalarFieldEnum]


  export const UserPainProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bodyPartId: 'bodyPartId',
    painLevel: 'painLevel',
    experienceLevel: 'experienceLevel',
    equipmentAvailable: 'equipmentAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPainProfileScalarFieldEnum = (typeof UserPainProfileScalarFieldEnum)[keyof typeof UserPainProfileScalarFieldEnum]


  export const UserCourseHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    completedAt: 'completedAt',
    savedAt: 'savedAt',
    isFavorite: 'isFavorite',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserCourseHistoryScalarFieldEnum = (typeof UserCourseHistoryScalarFieldEnum)[keyof typeof UserCourseHistoryScalarFieldEnum]


  export const UserFavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gymId: 'gymId',
    savedAt: 'savedAt',
    createdAt: 'createdAt'
  };

  export type UserFavoriteScalarFieldEnum = (typeof UserFavoriteScalarFieldEnum)[keyof typeof UserFavoriteScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    anonymousId: 'anonymousId',
    eventName: 'eventName',
    eventData: 'eventData',
    eventTime: 'eventTime',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    age: 'age',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reviews?: ReviewListRelationFilter
    courses?: CourseListRelationFilter
    userPainProfiles?: UserPainProfileListRelationFilter
    userCourseHistory?: UserCourseHistoryListRelationFilter
    userFavorites?: UserFavoriteListRelationFilter
    events?: EventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviews?: ReviewOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    userPainProfiles?: UserPainProfileOrderByRelationAggregateInput
    userCourseHistory?: UserCourseHistoryOrderByRelationAggregateInput
    userFavorites?: UserFavoriteOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    displayName?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reviews?: ReviewListRelationFilter
    courses?: CourseListRelationFilter
    userPainProfiles?: UserPainProfileListRelationFilter
    userCourseHistory?: UserCourseHistoryListRelationFilter
    userFavorites?: UserFavoriteListRelationFilter
    events?: EventListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GymWhereInput = {
    AND?: GymWhereInput | GymWhereInput[]
    OR?: GymWhereInput[]
    NOT?: GymWhereInput | GymWhereInput[]
    id?: UuidFilter<"Gym"> | string
    name?: StringFilter<"Gym"> | string
    address?: StringFilter<"Gym"> | string
    latitude?: DecimalFilter<"Gym"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"Gym"> | Decimal | DecimalJsLike | number | string
    phone?: StringNullableFilter<"Gym"> | string | null
    website?: StringNullableFilter<"Gym"> | string | null
    priceRange?: StringNullableFilter<"Gym"> | string | null
    description?: StringNullableFilter<"Gym"> | string | null
    isActive?: BoolFilter<"Gym"> | boolean
    facilityInfoCount?: IntFilter<"Gym"> | number
    lastUpdatedAt?: DateTimeNullableFilter<"Gym"> | Date | string | null
    createdAt?: DateTimeFilter<"Gym"> | Date | string
    updatedAt?: DateTimeFilter<"Gym"> | Date | string
    facilities?: XOR<GymFacilityNullableScalarRelationFilter, GymFacilityWhereInput> | null
    operatingHours?: GymOperatingHourListRelationFilter
    crowdLevels?: GymCrowdLevelListRelationFilter
    reviews?: ReviewListRelationFilter
    userFavorites?: UserFavoriteListRelationFilter
  }

  export type GymOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    facilityInfoCount?: SortOrder
    lastUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilities?: GymFacilityOrderByWithRelationInput
    operatingHours?: GymOperatingHourOrderByRelationAggregateInput
    crowdLevels?: GymCrowdLevelOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    userFavorites?: UserFavoriteOrderByRelationAggregateInput
  }

  export type GymWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GymWhereInput | GymWhereInput[]
    OR?: GymWhereInput[]
    NOT?: GymWhereInput | GymWhereInput[]
    name?: StringFilter<"Gym"> | string
    address?: StringFilter<"Gym"> | string
    latitude?: DecimalFilter<"Gym"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"Gym"> | Decimal | DecimalJsLike | number | string
    phone?: StringNullableFilter<"Gym"> | string | null
    website?: StringNullableFilter<"Gym"> | string | null
    priceRange?: StringNullableFilter<"Gym"> | string | null
    description?: StringNullableFilter<"Gym"> | string | null
    isActive?: BoolFilter<"Gym"> | boolean
    facilityInfoCount?: IntFilter<"Gym"> | number
    lastUpdatedAt?: DateTimeNullableFilter<"Gym"> | Date | string | null
    createdAt?: DateTimeFilter<"Gym"> | Date | string
    updatedAt?: DateTimeFilter<"Gym"> | Date | string
    facilities?: XOR<GymFacilityNullableScalarRelationFilter, GymFacilityWhereInput> | null
    operatingHours?: GymOperatingHourListRelationFilter
    crowdLevels?: GymCrowdLevelListRelationFilter
    reviews?: ReviewListRelationFilter
    userFavorites?: UserFavoriteListRelationFilter
  }, "id">

  export type GymOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    facilityInfoCount?: SortOrder
    lastUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymCountOrderByAggregateInput
    _avg?: GymAvgOrderByAggregateInput
    _max?: GymMaxOrderByAggregateInput
    _min?: GymMinOrderByAggregateInput
    _sum?: GymSumOrderByAggregateInput
  }

  export type GymScalarWhereWithAggregatesInput = {
    AND?: GymScalarWhereWithAggregatesInput | GymScalarWhereWithAggregatesInput[]
    OR?: GymScalarWhereWithAggregatesInput[]
    NOT?: GymScalarWhereWithAggregatesInput | GymScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Gym"> | string
    name?: StringWithAggregatesFilter<"Gym"> | string
    address?: StringWithAggregatesFilter<"Gym"> | string
    latitude?: DecimalWithAggregatesFilter<"Gym"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalWithAggregatesFilter<"Gym"> | Decimal | DecimalJsLike | number | string
    phone?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    website?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    priceRange?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    description?: StringNullableWithAggregatesFilter<"Gym"> | string | null
    isActive?: BoolWithAggregatesFilter<"Gym"> | boolean
    facilityInfoCount?: IntWithAggregatesFilter<"Gym"> | number
    lastUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Gym"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Gym"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gym"> | Date | string
  }

  export type GymFacilityWhereInput = {
    AND?: GymFacilityWhereInput | GymFacilityWhereInput[]
    OR?: GymFacilityWhereInput[]
    NOT?: GymFacilityWhereInput | GymFacilityWhereInput[]
    id?: UuidFilter<"GymFacility"> | string
    gymId?: UuidFilter<"GymFacility"> | string
    isQuiet?: BoolFilter<"GymFacility"> | boolean
    hasRehabEquipment?: BoolFilter<"GymFacility"> | boolean
    hasPtCoach?: BoolFilter<"GymFacility"> | boolean
    hasShower?: BoolFilter<"GymFacility"> | boolean
    hasParking?: BoolFilter<"GymFacility"> | boolean
    hasLocker?: BoolFilter<"GymFacility"> | boolean
    hasWaterDispenser?: BoolFilter<"GymFacility"> | boolean
    hasAirConditioning?: BoolFilter<"GymFacility"> | boolean
    otherFacilities?: StringNullableListFilter<"GymFacility">
    createdAt?: DateTimeFilter<"GymFacility"> | Date | string
    updatedAt?: DateTimeFilter<"GymFacility"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type GymFacilityOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    isQuiet?: SortOrder
    hasRehabEquipment?: SortOrder
    hasPtCoach?: SortOrder
    hasShower?: SortOrder
    hasParking?: SortOrder
    hasLocker?: SortOrder
    hasWaterDispenser?: SortOrder
    hasAirConditioning?: SortOrder
    otherFacilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type GymFacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gymId?: string
    AND?: GymFacilityWhereInput | GymFacilityWhereInput[]
    OR?: GymFacilityWhereInput[]
    NOT?: GymFacilityWhereInput | GymFacilityWhereInput[]
    isQuiet?: BoolFilter<"GymFacility"> | boolean
    hasRehabEquipment?: BoolFilter<"GymFacility"> | boolean
    hasPtCoach?: BoolFilter<"GymFacility"> | boolean
    hasShower?: BoolFilter<"GymFacility"> | boolean
    hasParking?: BoolFilter<"GymFacility"> | boolean
    hasLocker?: BoolFilter<"GymFacility"> | boolean
    hasWaterDispenser?: BoolFilter<"GymFacility"> | boolean
    hasAirConditioning?: BoolFilter<"GymFacility"> | boolean
    otherFacilities?: StringNullableListFilter<"GymFacility">
    createdAt?: DateTimeFilter<"GymFacility"> | Date | string
    updatedAt?: DateTimeFilter<"GymFacility"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id" | "gymId">

  export type GymFacilityOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    isQuiet?: SortOrder
    hasRehabEquipment?: SortOrder
    hasPtCoach?: SortOrder
    hasShower?: SortOrder
    hasParking?: SortOrder
    hasLocker?: SortOrder
    hasWaterDispenser?: SortOrder
    hasAirConditioning?: SortOrder
    otherFacilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymFacilityCountOrderByAggregateInput
    _max?: GymFacilityMaxOrderByAggregateInput
    _min?: GymFacilityMinOrderByAggregateInput
  }

  export type GymFacilityScalarWhereWithAggregatesInput = {
    AND?: GymFacilityScalarWhereWithAggregatesInput | GymFacilityScalarWhereWithAggregatesInput[]
    OR?: GymFacilityScalarWhereWithAggregatesInput[]
    NOT?: GymFacilityScalarWhereWithAggregatesInput | GymFacilityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GymFacility"> | string
    gymId?: UuidWithAggregatesFilter<"GymFacility"> | string
    isQuiet?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasRehabEquipment?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasPtCoach?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasShower?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasParking?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasLocker?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasWaterDispenser?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    hasAirConditioning?: BoolWithAggregatesFilter<"GymFacility"> | boolean
    otherFacilities?: StringNullableListFilter<"GymFacility">
    createdAt?: DateTimeWithAggregatesFilter<"GymFacility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymFacility"> | Date | string
  }

  export type GymOperatingHourWhereInput = {
    AND?: GymOperatingHourWhereInput | GymOperatingHourWhereInput[]
    OR?: GymOperatingHourWhereInput[]
    NOT?: GymOperatingHourWhereInput | GymOperatingHourWhereInput[]
    id?: UuidFilter<"GymOperatingHour"> | string
    gymId?: UuidFilter<"GymOperatingHour"> | string
    dayOfWeek?: IntFilter<"GymOperatingHour"> | number
    openTime?: StringNullableFilter<"GymOperatingHour"> | string | null
    closeTime?: StringNullableFilter<"GymOperatingHour"> | string | null
    isClosed?: BoolFilter<"GymOperatingHour"> | boolean
    notes?: StringNullableFilter<"GymOperatingHour"> | string | null
    createdAt?: DateTimeFilter<"GymOperatingHour"> | Date | string
    updatedAt?: DateTimeFilter<"GymOperatingHour"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type GymOperatingHourOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type GymOperatingHourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gymId_dayOfWeek?: GymOperatingHourGymIdDayOfWeekCompoundUniqueInput
    AND?: GymOperatingHourWhereInput | GymOperatingHourWhereInput[]
    OR?: GymOperatingHourWhereInput[]
    NOT?: GymOperatingHourWhereInput | GymOperatingHourWhereInput[]
    gymId?: UuidFilter<"GymOperatingHour"> | string
    dayOfWeek?: IntFilter<"GymOperatingHour"> | number
    openTime?: StringNullableFilter<"GymOperatingHour"> | string | null
    closeTime?: StringNullableFilter<"GymOperatingHour"> | string | null
    isClosed?: BoolFilter<"GymOperatingHour"> | boolean
    notes?: StringNullableFilter<"GymOperatingHour"> | string | null
    createdAt?: DateTimeFilter<"GymOperatingHour"> | Date | string
    updatedAt?: DateTimeFilter<"GymOperatingHour"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id" | "gymId_dayOfWeek">

  export type GymOperatingHourOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymOperatingHourCountOrderByAggregateInput
    _avg?: GymOperatingHourAvgOrderByAggregateInput
    _max?: GymOperatingHourMaxOrderByAggregateInput
    _min?: GymOperatingHourMinOrderByAggregateInput
    _sum?: GymOperatingHourSumOrderByAggregateInput
  }

  export type GymOperatingHourScalarWhereWithAggregatesInput = {
    AND?: GymOperatingHourScalarWhereWithAggregatesInput | GymOperatingHourScalarWhereWithAggregatesInput[]
    OR?: GymOperatingHourScalarWhereWithAggregatesInput[]
    NOT?: GymOperatingHourScalarWhereWithAggregatesInput | GymOperatingHourScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GymOperatingHour"> | string
    gymId?: UuidWithAggregatesFilter<"GymOperatingHour"> | string
    dayOfWeek?: IntWithAggregatesFilter<"GymOperatingHour"> | number
    openTime?: StringNullableWithAggregatesFilter<"GymOperatingHour"> | string | null
    closeTime?: StringNullableWithAggregatesFilter<"GymOperatingHour"> | string | null
    isClosed?: BoolWithAggregatesFilter<"GymOperatingHour"> | boolean
    notes?: StringNullableWithAggregatesFilter<"GymOperatingHour"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GymOperatingHour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymOperatingHour"> | Date | string
  }

  export type GymCrowdLevelWhereInput = {
    AND?: GymCrowdLevelWhereInput | GymCrowdLevelWhereInput[]
    OR?: GymCrowdLevelWhereInput[]
    NOT?: GymCrowdLevelWhereInput | GymCrowdLevelWhereInput[]
    id?: UuidFilter<"GymCrowdLevel"> | string
    gymId?: UuidFilter<"GymCrowdLevel"> | string
    timeSlot?: StringFilter<"GymCrowdLevel"> | string
    dayOfWeek?: IntNullableFilter<"GymCrowdLevel"> | number | null
    crowdLevel?: StringFilter<"GymCrowdLevel"> | string
    source?: StringFilter<"GymCrowdLevel"> | string
    reportedAt?: DateTimeNullableFilter<"GymCrowdLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"GymCrowdLevel"> | Date | string
    updatedAt?: DateTimeFilter<"GymCrowdLevel"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type GymCrowdLevelOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    timeSlot?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    crowdLevel?: SortOrder
    source?: SortOrder
    reportedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
  }

  export type GymCrowdLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GymCrowdLevelWhereInput | GymCrowdLevelWhereInput[]
    OR?: GymCrowdLevelWhereInput[]
    NOT?: GymCrowdLevelWhereInput | GymCrowdLevelWhereInput[]
    gymId?: UuidFilter<"GymCrowdLevel"> | string
    timeSlot?: StringFilter<"GymCrowdLevel"> | string
    dayOfWeek?: IntNullableFilter<"GymCrowdLevel"> | number | null
    crowdLevel?: StringFilter<"GymCrowdLevel"> | string
    source?: StringFilter<"GymCrowdLevel"> | string
    reportedAt?: DateTimeNullableFilter<"GymCrowdLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"GymCrowdLevel"> | Date | string
    updatedAt?: DateTimeFilter<"GymCrowdLevel"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id">

  export type GymCrowdLevelOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    timeSlot?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    crowdLevel?: SortOrder
    source?: SortOrder
    reportedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymCrowdLevelCountOrderByAggregateInput
    _avg?: GymCrowdLevelAvgOrderByAggregateInput
    _max?: GymCrowdLevelMaxOrderByAggregateInput
    _min?: GymCrowdLevelMinOrderByAggregateInput
    _sum?: GymCrowdLevelSumOrderByAggregateInput
  }

  export type GymCrowdLevelScalarWhereWithAggregatesInput = {
    AND?: GymCrowdLevelScalarWhereWithAggregatesInput | GymCrowdLevelScalarWhereWithAggregatesInput[]
    OR?: GymCrowdLevelScalarWhereWithAggregatesInput[]
    NOT?: GymCrowdLevelScalarWhereWithAggregatesInput | GymCrowdLevelScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GymCrowdLevel"> | string
    gymId?: UuidWithAggregatesFilter<"GymCrowdLevel"> | string
    timeSlot?: StringWithAggregatesFilter<"GymCrowdLevel"> | string
    dayOfWeek?: IntNullableWithAggregatesFilter<"GymCrowdLevel"> | number | null
    crowdLevel?: StringWithAggregatesFilter<"GymCrowdLevel"> | string
    source?: StringWithAggregatesFilter<"GymCrowdLevel"> | string
    reportedAt?: DateTimeNullableWithAggregatesFilter<"GymCrowdLevel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GymCrowdLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymCrowdLevel"> | Date | string
  }

  export type ReviewTagWhereInput = {
    AND?: ReviewTagWhereInput | ReviewTagWhereInput[]
    OR?: ReviewTagWhereInput[]
    NOT?: ReviewTagWhereInput | ReviewTagWhereInput[]
    id?: UuidFilter<"ReviewTag"> | string
    name?: StringFilter<"ReviewTag"> | string
    category?: StringNullableFilter<"ReviewTag"> | string | null
    displayOrder?: IntFilter<"ReviewTag"> | number
    isActive?: BoolFilter<"ReviewTag"> | boolean
    createdAt?: DateTimeFilter<"ReviewTag"> | Date | string
    reviewTagMappings?: ReviewTagMappingListRelationFilter
  }

  export type ReviewTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    reviewTagMappings?: ReviewTagMappingOrderByRelationAggregateInput
  }

  export type ReviewTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ReviewTagWhereInput | ReviewTagWhereInput[]
    OR?: ReviewTagWhereInput[]
    NOT?: ReviewTagWhereInput | ReviewTagWhereInput[]
    category?: StringNullableFilter<"ReviewTag"> | string | null
    displayOrder?: IntFilter<"ReviewTag"> | number
    isActive?: BoolFilter<"ReviewTag"> | boolean
    createdAt?: DateTimeFilter<"ReviewTag"> | Date | string
    reviewTagMappings?: ReviewTagMappingListRelationFilter
  }, "id" | "name">

  export type ReviewTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewTagCountOrderByAggregateInput
    _avg?: ReviewTagAvgOrderByAggregateInput
    _max?: ReviewTagMaxOrderByAggregateInput
    _min?: ReviewTagMinOrderByAggregateInput
    _sum?: ReviewTagSumOrderByAggregateInput
  }

  export type ReviewTagScalarWhereWithAggregatesInput = {
    AND?: ReviewTagScalarWhereWithAggregatesInput | ReviewTagScalarWhereWithAggregatesInput[]
    OR?: ReviewTagScalarWhereWithAggregatesInput[]
    NOT?: ReviewTagScalarWhereWithAggregatesInput | ReviewTagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ReviewTag"> | string
    name?: StringWithAggregatesFilter<"ReviewTag"> | string
    category?: StringNullableWithAggregatesFilter<"ReviewTag"> | string | null
    displayOrder?: IntWithAggregatesFilter<"ReviewTag"> | number
    isActive?: BoolWithAggregatesFilter<"ReviewTag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ReviewTag"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: UuidFilter<"Review"> | string
    gymId?: UuidFilter<"Review"> | string
    userId?: UuidNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    isAdminReview?: BoolFilter<"Review"> | boolean
    isDeleted?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reviewTagMappings?: ReviewTagMappingListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    gymId?: SortOrder
    userId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isAdminReview?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gym?: GymOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    reviewTagMappings?: ReviewTagMappingOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    gymId?: UuidFilter<"Review"> | string
    userId?: UuidNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    isAdminReview?: BoolFilter<"Review"> | boolean
    isDeleted?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reviewTagMappings?: ReviewTagMappingListRelationFilter
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    gymId?: SortOrder
    userId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isAdminReview?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Review"> | string
    gymId?: UuidWithAggregatesFilter<"Review"> | string
    userId?: UuidNullableWithAggregatesFilter<"Review"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isAdminReview?: BoolWithAggregatesFilter<"Review"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReviewTagMappingWhereInput = {
    AND?: ReviewTagMappingWhereInput | ReviewTagMappingWhereInput[]
    OR?: ReviewTagMappingWhereInput[]
    NOT?: ReviewTagMappingWhereInput | ReviewTagMappingWhereInput[]
    id?: UuidFilter<"ReviewTagMapping"> | string
    reviewId?: UuidFilter<"ReviewTagMapping"> | string
    reviewTagId?: UuidFilter<"ReviewTagMapping"> | string
    createdAt?: DateTimeFilter<"ReviewTagMapping"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    reviewTag?: XOR<ReviewTagScalarRelationFilter, ReviewTagWhereInput>
  }

  export type ReviewTagMappingOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    reviewTagId?: SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    reviewTag?: ReviewTagOrderByWithRelationInput
  }

  export type ReviewTagMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId_reviewTagId?: ReviewTagMappingReviewIdReviewTagIdCompoundUniqueInput
    AND?: ReviewTagMappingWhereInput | ReviewTagMappingWhereInput[]
    OR?: ReviewTagMappingWhereInput[]
    NOT?: ReviewTagMappingWhereInput | ReviewTagMappingWhereInput[]
    reviewId?: UuidFilter<"ReviewTagMapping"> | string
    reviewTagId?: UuidFilter<"ReviewTagMapping"> | string
    createdAt?: DateTimeFilter<"ReviewTagMapping"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    reviewTag?: XOR<ReviewTagScalarRelationFilter, ReviewTagWhereInput>
  }, "id" | "reviewId_reviewTagId">

  export type ReviewTagMappingOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    reviewTagId?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewTagMappingCountOrderByAggregateInput
    _max?: ReviewTagMappingMaxOrderByAggregateInput
    _min?: ReviewTagMappingMinOrderByAggregateInput
  }

  export type ReviewTagMappingScalarWhereWithAggregatesInput = {
    AND?: ReviewTagMappingScalarWhereWithAggregatesInput | ReviewTagMappingScalarWhereWithAggregatesInput[]
    OR?: ReviewTagMappingScalarWhereWithAggregatesInput[]
    NOT?: ReviewTagMappingScalarWhereWithAggregatesInput | ReviewTagMappingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ReviewTagMapping"> | string
    reviewId?: UuidWithAggregatesFilter<"ReviewTagMapping"> | string
    reviewTagId?: UuidWithAggregatesFilter<"ReviewTagMapping"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewTagMapping"> | Date | string
  }

  export type BodyPartWhereInput = {
    AND?: BodyPartWhereInput | BodyPartWhereInput[]
    OR?: BodyPartWhereInput[]
    NOT?: BodyPartWhereInput | BodyPartWhereInput[]
    id?: UuidFilter<"BodyPart"> | string
    name?: StringFilter<"BodyPart"> | string
    displayOrder?: IntFilter<"BodyPart"> | number
    isActive?: BoolFilter<"BodyPart"> | boolean
    createdAt?: DateTimeFilter<"BodyPart"> | Date | string
    exerciseTemplates?: ExerciseTemplateListRelationFilter
    userPainProfiles?: UserPainProfileListRelationFilter
  }

  export type BodyPartOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    exerciseTemplates?: ExerciseTemplateOrderByRelationAggregateInput
    userPainProfiles?: UserPainProfileOrderByRelationAggregateInput
  }

  export type BodyPartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BodyPartWhereInput | BodyPartWhereInput[]
    OR?: BodyPartWhereInput[]
    NOT?: BodyPartWhereInput | BodyPartWhereInput[]
    displayOrder?: IntFilter<"BodyPart"> | number
    isActive?: BoolFilter<"BodyPart"> | boolean
    createdAt?: DateTimeFilter<"BodyPart"> | Date | string
    exerciseTemplates?: ExerciseTemplateListRelationFilter
    userPainProfiles?: UserPainProfileListRelationFilter
  }, "id" | "name">

  export type BodyPartOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: BodyPartCountOrderByAggregateInput
    _avg?: BodyPartAvgOrderByAggregateInput
    _max?: BodyPartMaxOrderByAggregateInput
    _min?: BodyPartMinOrderByAggregateInput
    _sum?: BodyPartSumOrderByAggregateInput
  }

  export type BodyPartScalarWhereWithAggregatesInput = {
    AND?: BodyPartScalarWhereWithAggregatesInput | BodyPartScalarWhereWithAggregatesInput[]
    OR?: BodyPartScalarWhereWithAggregatesInput[]
    NOT?: BodyPartScalarWhereWithAggregatesInput | BodyPartScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BodyPart"> | string
    name?: StringWithAggregatesFilter<"BodyPart"> | string
    displayOrder?: IntWithAggregatesFilter<"BodyPart"> | number
    isActive?: BoolWithAggregatesFilter<"BodyPart"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BodyPart"> | Date | string
  }

  export type EquipmentTypeWhereInput = {
    AND?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    OR?: EquipmentTypeWhereInput[]
    NOT?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    id?: UuidFilter<"EquipmentType"> | string
    name?: StringFilter<"EquipmentType"> | string
    displayOrder?: IntFilter<"EquipmentType"> | number
    isActive?: BoolFilter<"EquipmentType"> | boolean
    createdAt?: DateTimeFilter<"EquipmentType"> | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingListRelationFilter
  }

  export type EquipmentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    exerciseEquipmentMappings?: ExerciseEquipmentMappingOrderByRelationAggregateInput
  }

  export type EquipmentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    OR?: EquipmentTypeWhereInput[]
    NOT?: EquipmentTypeWhereInput | EquipmentTypeWhereInput[]
    displayOrder?: IntFilter<"EquipmentType"> | number
    isActive?: BoolFilter<"EquipmentType"> | boolean
    createdAt?: DateTimeFilter<"EquipmentType"> | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingListRelationFilter
  }, "id" | "name">

  export type EquipmentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: EquipmentTypeCountOrderByAggregateInput
    _avg?: EquipmentTypeAvgOrderByAggregateInput
    _max?: EquipmentTypeMaxOrderByAggregateInput
    _min?: EquipmentTypeMinOrderByAggregateInput
    _sum?: EquipmentTypeSumOrderByAggregateInput
  }

  export type EquipmentTypeScalarWhereWithAggregatesInput = {
    AND?: EquipmentTypeScalarWhereWithAggregatesInput | EquipmentTypeScalarWhereWithAggregatesInput[]
    OR?: EquipmentTypeScalarWhereWithAggregatesInput[]
    NOT?: EquipmentTypeScalarWhereWithAggregatesInput | EquipmentTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EquipmentType"> | string
    name?: StringWithAggregatesFilter<"EquipmentType"> | string
    displayOrder?: IntWithAggregatesFilter<"EquipmentType"> | number
    isActive?: BoolWithAggregatesFilter<"EquipmentType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentType"> | Date | string
  }

  export type ExerciseTemplateWhereInput = {
    AND?: ExerciseTemplateWhereInput | ExerciseTemplateWhereInput[]
    OR?: ExerciseTemplateWhereInput[]
    NOT?: ExerciseTemplateWhereInput | ExerciseTemplateWhereInput[]
    id?: UuidFilter<"ExerciseTemplate"> | string
    name?: StringFilter<"ExerciseTemplate"> | string
    description?: StringNullableFilter<"ExerciseTemplate"> | string | null
    bodyPartId?: UuidFilter<"ExerciseTemplate"> | string
    intensityLevel?: IntNullableFilter<"ExerciseTemplate"> | number | null
    durationMinutes?: IntNullableFilter<"ExerciseTemplate"> | number | null
    reps?: IntNullableFilter<"ExerciseTemplate"> | number | null
    sets?: IntNullableFilter<"ExerciseTemplate"> | number | null
    restSeconds?: IntNullableFilter<"ExerciseTemplate"> | number | null
    difficultyScore?: IntNullableFilter<"ExerciseTemplate"> | number | null
    contraindications?: StringNullableListFilter<"ExerciseTemplate">
    instructions?: StringNullableFilter<"ExerciseTemplate"> | string | null
    precautions?: StringNullableFilter<"ExerciseTemplate"> | string | null
    isActive?: BoolFilter<"ExerciseTemplate"> | boolean
    createdAt?: DateTimeFilter<"ExerciseTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseTemplate"> | Date | string
    bodyPart?: XOR<BodyPartScalarRelationFilter, BodyPartWhereInput>
    exerciseEquipmentMappings?: ExerciseEquipmentMappingListRelationFilter
    courseExercises?: CourseExerciseListRelationFilter
  }

  export type ExerciseTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    bodyPartId?: SortOrder
    intensityLevel?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    sets?: SortOrderInput | SortOrder
    restSeconds?: SortOrderInput | SortOrder
    difficultyScore?: SortOrderInput | SortOrder
    contraindications?: SortOrder
    instructions?: SortOrderInput | SortOrder
    precautions?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bodyPart?: BodyPartOrderByWithRelationInput
    exerciseEquipmentMappings?: ExerciseEquipmentMappingOrderByRelationAggregateInput
    courseExercises?: CourseExerciseOrderByRelationAggregateInput
  }

  export type ExerciseTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseTemplateWhereInput | ExerciseTemplateWhereInput[]
    OR?: ExerciseTemplateWhereInput[]
    NOT?: ExerciseTemplateWhereInput | ExerciseTemplateWhereInput[]
    name?: StringFilter<"ExerciseTemplate"> | string
    description?: StringNullableFilter<"ExerciseTemplate"> | string | null
    bodyPartId?: UuidFilter<"ExerciseTemplate"> | string
    intensityLevel?: IntNullableFilter<"ExerciseTemplate"> | number | null
    durationMinutes?: IntNullableFilter<"ExerciseTemplate"> | number | null
    reps?: IntNullableFilter<"ExerciseTemplate"> | number | null
    sets?: IntNullableFilter<"ExerciseTemplate"> | number | null
    restSeconds?: IntNullableFilter<"ExerciseTemplate"> | number | null
    difficultyScore?: IntNullableFilter<"ExerciseTemplate"> | number | null
    contraindications?: StringNullableListFilter<"ExerciseTemplate">
    instructions?: StringNullableFilter<"ExerciseTemplate"> | string | null
    precautions?: StringNullableFilter<"ExerciseTemplate"> | string | null
    isActive?: BoolFilter<"ExerciseTemplate"> | boolean
    createdAt?: DateTimeFilter<"ExerciseTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseTemplate"> | Date | string
    bodyPart?: XOR<BodyPartScalarRelationFilter, BodyPartWhereInput>
    exerciseEquipmentMappings?: ExerciseEquipmentMappingListRelationFilter
    courseExercises?: CourseExerciseListRelationFilter
  }, "id">

  export type ExerciseTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    bodyPartId?: SortOrder
    intensityLevel?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    sets?: SortOrderInput | SortOrder
    restSeconds?: SortOrderInput | SortOrder
    difficultyScore?: SortOrderInput | SortOrder
    contraindications?: SortOrder
    instructions?: SortOrderInput | SortOrder
    precautions?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseTemplateCountOrderByAggregateInput
    _avg?: ExerciseTemplateAvgOrderByAggregateInput
    _max?: ExerciseTemplateMaxOrderByAggregateInput
    _min?: ExerciseTemplateMinOrderByAggregateInput
    _sum?: ExerciseTemplateSumOrderByAggregateInput
  }

  export type ExerciseTemplateScalarWhereWithAggregatesInput = {
    AND?: ExerciseTemplateScalarWhereWithAggregatesInput | ExerciseTemplateScalarWhereWithAggregatesInput[]
    OR?: ExerciseTemplateScalarWhereWithAggregatesInput[]
    NOT?: ExerciseTemplateScalarWhereWithAggregatesInput | ExerciseTemplateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ExerciseTemplate"> | string
    name?: StringWithAggregatesFilter<"ExerciseTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ExerciseTemplate"> | string | null
    bodyPartId?: UuidWithAggregatesFilter<"ExerciseTemplate"> | string
    intensityLevel?: IntNullableWithAggregatesFilter<"ExerciseTemplate"> | number | null
    durationMinutes?: IntNullableWithAggregatesFilter<"ExerciseTemplate"> | number | null
    reps?: IntNullableWithAggregatesFilter<"ExerciseTemplate"> | number | null
    sets?: IntNullableWithAggregatesFilter<"ExerciseTemplate"> | number | null
    restSeconds?: IntNullableWithAggregatesFilter<"ExerciseTemplate"> | number | null
    difficultyScore?: IntNullableWithAggregatesFilter<"ExerciseTemplate"> | number | null
    contraindications?: StringNullableListFilter<"ExerciseTemplate">
    instructions?: StringNullableWithAggregatesFilter<"ExerciseTemplate"> | string | null
    precautions?: StringNullableWithAggregatesFilter<"ExerciseTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"ExerciseTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExerciseTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExerciseTemplate"> | Date | string
  }

  export type ExerciseEquipmentMappingWhereInput = {
    AND?: ExerciseEquipmentMappingWhereInput | ExerciseEquipmentMappingWhereInput[]
    OR?: ExerciseEquipmentMappingWhereInput[]
    NOT?: ExerciseEquipmentMappingWhereInput | ExerciseEquipmentMappingWhereInput[]
    id?: UuidFilter<"ExerciseEquipmentMapping"> | string
    exerciseTemplateId?: UuidFilter<"ExerciseEquipmentMapping"> | string
    equipmentTypeId?: UuidFilter<"ExerciseEquipmentMapping"> | string
    isRequired?: BoolFilter<"ExerciseEquipmentMapping"> | boolean
    createdAt?: DateTimeFilter<"ExerciseEquipmentMapping"> | Date | string
    exerciseTemplate?: XOR<ExerciseTemplateScalarRelationFilter, ExerciseTemplateWhereInput>
    equipmentType?: XOR<EquipmentTypeScalarRelationFilter, EquipmentTypeWhereInput>
  }

  export type ExerciseEquipmentMappingOrderByWithRelationInput = {
    id?: SortOrder
    exerciseTemplateId?: SortOrder
    equipmentTypeId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    exerciseTemplate?: ExerciseTemplateOrderByWithRelationInput
    equipmentType?: EquipmentTypeOrderByWithRelationInput
  }

  export type ExerciseEquipmentMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    exerciseTemplateId_equipmentTypeId?: ExerciseEquipmentMappingExerciseTemplateIdEquipmentTypeIdCompoundUniqueInput
    AND?: ExerciseEquipmentMappingWhereInput | ExerciseEquipmentMappingWhereInput[]
    OR?: ExerciseEquipmentMappingWhereInput[]
    NOT?: ExerciseEquipmentMappingWhereInput | ExerciseEquipmentMappingWhereInput[]
    exerciseTemplateId?: UuidFilter<"ExerciseEquipmentMapping"> | string
    equipmentTypeId?: UuidFilter<"ExerciseEquipmentMapping"> | string
    isRequired?: BoolFilter<"ExerciseEquipmentMapping"> | boolean
    createdAt?: DateTimeFilter<"ExerciseEquipmentMapping"> | Date | string
    exerciseTemplate?: XOR<ExerciseTemplateScalarRelationFilter, ExerciseTemplateWhereInput>
    equipmentType?: XOR<EquipmentTypeScalarRelationFilter, EquipmentTypeWhereInput>
  }, "id" | "exerciseTemplateId_equipmentTypeId">

  export type ExerciseEquipmentMappingOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseTemplateId?: SortOrder
    equipmentTypeId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    _count?: ExerciseEquipmentMappingCountOrderByAggregateInput
    _max?: ExerciseEquipmentMappingMaxOrderByAggregateInput
    _min?: ExerciseEquipmentMappingMinOrderByAggregateInput
  }

  export type ExerciseEquipmentMappingScalarWhereWithAggregatesInput = {
    AND?: ExerciseEquipmentMappingScalarWhereWithAggregatesInput | ExerciseEquipmentMappingScalarWhereWithAggregatesInput[]
    OR?: ExerciseEquipmentMappingScalarWhereWithAggregatesInput[]
    NOT?: ExerciseEquipmentMappingScalarWhereWithAggregatesInput | ExerciseEquipmentMappingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ExerciseEquipmentMapping"> | string
    exerciseTemplateId?: UuidWithAggregatesFilter<"ExerciseEquipmentMapping"> | string
    equipmentTypeId?: UuidWithAggregatesFilter<"ExerciseEquipmentMapping"> | string
    isRequired?: BoolWithAggregatesFilter<"ExerciseEquipmentMapping"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExerciseEquipmentMapping"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: UuidFilter<"Course"> | string
    userId?: UuidNullableFilter<"Course"> | string | null
    totalDurationMinutes?: IntFilter<"Course"> | number
    painLevel?: IntNullableFilter<"Course"> | number | null
    experienceLevel?: StringNullableFilter<"Course"> | string | null
    bodyParts?: StringNullableListFilter<"Course">
    equipmentAvailable?: StringNullableListFilter<"Course">
    courseType?: StringFilter<"Course"> | string
    isTemplate?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courseExercises?: CourseExerciseListRelationFilter
    userCourseHistory?: UserCourseHistoryListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    bodyParts?: SortOrder
    equipmentAvailable?: SortOrder
    courseType?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    courseExercises?: CourseExerciseOrderByRelationAggregateInput
    userCourseHistory?: UserCourseHistoryOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    userId?: UuidNullableFilter<"Course"> | string | null
    totalDurationMinutes?: IntFilter<"Course"> | number
    painLevel?: IntNullableFilter<"Course"> | number | null
    experienceLevel?: StringNullableFilter<"Course"> | string | null
    bodyParts?: StringNullableListFilter<"Course">
    equipmentAvailable?: StringNullableListFilter<"Course">
    courseType?: StringFilter<"Course"> | string
    isTemplate?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courseExercises?: CourseExerciseListRelationFilter
    userCourseHistory?: UserCourseHistoryListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    bodyParts?: SortOrder
    equipmentAvailable?: SortOrder
    courseType?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Course"> | string
    userId?: UuidNullableWithAggregatesFilter<"Course"> | string | null
    totalDurationMinutes?: IntWithAggregatesFilter<"Course"> | number
    painLevel?: IntNullableWithAggregatesFilter<"Course"> | number | null
    experienceLevel?: StringNullableWithAggregatesFilter<"Course"> | string | null
    bodyParts?: StringNullableListFilter<"Course">
    equipmentAvailable?: StringNullableListFilter<"Course">
    courseType?: StringWithAggregatesFilter<"Course"> | string
    isTemplate?: BoolWithAggregatesFilter<"Course"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseExerciseWhereInput = {
    AND?: CourseExerciseWhereInput | CourseExerciseWhereInput[]
    OR?: CourseExerciseWhereInput[]
    NOT?: CourseExerciseWhereInput | CourseExerciseWhereInput[]
    id?: UuidFilter<"CourseExercise"> | string
    courseId?: UuidFilter<"CourseExercise"> | string
    exerciseTemplateId?: UuidFilter<"CourseExercise"> | string
    section?: StringFilter<"CourseExercise"> | string
    orderInSection?: IntFilter<"CourseExercise"> | number
    durationMinutes?: IntNullableFilter<"CourseExercise"> | number | null
    reps?: IntNullableFilter<"CourseExercise"> | number | null
    sets?: IntNullableFilter<"CourseExercise"> | number | null
    restSeconds?: IntNullableFilter<"CourseExercise"> | number | null
    notes?: StringNullableFilter<"CourseExercise"> | string | null
    createdAt?: DateTimeFilter<"CourseExercise"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    exerciseTemplate?: XOR<ExerciseTemplateScalarRelationFilter, ExerciseTemplateWhereInput>
  }

  export type CourseExerciseOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    exerciseTemplateId?: SortOrder
    section?: SortOrder
    orderInSection?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    sets?: SortOrderInput | SortOrder
    restSeconds?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    exerciseTemplate?: ExerciseTemplateOrderByWithRelationInput
  }

  export type CourseExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseExerciseWhereInput | CourseExerciseWhereInput[]
    OR?: CourseExerciseWhereInput[]
    NOT?: CourseExerciseWhereInput | CourseExerciseWhereInput[]
    courseId?: UuidFilter<"CourseExercise"> | string
    exerciseTemplateId?: UuidFilter<"CourseExercise"> | string
    section?: StringFilter<"CourseExercise"> | string
    orderInSection?: IntFilter<"CourseExercise"> | number
    durationMinutes?: IntNullableFilter<"CourseExercise"> | number | null
    reps?: IntNullableFilter<"CourseExercise"> | number | null
    sets?: IntNullableFilter<"CourseExercise"> | number | null
    restSeconds?: IntNullableFilter<"CourseExercise"> | number | null
    notes?: StringNullableFilter<"CourseExercise"> | string | null
    createdAt?: DateTimeFilter<"CourseExercise"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    exerciseTemplate?: XOR<ExerciseTemplateScalarRelationFilter, ExerciseTemplateWhereInput>
  }, "id">

  export type CourseExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    exerciseTemplateId?: SortOrder
    section?: SortOrder
    orderInSection?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    sets?: SortOrderInput | SortOrder
    restSeconds?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourseExerciseCountOrderByAggregateInput
    _avg?: CourseExerciseAvgOrderByAggregateInput
    _max?: CourseExerciseMaxOrderByAggregateInput
    _min?: CourseExerciseMinOrderByAggregateInput
    _sum?: CourseExerciseSumOrderByAggregateInput
  }

  export type CourseExerciseScalarWhereWithAggregatesInput = {
    AND?: CourseExerciseScalarWhereWithAggregatesInput | CourseExerciseScalarWhereWithAggregatesInput[]
    OR?: CourseExerciseScalarWhereWithAggregatesInput[]
    NOT?: CourseExerciseScalarWhereWithAggregatesInput | CourseExerciseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CourseExercise"> | string
    courseId?: UuidWithAggregatesFilter<"CourseExercise"> | string
    exerciseTemplateId?: UuidWithAggregatesFilter<"CourseExercise"> | string
    section?: StringWithAggregatesFilter<"CourseExercise"> | string
    orderInSection?: IntWithAggregatesFilter<"CourseExercise"> | number
    durationMinutes?: IntNullableWithAggregatesFilter<"CourseExercise"> | number | null
    reps?: IntNullableWithAggregatesFilter<"CourseExercise"> | number | null
    sets?: IntNullableWithAggregatesFilter<"CourseExercise"> | number | null
    restSeconds?: IntNullableWithAggregatesFilter<"CourseExercise"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CourseExercise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseExercise"> | Date | string
  }

  export type UserPainProfileWhereInput = {
    AND?: UserPainProfileWhereInput | UserPainProfileWhereInput[]
    OR?: UserPainProfileWhereInput[]
    NOT?: UserPainProfileWhereInput | UserPainProfileWhereInput[]
    id?: UuidFilter<"UserPainProfile"> | string
    userId?: UuidNullableFilter<"UserPainProfile"> | string | null
    bodyPartId?: UuidFilter<"UserPainProfile"> | string
    painLevel?: IntNullableFilter<"UserPainProfile"> | number | null
    experienceLevel?: StringNullableFilter<"UserPainProfile"> | string | null
    equipmentAvailable?: StringNullableListFilter<"UserPainProfile">
    createdAt?: DateTimeFilter<"UserPainProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserPainProfile"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bodyPart?: XOR<BodyPartScalarRelationFilter, BodyPartWhereInput>
  }

  export type UserPainProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    bodyPartId?: SortOrder
    painLevel?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    equipmentAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bodyPart?: BodyPartOrderByWithRelationInput
  }

  export type UserPainProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPainProfileWhereInput | UserPainProfileWhereInput[]
    OR?: UserPainProfileWhereInput[]
    NOT?: UserPainProfileWhereInput | UserPainProfileWhereInput[]
    userId?: UuidNullableFilter<"UserPainProfile"> | string | null
    bodyPartId?: UuidFilter<"UserPainProfile"> | string
    painLevel?: IntNullableFilter<"UserPainProfile"> | number | null
    experienceLevel?: StringNullableFilter<"UserPainProfile"> | string | null
    equipmentAvailable?: StringNullableListFilter<"UserPainProfile">
    createdAt?: DateTimeFilter<"UserPainProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserPainProfile"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bodyPart?: XOR<BodyPartScalarRelationFilter, BodyPartWhereInput>
  }, "id">

  export type UserPainProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    bodyPartId?: SortOrder
    painLevel?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    equipmentAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPainProfileCountOrderByAggregateInput
    _avg?: UserPainProfileAvgOrderByAggregateInput
    _max?: UserPainProfileMaxOrderByAggregateInput
    _min?: UserPainProfileMinOrderByAggregateInput
    _sum?: UserPainProfileSumOrderByAggregateInput
  }

  export type UserPainProfileScalarWhereWithAggregatesInput = {
    AND?: UserPainProfileScalarWhereWithAggregatesInput | UserPainProfileScalarWhereWithAggregatesInput[]
    OR?: UserPainProfileScalarWhereWithAggregatesInput[]
    NOT?: UserPainProfileScalarWhereWithAggregatesInput | UserPainProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserPainProfile"> | string
    userId?: UuidNullableWithAggregatesFilter<"UserPainProfile"> | string | null
    bodyPartId?: UuidWithAggregatesFilter<"UserPainProfile"> | string
    painLevel?: IntNullableWithAggregatesFilter<"UserPainProfile"> | number | null
    experienceLevel?: StringNullableWithAggregatesFilter<"UserPainProfile"> | string | null
    equipmentAvailable?: StringNullableListFilter<"UserPainProfile">
    createdAt?: DateTimeWithAggregatesFilter<"UserPainProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPainProfile"> | Date | string
  }

  export type UserCourseHistoryWhereInput = {
    AND?: UserCourseHistoryWhereInput | UserCourseHistoryWhereInput[]
    OR?: UserCourseHistoryWhereInput[]
    NOT?: UserCourseHistoryWhereInput | UserCourseHistoryWhereInput[]
    id?: UuidFilter<"UserCourseHistory"> | string
    userId?: UuidNullableFilter<"UserCourseHistory"> | string | null
    courseId?: UuidFilter<"UserCourseHistory"> | string
    completedAt?: DateTimeNullableFilter<"UserCourseHistory"> | Date | string | null
    savedAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    isFavorite?: BoolFilter<"UserCourseHistory"> | boolean
    notes?: StringNullableFilter<"UserCourseHistory"> | string | null
    createdAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type UserCourseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    courseId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    savedAt?: SortOrder
    isFavorite?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type UserCourseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserCourseHistoryWhereInput | UserCourseHistoryWhereInput[]
    OR?: UserCourseHistoryWhereInput[]
    NOT?: UserCourseHistoryWhereInput | UserCourseHistoryWhereInput[]
    userId?: UuidNullableFilter<"UserCourseHistory"> | string | null
    courseId?: UuidFilter<"UserCourseHistory"> | string
    completedAt?: DateTimeNullableFilter<"UserCourseHistory"> | Date | string | null
    savedAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    isFavorite?: BoolFilter<"UserCourseHistory"> | boolean
    notes?: StringNullableFilter<"UserCourseHistory"> | string | null
    createdAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type UserCourseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    courseId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    savedAt?: SortOrder
    isFavorite?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCourseHistoryCountOrderByAggregateInput
    _max?: UserCourseHistoryMaxOrderByAggregateInput
    _min?: UserCourseHistoryMinOrderByAggregateInput
  }

  export type UserCourseHistoryScalarWhereWithAggregatesInput = {
    AND?: UserCourseHistoryScalarWhereWithAggregatesInput | UserCourseHistoryScalarWhereWithAggregatesInput[]
    OR?: UserCourseHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserCourseHistoryScalarWhereWithAggregatesInput | UserCourseHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserCourseHistory"> | string
    userId?: UuidNullableWithAggregatesFilter<"UserCourseHistory"> | string | null
    courseId?: UuidWithAggregatesFilter<"UserCourseHistory"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserCourseHistory"> | Date | string | null
    savedAt?: DateTimeWithAggregatesFilter<"UserCourseHistory"> | Date | string
    isFavorite?: BoolWithAggregatesFilter<"UserCourseHistory"> | boolean
    notes?: StringNullableWithAggregatesFilter<"UserCourseHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserCourseHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserCourseHistory"> | Date | string
  }

  export type UserFavoriteWhereInput = {
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    id?: UuidFilter<"UserFavorite"> | string
    userId?: UuidNullableFilter<"UserFavorite"> | string | null
    gymId?: UuidFilter<"UserFavorite"> | string
    savedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }

  export type UserFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    gymId?: SortOrder
    savedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    gym?: GymOrderByWithRelationInput
  }

  export type UserFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_gymId?: UserFavoriteUserIdGymIdCompoundUniqueInput
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: UuidNullableFilter<"UserFavorite"> | string | null
    gymId?: UuidFilter<"UserFavorite"> | string
    savedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    gym?: XOR<GymScalarRelationFilter, GymWhereInput>
  }, "id" | "userId_gymId">

  export type UserFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    gymId?: SortOrder
    savedAt?: SortOrder
    createdAt?: SortOrder
    _count?: UserFavoriteCountOrderByAggregateInput
    _max?: UserFavoriteMaxOrderByAggregateInput
    _min?: UserFavoriteMinOrderByAggregateInput
  }

  export type UserFavoriteScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserFavorite"> | string
    userId?: UuidNullableWithAggregatesFilter<"UserFavorite"> | string | null
    gymId?: UuidWithAggregatesFilter<"UserFavorite"> | string
    savedAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: UuidFilter<"Event"> | string
    userId?: UuidNullableFilter<"Event"> | string | null
    anonymousId?: StringNullableFilter<"Event"> | string | null
    eventName?: StringFilter<"Event"> | string
    eventData?: JsonNullableFilter<"Event">
    eventTime?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    eventData?: SortOrderInput | SortOrder
    eventTime?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    userId?: UuidNullableFilter<"Event"> | string | null
    anonymousId?: StringNullableFilter<"Event"> | string | null
    eventName?: StringFilter<"Event"> | string
    eventData?: JsonNullableFilter<"Event">
    eventTime?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    eventData?: SortOrderInput | SortOrder
    eventTime?: SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Event"> | string
    userId?: UuidNullableWithAggregatesFilter<"Event"> | string | null
    anonymousId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    eventName?: StringWithAggregatesFilter<"Event"> | string
    eventData?: JsonNullableWithAggregatesFilter<"Event">
    eventTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    name?: StringFilter<"Patient"> | string
    age?: IntFilter<"Patient"> | number
    gender?: StringFilter<"Patient"> | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    name?: StringFilter<"Patient"> | string
    age?: IntFilter<"Patient"> | number
    gender?: StringFilter<"Patient"> | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    name?: StringWithAggregatesFilter<"Patient"> | string
    age?: IntWithAggregatesFilter<"Patient"> | number
    gender?: StringWithAggregatesFilter<"Patient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCreateInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelCreateNestedManyWithoutGymInput
    reviews?: ReviewCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutGymInput
  }

  export type GymUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityUncheckedCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourUncheckedCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelUncheckedCreateNestedManyWithoutGymInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutGymInput
  }

  export type GymUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUpdateManyWithoutGymNestedInput
    reviews?: ReviewUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutGymNestedInput
  }

  export type GymUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUncheckedUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUncheckedUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUncheckedUpdateManyWithoutGymNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutGymNestedInput
  }

  export type GymCreateManyInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymFacilityCreateInput = {
    id?: string
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: GymFacilityCreateotherFacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutFacilitiesInput
  }

  export type GymFacilityUncheckedCreateInput = {
    id?: string
    gymId: string
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: GymFacilityCreateotherFacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymFacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isQuiet?: BoolFieldUpdateOperationsInput | boolean
    hasRehabEquipment?: BoolFieldUpdateOperationsInput | boolean
    hasPtCoach?: BoolFieldUpdateOperationsInput | boolean
    hasShower?: BoolFieldUpdateOperationsInput | boolean
    hasParking?: BoolFieldUpdateOperationsInput | boolean
    hasLocker?: BoolFieldUpdateOperationsInput | boolean
    hasWaterDispenser?: BoolFieldUpdateOperationsInput | boolean
    hasAirConditioning?: BoolFieldUpdateOperationsInput | boolean
    otherFacilities?: GymFacilityUpdateotherFacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutFacilitiesNestedInput
  }

  export type GymFacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    isQuiet?: BoolFieldUpdateOperationsInput | boolean
    hasRehabEquipment?: BoolFieldUpdateOperationsInput | boolean
    hasPtCoach?: BoolFieldUpdateOperationsInput | boolean
    hasShower?: BoolFieldUpdateOperationsInput | boolean
    hasParking?: BoolFieldUpdateOperationsInput | boolean
    hasLocker?: BoolFieldUpdateOperationsInput | boolean
    hasWaterDispenser?: BoolFieldUpdateOperationsInput | boolean
    hasAirConditioning?: BoolFieldUpdateOperationsInput | boolean
    otherFacilities?: GymFacilityUpdateotherFacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymFacilityCreateManyInput = {
    id?: string
    gymId: string
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: GymFacilityCreateotherFacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymFacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isQuiet?: BoolFieldUpdateOperationsInput | boolean
    hasRehabEquipment?: BoolFieldUpdateOperationsInput | boolean
    hasPtCoach?: BoolFieldUpdateOperationsInput | boolean
    hasShower?: BoolFieldUpdateOperationsInput | boolean
    hasParking?: BoolFieldUpdateOperationsInput | boolean
    hasLocker?: BoolFieldUpdateOperationsInput | boolean
    hasWaterDispenser?: BoolFieldUpdateOperationsInput | boolean
    hasAirConditioning?: BoolFieldUpdateOperationsInput | boolean
    otherFacilities?: GymFacilityUpdateotherFacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymFacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    isQuiet?: BoolFieldUpdateOperationsInput | boolean
    hasRehabEquipment?: BoolFieldUpdateOperationsInput | boolean
    hasPtCoach?: BoolFieldUpdateOperationsInput | boolean
    hasShower?: BoolFieldUpdateOperationsInput | boolean
    hasParking?: BoolFieldUpdateOperationsInput | boolean
    hasLocker?: BoolFieldUpdateOperationsInput | boolean
    hasWaterDispenser?: BoolFieldUpdateOperationsInput | boolean
    hasAirConditioning?: BoolFieldUpdateOperationsInput | boolean
    otherFacilities?: GymFacilityUpdateotherFacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourCreateInput = {
    id?: string
    dayOfWeek: number
    openTime?: string | null
    closeTime?: string | null
    isClosed?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutOperatingHoursInput
  }

  export type GymOperatingHourUncheckedCreateInput = {
    id?: string
    gymId: string
    dayOfWeek: number
    openTime?: string | null
    closeTime?: string | null
    isClosed?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymOperatingHourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutOperatingHoursNestedInput
  }

  export type GymOperatingHourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourCreateManyInput = {
    id?: string
    gymId: string
    dayOfWeek: number
    openTime?: string | null
    closeTime?: string | null
    isClosed?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymOperatingHourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCrowdLevelCreateInput = {
    id?: string
    timeSlot: string
    dayOfWeek?: number | null
    crowdLevel: string
    source?: string
    reportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutCrowdLevelsInput
  }

  export type GymCrowdLevelUncheckedCreateInput = {
    id?: string
    gymId: string
    timeSlot: string
    dayOfWeek?: number | null
    crowdLevel: string
    source?: string
    reportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymCrowdLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutCrowdLevelsNestedInput
  }

  export type GymCrowdLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCrowdLevelCreateManyInput = {
    id?: string
    gymId: string
    timeSlot: string
    dayOfWeek?: number | null
    crowdLevel: string
    source?: string
    reportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymCrowdLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCrowdLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagCreateInput = {
    id?: string
    name: string
    category?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    reviewTagMappings?: ReviewTagMappingCreateNestedManyWithoutReviewTagInput
  }

  export type ReviewTagUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedCreateNestedManyWithoutReviewTagInput
  }

  export type ReviewTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewTagMappings?: ReviewTagMappingUpdateManyWithoutReviewTagNestedInput
  }

  export type ReviewTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedUpdateManyWithoutReviewTagNestedInput
  }

  export type ReviewTagCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ReviewTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutReviewsInput
    user?: UserCreateNestedOneWithoutReviewsInput
    reviewTagMappings?: ReviewTagMappingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    gymId: string
    userId?: string | null
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneWithoutReviewsNestedInput
    reviewTagMappings?: ReviewTagMappingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    gymId: string
    userId?: string | null
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingCreateInput = {
    id?: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutReviewTagMappingsInput
    reviewTag: ReviewTagCreateNestedOneWithoutReviewTagMappingsInput
  }

  export type ReviewTagMappingUncheckedCreateInput = {
    id?: string
    reviewId: string
    reviewTagId: string
    createdAt?: Date | string
  }

  export type ReviewTagMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutReviewTagMappingsNestedInput
    reviewTag?: ReviewTagUpdateOneRequiredWithoutReviewTagMappingsNestedInput
  }

  export type ReviewTagMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    reviewTagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingCreateManyInput = {
    id?: string
    reviewId: string
    reviewTagId: string
    createdAt?: Date | string
  }

  export type ReviewTagMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    reviewTagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyPartCreateInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    exerciseTemplates?: ExerciseTemplateCreateNestedManyWithoutBodyPartInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutBodyPartInput
  }

  export type BodyPartUncheckedCreateInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    exerciseTemplates?: ExerciseTemplateUncheckedCreateNestedManyWithoutBodyPartInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutBodyPartInput
  }

  export type BodyPartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplates?: ExerciseTemplateUpdateManyWithoutBodyPartNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutBodyPartNestedInput
  }

  export type BodyPartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplates?: ExerciseTemplateUncheckedUpdateManyWithoutBodyPartNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutBodyPartNestedInput
  }

  export type BodyPartCreateManyInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BodyPartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyPartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentTypeCreateInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingCreateNestedManyWithoutEquipmentTypeInput
  }

  export type EquipmentTypeUncheckedCreateInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedCreateNestedManyWithoutEquipmentTypeInput
  }

  export type EquipmentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUpdateManyWithoutEquipmentTypeNestedInput
  }

  export type EquipmentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedUpdateManyWithoutEquipmentTypeNestedInput
  }

  export type EquipmentTypeCreateManyInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EquipmentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyPart: BodyPartCreateNestedOneWithoutExerciseTemplatesInput
    exerciseEquipmentMappings?: ExerciseEquipmentMappingCreateNestedManyWithoutExerciseTemplateInput
    courseExercises?: CourseExerciseCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    bodyPartId: string
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedCreateNestedManyWithoutExerciseTemplateInput
    courseExercises?: CourseExerciseUncheckedCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyPart?: BodyPartUpdateOneRequiredWithoutExerciseTemplatesNestedInput
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUpdateManyWithoutExerciseTemplateNestedInput
    courseExercises?: CourseExerciseUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type ExerciseTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartId?: StringFieldUpdateOperationsInput | string
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedUpdateManyWithoutExerciseTemplateNestedInput
    courseExercises?: CourseExerciseUncheckedUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type ExerciseTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    bodyPartId: string
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartId?: StringFieldUpdateOperationsInput | string
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingCreateInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    exerciseTemplate: ExerciseTemplateCreateNestedOneWithoutExerciseEquipmentMappingsInput
    equipmentType: EquipmentTypeCreateNestedOneWithoutExerciseEquipmentMappingsInput
  }

  export type ExerciseEquipmentMappingUncheckedCreateInput = {
    id?: string
    exerciseTemplateId: string
    equipmentTypeId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type ExerciseEquipmentMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplate?: ExerciseTemplateUpdateOneRequiredWithoutExerciseEquipmentMappingsNestedInput
    equipmentType?: EquipmentTypeUpdateOneRequiredWithoutExerciseEquipmentMappingsNestedInput
  }

  export type ExerciseEquipmentMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    equipmentTypeId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingCreateManyInput = {
    id?: string
    exerciseTemplateId: string
    equipmentTypeId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type ExerciseEquipmentMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    equipmentTypeId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCoursesInput
    courseExercises?: CourseExerciseCreateNestedManyWithoutCourseInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    userId?: string | null
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseExercises?: CourseExerciseUncheckedCreateNestedManyWithoutCourseInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCoursesNestedInput
    courseExercises?: CourseExerciseUpdateManyWithoutCourseNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseExercises?: CourseExerciseUncheckedUpdateManyWithoutCourseNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    userId?: string | null
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseCreateInput = {
    id?: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutCourseExercisesInput
    exerciseTemplate: ExerciseTemplateCreateNestedOneWithoutCourseExercisesInput
  }

  export type CourseExerciseUncheckedCreateInput = {
    id?: string
    courseId: string
    exerciseTemplateId: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CourseExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutCourseExercisesNestedInput
    exerciseTemplate?: ExerciseTemplateUpdateOneRequiredWithoutCourseExercisesNestedInput
  }

  export type CourseExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseCreateManyInput = {
    id?: string
    courseId: string
    exerciseTemplateId: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CourseExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileCreateInput = {
    id?: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserPainProfilesInput
    bodyPart: BodyPartCreateNestedOneWithoutUserPainProfilesInput
  }

  export type UserPainProfileUncheckedCreateInput = {
    id?: string
    userId?: string | null
    bodyPartId: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPainProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserPainProfilesNestedInput
    bodyPart?: BodyPartUpdateOneRequiredWithoutUserPainProfilesNestedInput
  }

  export type UserPainProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartId?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileCreateManyInput = {
    id?: string
    userId?: string | null
    bodyPartId: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPainProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartId?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryCreateInput = {
    id?: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserCourseHistoryInput
    course: CourseCreateNestedOneWithoutUserCourseHistoryInput
  }

  export type UserCourseHistoryUncheckedCreateInput = {
    id?: string
    userId?: string | null
    courseId: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserCourseHistoryNestedInput
    course?: CourseUpdateOneRequiredWithoutUserCourseHistoryNestedInput
  }

  export type UserCourseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryCreateManyInput = {
    id?: string
    userId?: string | null
    courseId: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateInput = {
    id?: string
    savedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUserFavoritesInput
    gym: GymCreateNestedOneWithoutUserFavoritesInput
  }

  export type UserFavoriteUncheckedCreateInput = {
    id?: string
    userId?: string | null
    gymId: string
    savedAt?: Date | string
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserFavoritesNestedInput
    gym?: GymUpdateOneRequiredWithoutUserFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    gymId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInput = {
    id?: string
    userId?: string | null
    gymId: string
    savedAt?: Date | string
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    gymId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    anonymousId?: string | null
    eventName: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    eventName: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: Date | string
    createdAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    eventName: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: Date | string
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    name: string
    age: number
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    name: string
    age: number
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateManyInput = {
    id?: number
    name: string
    age: number
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type UserPainProfileListRelationFilter = {
    every?: UserPainProfileWhereInput
    some?: UserPainProfileWhereInput
    none?: UserPainProfileWhereInput
  }

  export type UserCourseHistoryListRelationFilter = {
    every?: UserCourseHistoryWhereInput
    some?: UserCourseHistoryWhereInput
    none?: UserCourseHistoryWhereInput
  }

  export type UserFavoriteListRelationFilter = {
    every?: UserFavoriteWhereInput
    some?: UserFavoriteWhereInput
    none?: UserFavoriteWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPainProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCourseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type GymFacilityNullableScalarRelationFilter = {
    is?: GymFacilityWhereInput | null
    isNot?: GymFacilityWhereInput | null
  }

  export type GymOperatingHourListRelationFilter = {
    every?: GymOperatingHourWhereInput
    some?: GymOperatingHourWhereInput
    none?: GymOperatingHourWhereInput
  }

  export type GymCrowdLevelListRelationFilter = {
    every?: GymCrowdLevelWhereInput
    some?: GymCrowdLevelWhereInput
    none?: GymCrowdLevelWhereInput
  }

  export type GymOperatingHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GymCrowdLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GymCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    priceRange?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    facilityInfoCount?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    facilityInfoCount?: SortOrder
  }

  export type GymMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    priceRange?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    facilityInfoCount?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    priceRange?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    facilityInfoCount?: SortOrder
    lastUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    facilityInfoCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type GymScalarRelationFilter = {
    is?: GymWhereInput
    isNot?: GymWhereInput
  }

  export type GymFacilityCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    isQuiet?: SortOrder
    hasRehabEquipment?: SortOrder
    hasPtCoach?: SortOrder
    hasShower?: SortOrder
    hasParking?: SortOrder
    hasLocker?: SortOrder
    hasWaterDispenser?: SortOrder
    hasAirConditioning?: SortOrder
    otherFacilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymFacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    isQuiet?: SortOrder
    hasRehabEquipment?: SortOrder
    hasPtCoach?: SortOrder
    hasShower?: SortOrder
    hasParking?: SortOrder
    hasLocker?: SortOrder
    hasWaterDispenser?: SortOrder
    hasAirConditioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymFacilityMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    isQuiet?: SortOrder
    hasRehabEquipment?: SortOrder
    hasPtCoach?: SortOrder
    hasShower?: SortOrder
    hasParking?: SortOrder
    hasLocker?: SortOrder
    hasWaterDispenser?: SortOrder
    hasAirConditioning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymOperatingHourGymIdDayOfWeekCompoundUniqueInput = {
    gymId: string
    dayOfWeek: number
  }

  export type GymOperatingHourCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymOperatingHourAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type GymOperatingHourMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymOperatingHourMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymOperatingHourSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type GymCrowdLevelCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    timeSlot?: SortOrder
    dayOfWeek?: SortOrder
    crowdLevel?: SortOrder
    source?: SortOrder
    reportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymCrowdLevelAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type GymCrowdLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    timeSlot?: SortOrder
    dayOfWeek?: SortOrder
    crowdLevel?: SortOrder
    source?: SortOrder
    reportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymCrowdLevelMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    timeSlot?: SortOrder
    dayOfWeek?: SortOrder
    crowdLevel?: SortOrder
    source?: SortOrder
    reportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymCrowdLevelSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReviewTagMappingListRelationFilter = {
    every?: ReviewTagMappingWhereInput
    some?: ReviewTagMappingWhereInput
    none?: ReviewTagMappingWhereInput
  }

  export type ReviewTagMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewTagAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ReviewTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewTagSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    isAdminReview?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    isAdminReview?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    gymId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    isAdminReview?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewTagScalarRelationFilter = {
    is?: ReviewTagWhereInput
    isNot?: ReviewTagWhereInput
  }

  export type ReviewTagMappingReviewIdReviewTagIdCompoundUniqueInput = {
    reviewId: string
    reviewTagId: string
  }

  export type ReviewTagMappingCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    reviewTagId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewTagMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    reviewTagId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewTagMappingMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    reviewTagId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseTemplateListRelationFilter = {
    every?: ExerciseTemplateWhereInput
    some?: ExerciseTemplateWhereInput
    none?: ExerciseTemplateWhereInput
  }

  export type ExerciseTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BodyPartCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BodyPartAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type BodyPartMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BodyPartMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BodyPartSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ExerciseEquipmentMappingListRelationFilter = {
    every?: ExerciseEquipmentMappingWhereInput
    some?: ExerciseEquipmentMappingWhereInput
    none?: ExerciseEquipmentMappingWhereInput
  }

  export type ExerciseEquipmentMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentTypeAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type EquipmentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentTypeSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type BodyPartScalarRelationFilter = {
    is?: BodyPartWhereInput
    isNot?: BodyPartWhereInput
  }

  export type CourseExerciseListRelationFilter = {
    every?: CourseExerciseWhereInput
    some?: CourseExerciseWhereInput
    none?: CourseExerciseWhereInput
  }

  export type CourseExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    bodyPartId?: SortOrder
    intensityLevel?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    difficultyScore?: SortOrder
    contraindications?: SortOrder
    instructions?: SortOrder
    precautions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseTemplateAvgOrderByAggregateInput = {
    intensityLevel?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    difficultyScore?: SortOrder
  }

  export type ExerciseTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    bodyPartId?: SortOrder
    intensityLevel?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    difficultyScore?: SortOrder
    instructions?: SortOrder
    precautions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    bodyPartId?: SortOrder
    intensityLevel?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    difficultyScore?: SortOrder
    instructions?: SortOrder
    precautions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseTemplateSumOrderByAggregateInput = {
    intensityLevel?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    difficultyScore?: SortOrder
  }

  export type ExerciseTemplateScalarRelationFilter = {
    is?: ExerciseTemplateWhereInput
    isNot?: ExerciseTemplateWhereInput
  }

  export type EquipmentTypeScalarRelationFilter = {
    is?: EquipmentTypeWhereInput
    isNot?: EquipmentTypeWhereInput
  }

  export type ExerciseEquipmentMappingExerciseTemplateIdEquipmentTypeIdCompoundUniqueInput = {
    exerciseTemplateId: string
    equipmentTypeId: string
  }

  export type ExerciseEquipmentMappingCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseTemplateId?: SortOrder
    equipmentTypeId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseEquipmentMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseTemplateId?: SortOrder
    equipmentTypeId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseEquipmentMappingMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseTemplateId?: SortOrder
    equipmentTypeId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrder
    experienceLevel?: SortOrder
    bodyParts?: SortOrder
    equipmentAvailable?: SortOrder
    courseType?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrder
    experienceLevel?: SortOrder
    courseType?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrder
    experienceLevel?: SortOrder
    courseType?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    totalDurationMinutes?: SortOrder
    painLevel?: SortOrder
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    exerciseTemplateId?: SortOrder
    section?: SortOrder
    orderInSection?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseExerciseAvgOrderByAggregateInput = {
    orderInSection?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
  }

  export type CourseExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    exerciseTemplateId?: SortOrder
    section?: SortOrder
    orderInSection?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    exerciseTemplateId?: SortOrder
    section?: SortOrder
    orderInSection?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseExerciseSumOrderByAggregateInput = {
    orderInSection?: SortOrder
    durationMinutes?: SortOrder
    reps?: SortOrder
    sets?: SortOrder
    restSeconds?: SortOrder
  }

  export type UserPainProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bodyPartId?: SortOrder
    painLevel?: SortOrder
    experienceLevel?: SortOrder
    equipmentAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPainProfileAvgOrderByAggregateInput = {
    painLevel?: SortOrder
  }

  export type UserPainProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bodyPartId?: SortOrder
    painLevel?: SortOrder
    experienceLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPainProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bodyPartId?: SortOrder
    painLevel?: SortOrder
    experienceLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPainProfileSumOrderByAggregateInput = {
    painLevel?: SortOrder
  }

  export type UserCourseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedAt?: SortOrder
    savedAt?: SortOrder
    isFavorite?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedAt?: SortOrder
    savedAt?: SortOrder
    isFavorite?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedAt?: SortOrder
    savedAt?: SortOrder
    isFavorite?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFavoriteUserIdGymIdCompoundUniqueInput = {
    userId: string
    gymId: string
  }

  export type UserFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gymId?: SortOrder
    savedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gymId?: SortOrder
    savedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gymId?: SortOrder
    savedAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    eventName?: SortOrder
    eventData?: SortOrder
    eventTime?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    eventName?: SortOrder
    eventTime?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    eventName?: SortOrder
    eventTime?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserPainProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPainProfileCreateWithoutUserInput, UserPainProfileUncheckedCreateWithoutUserInput> | UserPainProfileCreateWithoutUserInput[] | UserPainProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutUserInput | UserPainProfileCreateOrConnectWithoutUserInput[]
    createMany?: UserPainProfileCreateManyUserInputEnvelope
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
  }

  export type UserCourseHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseHistoryCreateWithoutUserInput, UserCourseHistoryUncheckedCreateWithoutUserInput> | UserCourseHistoryCreateWithoutUserInput[] | UserCourseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutUserInput | UserCourseHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseHistoryCreateManyUserInputEnvelope
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserPainProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPainProfileCreateWithoutUserInput, UserPainProfileUncheckedCreateWithoutUserInput> | UserPainProfileCreateWithoutUserInput[] | UserPainProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutUserInput | UserPainProfileCreateOrConnectWithoutUserInput[]
    createMany?: UserPainProfileCreateManyUserInputEnvelope
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
  }

  export type UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseHistoryCreateWithoutUserInput, UserCourseHistoryUncheckedCreateWithoutUserInput> | UserCourseHistoryCreateWithoutUserInput[] | UserCourseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutUserInput | UserCourseHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseHistoryCreateManyUserInputEnvelope
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUserInput | CourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUserInput | CourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUserInput | CourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserPainProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPainProfileCreateWithoutUserInput, UserPainProfileUncheckedCreateWithoutUserInput> | UserPainProfileCreateWithoutUserInput[] | UserPainProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutUserInput | UserPainProfileCreateOrConnectWithoutUserInput[]
    upsert?: UserPainProfileUpsertWithWhereUniqueWithoutUserInput | UserPainProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPainProfileCreateManyUserInputEnvelope
    set?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    disconnect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    delete?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    update?: UserPainProfileUpdateWithWhereUniqueWithoutUserInput | UserPainProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPainProfileUpdateManyWithWhereWithoutUserInput | UserPainProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPainProfileScalarWhereInput | UserPainProfileScalarWhereInput[]
  }

  export type UserCourseHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseHistoryCreateWithoutUserInput, UserCourseHistoryUncheckedCreateWithoutUserInput> | UserCourseHistoryCreateWithoutUserInput[] | UserCourseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutUserInput | UserCourseHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseHistoryUpsertWithWhereUniqueWithoutUserInput | UserCourseHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseHistoryCreateManyUserInputEnvelope
    set?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    disconnect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    delete?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    update?: UserCourseHistoryUpdateWithWhereUniqueWithoutUserInput | UserCourseHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseHistoryUpdateManyWithWhereWithoutUserInput | UserCourseHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseHistoryScalarWhereInput | UserCourseHistoryScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type EventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUserInput | CourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUserInput | CourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUserInput | CourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserPainProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPainProfileCreateWithoutUserInput, UserPainProfileUncheckedCreateWithoutUserInput> | UserPainProfileCreateWithoutUserInput[] | UserPainProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutUserInput | UserPainProfileCreateOrConnectWithoutUserInput[]
    upsert?: UserPainProfileUpsertWithWhereUniqueWithoutUserInput | UserPainProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPainProfileCreateManyUserInputEnvelope
    set?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    disconnect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    delete?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    update?: UserPainProfileUpdateWithWhereUniqueWithoutUserInput | UserPainProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPainProfileUpdateManyWithWhereWithoutUserInput | UserPainProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPainProfileScalarWhereInput | UserPainProfileScalarWhereInput[]
  }

  export type UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseHistoryCreateWithoutUserInput, UserCourseHistoryUncheckedCreateWithoutUserInput> | UserCourseHistoryCreateWithoutUserInput[] | UserCourseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutUserInput | UserCourseHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseHistoryUpsertWithWhereUniqueWithoutUserInput | UserCourseHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseHistoryCreateManyUserInputEnvelope
    set?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    disconnect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    delete?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    update?: UserCourseHistoryUpdateWithWhereUniqueWithoutUserInput | UserCourseHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseHistoryUpdateManyWithWhereWithoutUserInput | UserCourseHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseHistoryScalarWhereInput | UserCourseHistoryScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type GymFacilityCreateNestedOneWithoutGymInput = {
    create?: XOR<GymFacilityCreateWithoutGymInput, GymFacilityUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymFacilityCreateOrConnectWithoutGymInput
    connect?: GymFacilityWhereUniqueInput
  }

  export type GymOperatingHourCreateNestedManyWithoutGymInput = {
    create?: XOR<GymOperatingHourCreateWithoutGymInput, GymOperatingHourUncheckedCreateWithoutGymInput> | GymOperatingHourCreateWithoutGymInput[] | GymOperatingHourUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymOperatingHourCreateOrConnectWithoutGymInput | GymOperatingHourCreateOrConnectWithoutGymInput[]
    createMany?: GymOperatingHourCreateManyGymInputEnvelope
    connect?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
  }

  export type GymCrowdLevelCreateNestedManyWithoutGymInput = {
    create?: XOR<GymCrowdLevelCreateWithoutGymInput, GymCrowdLevelUncheckedCreateWithoutGymInput> | GymCrowdLevelCreateWithoutGymInput[] | GymCrowdLevelUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymCrowdLevelCreateOrConnectWithoutGymInput | GymCrowdLevelCreateOrConnectWithoutGymInput[]
    createMany?: GymCrowdLevelCreateManyGymInputEnvelope
    connect?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutGymInput = {
    create?: XOR<ReviewCreateWithoutGymInput, ReviewUncheckedCreateWithoutGymInput> | ReviewCreateWithoutGymInput[] | ReviewUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGymInput | ReviewCreateOrConnectWithoutGymInput[]
    createMany?: ReviewCreateManyGymInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutGymInput = {
    create?: XOR<UserFavoriteCreateWithoutGymInput, UserFavoriteUncheckedCreateWithoutGymInput> | UserFavoriteCreateWithoutGymInput[] | UserFavoriteUncheckedCreateWithoutGymInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutGymInput | UserFavoriteCreateOrConnectWithoutGymInput[]
    createMany?: UserFavoriteCreateManyGymInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type GymFacilityUncheckedCreateNestedOneWithoutGymInput = {
    create?: XOR<GymFacilityCreateWithoutGymInput, GymFacilityUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymFacilityCreateOrConnectWithoutGymInput
    connect?: GymFacilityWhereUniqueInput
  }

  export type GymOperatingHourUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<GymOperatingHourCreateWithoutGymInput, GymOperatingHourUncheckedCreateWithoutGymInput> | GymOperatingHourCreateWithoutGymInput[] | GymOperatingHourUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymOperatingHourCreateOrConnectWithoutGymInput | GymOperatingHourCreateOrConnectWithoutGymInput[]
    createMany?: GymOperatingHourCreateManyGymInputEnvelope
    connect?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
  }

  export type GymCrowdLevelUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<GymCrowdLevelCreateWithoutGymInput, GymCrowdLevelUncheckedCreateWithoutGymInput> | GymCrowdLevelCreateWithoutGymInput[] | GymCrowdLevelUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymCrowdLevelCreateOrConnectWithoutGymInput | GymCrowdLevelCreateOrConnectWithoutGymInput[]
    createMany?: GymCrowdLevelCreateManyGymInputEnvelope
    connect?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<ReviewCreateWithoutGymInput, ReviewUncheckedCreateWithoutGymInput> | ReviewCreateWithoutGymInput[] | ReviewUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGymInput | ReviewCreateOrConnectWithoutGymInput[]
    createMany?: ReviewCreateManyGymInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutGymInput = {
    create?: XOR<UserFavoriteCreateWithoutGymInput, UserFavoriteUncheckedCreateWithoutGymInput> | UserFavoriteCreateWithoutGymInput[] | UserFavoriteUncheckedCreateWithoutGymInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutGymInput | UserFavoriteCreateOrConnectWithoutGymInput[]
    createMany?: UserFavoriteCreateManyGymInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type GymFacilityUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymFacilityCreateWithoutGymInput, GymFacilityUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymFacilityCreateOrConnectWithoutGymInput
    upsert?: GymFacilityUpsertWithoutGymInput
    disconnect?: GymFacilityWhereInput | boolean
    delete?: GymFacilityWhereInput | boolean
    connect?: GymFacilityWhereUniqueInput
    update?: XOR<XOR<GymFacilityUpdateToOneWithWhereWithoutGymInput, GymFacilityUpdateWithoutGymInput>, GymFacilityUncheckedUpdateWithoutGymInput>
  }

  export type GymOperatingHourUpdateManyWithoutGymNestedInput = {
    create?: XOR<GymOperatingHourCreateWithoutGymInput, GymOperatingHourUncheckedCreateWithoutGymInput> | GymOperatingHourCreateWithoutGymInput[] | GymOperatingHourUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymOperatingHourCreateOrConnectWithoutGymInput | GymOperatingHourCreateOrConnectWithoutGymInput[]
    upsert?: GymOperatingHourUpsertWithWhereUniqueWithoutGymInput | GymOperatingHourUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: GymOperatingHourCreateManyGymInputEnvelope
    set?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    disconnect?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    delete?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    connect?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    update?: GymOperatingHourUpdateWithWhereUniqueWithoutGymInput | GymOperatingHourUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: GymOperatingHourUpdateManyWithWhereWithoutGymInput | GymOperatingHourUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: GymOperatingHourScalarWhereInput | GymOperatingHourScalarWhereInput[]
  }

  export type GymCrowdLevelUpdateManyWithoutGymNestedInput = {
    create?: XOR<GymCrowdLevelCreateWithoutGymInput, GymCrowdLevelUncheckedCreateWithoutGymInput> | GymCrowdLevelCreateWithoutGymInput[] | GymCrowdLevelUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymCrowdLevelCreateOrConnectWithoutGymInput | GymCrowdLevelCreateOrConnectWithoutGymInput[]
    upsert?: GymCrowdLevelUpsertWithWhereUniqueWithoutGymInput | GymCrowdLevelUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: GymCrowdLevelCreateManyGymInputEnvelope
    set?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    disconnect?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    delete?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    connect?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    update?: GymCrowdLevelUpdateWithWhereUniqueWithoutGymInput | GymCrowdLevelUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: GymCrowdLevelUpdateManyWithWhereWithoutGymInput | GymCrowdLevelUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: GymCrowdLevelScalarWhereInput | GymCrowdLevelScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutGymNestedInput = {
    create?: XOR<ReviewCreateWithoutGymInput, ReviewUncheckedCreateWithoutGymInput> | ReviewCreateWithoutGymInput[] | ReviewUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGymInput | ReviewCreateOrConnectWithoutGymInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutGymInput | ReviewUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: ReviewCreateManyGymInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutGymInput | ReviewUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutGymInput | ReviewUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutGymNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutGymInput, UserFavoriteUncheckedCreateWithoutGymInput> | UserFavoriteCreateWithoutGymInput[] | UserFavoriteUncheckedCreateWithoutGymInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutGymInput | UserFavoriteCreateOrConnectWithoutGymInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutGymInput | UserFavoriteUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: UserFavoriteCreateManyGymInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutGymInput | UserFavoriteUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutGymInput | UserFavoriteUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type GymFacilityUncheckedUpdateOneWithoutGymNestedInput = {
    create?: XOR<GymFacilityCreateWithoutGymInput, GymFacilityUncheckedCreateWithoutGymInput>
    connectOrCreate?: GymFacilityCreateOrConnectWithoutGymInput
    upsert?: GymFacilityUpsertWithoutGymInput
    disconnect?: GymFacilityWhereInput | boolean
    delete?: GymFacilityWhereInput | boolean
    connect?: GymFacilityWhereUniqueInput
    update?: XOR<XOR<GymFacilityUpdateToOneWithWhereWithoutGymInput, GymFacilityUpdateWithoutGymInput>, GymFacilityUncheckedUpdateWithoutGymInput>
  }

  export type GymOperatingHourUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<GymOperatingHourCreateWithoutGymInput, GymOperatingHourUncheckedCreateWithoutGymInput> | GymOperatingHourCreateWithoutGymInput[] | GymOperatingHourUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymOperatingHourCreateOrConnectWithoutGymInput | GymOperatingHourCreateOrConnectWithoutGymInput[]
    upsert?: GymOperatingHourUpsertWithWhereUniqueWithoutGymInput | GymOperatingHourUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: GymOperatingHourCreateManyGymInputEnvelope
    set?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    disconnect?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    delete?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    connect?: GymOperatingHourWhereUniqueInput | GymOperatingHourWhereUniqueInput[]
    update?: GymOperatingHourUpdateWithWhereUniqueWithoutGymInput | GymOperatingHourUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: GymOperatingHourUpdateManyWithWhereWithoutGymInput | GymOperatingHourUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: GymOperatingHourScalarWhereInput | GymOperatingHourScalarWhereInput[]
  }

  export type GymCrowdLevelUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<GymCrowdLevelCreateWithoutGymInput, GymCrowdLevelUncheckedCreateWithoutGymInput> | GymCrowdLevelCreateWithoutGymInput[] | GymCrowdLevelUncheckedCreateWithoutGymInput[]
    connectOrCreate?: GymCrowdLevelCreateOrConnectWithoutGymInput | GymCrowdLevelCreateOrConnectWithoutGymInput[]
    upsert?: GymCrowdLevelUpsertWithWhereUniqueWithoutGymInput | GymCrowdLevelUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: GymCrowdLevelCreateManyGymInputEnvelope
    set?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    disconnect?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    delete?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    connect?: GymCrowdLevelWhereUniqueInput | GymCrowdLevelWhereUniqueInput[]
    update?: GymCrowdLevelUpdateWithWhereUniqueWithoutGymInput | GymCrowdLevelUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: GymCrowdLevelUpdateManyWithWhereWithoutGymInput | GymCrowdLevelUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: GymCrowdLevelScalarWhereInput | GymCrowdLevelScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<ReviewCreateWithoutGymInput, ReviewUncheckedCreateWithoutGymInput> | ReviewCreateWithoutGymInput[] | ReviewUncheckedCreateWithoutGymInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGymInput | ReviewCreateOrConnectWithoutGymInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutGymInput | ReviewUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: ReviewCreateManyGymInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutGymInput | ReviewUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutGymInput | ReviewUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutGymNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutGymInput, UserFavoriteUncheckedCreateWithoutGymInput> | UserFavoriteCreateWithoutGymInput[] | UserFavoriteUncheckedCreateWithoutGymInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutGymInput | UserFavoriteCreateOrConnectWithoutGymInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutGymInput | UserFavoriteUpsertWithWhereUniqueWithoutGymInput[]
    createMany?: UserFavoriteCreateManyGymInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutGymInput | UserFavoriteUpdateWithWhereUniqueWithoutGymInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutGymInput | UserFavoriteUpdateManyWithWhereWithoutGymInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type GymFacilityCreateotherFacilitiesInput = {
    set: string[]
  }

  export type GymCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<GymCreateWithoutFacilitiesInput, GymUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: GymCreateOrConnectWithoutFacilitiesInput
    connect?: GymWhereUniqueInput
  }

  export type GymFacilityUpdateotherFacilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GymUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<GymCreateWithoutFacilitiesInput, GymUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: GymCreateOrConnectWithoutFacilitiesInput
    upsert?: GymUpsertWithoutFacilitiesInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutFacilitiesInput, GymUpdateWithoutFacilitiesInput>, GymUncheckedUpdateWithoutFacilitiesInput>
  }

  export type GymCreateNestedOneWithoutOperatingHoursInput = {
    create?: XOR<GymCreateWithoutOperatingHoursInput, GymUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: GymCreateOrConnectWithoutOperatingHoursInput
    connect?: GymWhereUniqueInput
  }

  export type GymUpdateOneRequiredWithoutOperatingHoursNestedInput = {
    create?: XOR<GymCreateWithoutOperatingHoursInput, GymUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: GymCreateOrConnectWithoutOperatingHoursInput
    upsert?: GymUpsertWithoutOperatingHoursInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutOperatingHoursInput, GymUpdateWithoutOperatingHoursInput>, GymUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type GymCreateNestedOneWithoutCrowdLevelsInput = {
    create?: XOR<GymCreateWithoutCrowdLevelsInput, GymUncheckedCreateWithoutCrowdLevelsInput>
    connectOrCreate?: GymCreateOrConnectWithoutCrowdLevelsInput
    connect?: GymWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GymUpdateOneRequiredWithoutCrowdLevelsNestedInput = {
    create?: XOR<GymCreateWithoutCrowdLevelsInput, GymUncheckedCreateWithoutCrowdLevelsInput>
    connectOrCreate?: GymCreateOrConnectWithoutCrowdLevelsInput
    upsert?: GymUpsertWithoutCrowdLevelsInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutCrowdLevelsInput, GymUpdateWithoutCrowdLevelsInput>, GymUncheckedUpdateWithoutCrowdLevelsInput>
  }

  export type ReviewTagMappingCreateNestedManyWithoutReviewTagInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewTagInput, ReviewTagMappingUncheckedCreateWithoutReviewTagInput> | ReviewTagMappingCreateWithoutReviewTagInput[] | ReviewTagMappingUncheckedCreateWithoutReviewTagInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewTagInput | ReviewTagMappingCreateOrConnectWithoutReviewTagInput[]
    createMany?: ReviewTagMappingCreateManyReviewTagInputEnvelope
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
  }

  export type ReviewTagMappingUncheckedCreateNestedManyWithoutReviewTagInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewTagInput, ReviewTagMappingUncheckedCreateWithoutReviewTagInput> | ReviewTagMappingCreateWithoutReviewTagInput[] | ReviewTagMappingUncheckedCreateWithoutReviewTagInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewTagInput | ReviewTagMappingCreateOrConnectWithoutReviewTagInput[]
    createMany?: ReviewTagMappingCreateManyReviewTagInputEnvelope
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
  }

  export type ReviewTagMappingUpdateManyWithoutReviewTagNestedInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewTagInput, ReviewTagMappingUncheckedCreateWithoutReviewTagInput> | ReviewTagMappingCreateWithoutReviewTagInput[] | ReviewTagMappingUncheckedCreateWithoutReviewTagInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewTagInput | ReviewTagMappingCreateOrConnectWithoutReviewTagInput[]
    upsert?: ReviewTagMappingUpsertWithWhereUniqueWithoutReviewTagInput | ReviewTagMappingUpsertWithWhereUniqueWithoutReviewTagInput[]
    createMany?: ReviewTagMappingCreateManyReviewTagInputEnvelope
    set?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    disconnect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    delete?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    update?: ReviewTagMappingUpdateWithWhereUniqueWithoutReviewTagInput | ReviewTagMappingUpdateWithWhereUniqueWithoutReviewTagInput[]
    updateMany?: ReviewTagMappingUpdateManyWithWhereWithoutReviewTagInput | ReviewTagMappingUpdateManyWithWhereWithoutReviewTagInput[]
    deleteMany?: ReviewTagMappingScalarWhereInput | ReviewTagMappingScalarWhereInput[]
  }

  export type ReviewTagMappingUncheckedUpdateManyWithoutReviewTagNestedInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewTagInput, ReviewTagMappingUncheckedCreateWithoutReviewTagInput> | ReviewTagMappingCreateWithoutReviewTagInput[] | ReviewTagMappingUncheckedCreateWithoutReviewTagInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewTagInput | ReviewTagMappingCreateOrConnectWithoutReviewTagInput[]
    upsert?: ReviewTagMappingUpsertWithWhereUniqueWithoutReviewTagInput | ReviewTagMappingUpsertWithWhereUniqueWithoutReviewTagInput[]
    createMany?: ReviewTagMappingCreateManyReviewTagInputEnvelope
    set?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    disconnect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    delete?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    update?: ReviewTagMappingUpdateWithWhereUniqueWithoutReviewTagInput | ReviewTagMappingUpdateWithWhereUniqueWithoutReviewTagInput[]
    updateMany?: ReviewTagMappingUpdateManyWithWhereWithoutReviewTagInput | ReviewTagMappingUpdateManyWithWhereWithoutReviewTagInput[]
    deleteMany?: ReviewTagMappingScalarWhereInput | ReviewTagMappingScalarWhereInput[]
  }

  export type GymCreateNestedOneWithoutReviewsInput = {
    create?: XOR<GymCreateWithoutReviewsInput, GymUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: GymCreateOrConnectWithoutReviewsInput
    connect?: GymWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewTagMappingCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewInput, ReviewTagMappingUncheckedCreateWithoutReviewInput> | ReviewTagMappingCreateWithoutReviewInput[] | ReviewTagMappingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewInput | ReviewTagMappingCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewTagMappingCreateManyReviewInputEnvelope
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
  }

  export type ReviewTagMappingUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewInput, ReviewTagMappingUncheckedCreateWithoutReviewInput> | ReviewTagMappingCreateWithoutReviewInput[] | ReviewTagMappingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewInput | ReviewTagMappingCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewTagMappingCreateManyReviewInputEnvelope
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
  }

  export type GymUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<GymCreateWithoutReviewsInput, GymUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: GymCreateOrConnectWithoutReviewsInput
    upsert?: GymUpsertWithoutReviewsInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutReviewsInput, GymUpdateWithoutReviewsInput>, GymUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ReviewTagMappingUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewInput, ReviewTagMappingUncheckedCreateWithoutReviewInput> | ReviewTagMappingCreateWithoutReviewInput[] | ReviewTagMappingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewInput | ReviewTagMappingCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewTagMappingUpsertWithWhereUniqueWithoutReviewInput | ReviewTagMappingUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewTagMappingCreateManyReviewInputEnvelope
    set?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    disconnect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    delete?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    update?: ReviewTagMappingUpdateWithWhereUniqueWithoutReviewInput | ReviewTagMappingUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewTagMappingUpdateManyWithWhereWithoutReviewInput | ReviewTagMappingUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewTagMappingScalarWhereInput | ReviewTagMappingScalarWhereInput[]
  }

  export type ReviewTagMappingUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewTagMappingCreateWithoutReviewInput, ReviewTagMappingUncheckedCreateWithoutReviewInput> | ReviewTagMappingCreateWithoutReviewInput[] | ReviewTagMappingUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTagMappingCreateOrConnectWithoutReviewInput | ReviewTagMappingCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewTagMappingUpsertWithWhereUniqueWithoutReviewInput | ReviewTagMappingUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewTagMappingCreateManyReviewInputEnvelope
    set?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    disconnect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    delete?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    connect?: ReviewTagMappingWhereUniqueInput | ReviewTagMappingWhereUniqueInput[]
    update?: ReviewTagMappingUpdateWithWhereUniqueWithoutReviewInput | ReviewTagMappingUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewTagMappingUpdateManyWithWhereWithoutReviewInput | ReviewTagMappingUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewTagMappingScalarWhereInput | ReviewTagMappingScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutReviewTagMappingsInput = {
    create?: XOR<ReviewCreateWithoutReviewTagMappingsInput, ReviewUncheckedCreateWithoutReviewTagMappingsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewTagMappingsInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReviewTagCreateNestedOneWithoutReviewTagMappingsInput = {
    create?: XOR<ReviewTagCreateWithoutReviewTagMappingsInput, ReviewTagUncheckedCreateWithoutReviewTagMappingsInput>
    connectOrCreate?: ReviewTagCreateOrConnectWithoutReviewTagMappingsInput
    connect?: ReviewTagWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutReviewTagMappingsNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewTagMappingsInput, ReviewUncheckedCreateWithoutReviewTagMappingsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewTagMappingsInput
    upsert?: ReviewUpsertWithoutReviewTagMappingsInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutReviewTagMappingsInput, ReviewUpdateWithoutReviewTagMappingsInput>, ReviewUncheckedUpdateWithoutReviewTagMappingsInput>
  }

  export type ReviewTagUpdateOneRequiredWithoutReviewTagMappingsNestedInput = {
    create?: XOR<ReviewTagCreateWithoutReviewTagMappingsInput, ReviewTagUncheckedCreateWithoutReviewTagMappingsInput>
    connectOrCreate?: ReviewTagCreateOrConnectWithoutReviewTagMappingsInput
    upsert?: ReviewTagUpsertWithoutReviewTagMappingsInput
    connect?: ReviewTagWhereUniqueInput
    update?: XOR<XOR<ReviewTagUpdateToOneWithWhereWithoutReviewTagMappingsInput, ReviewTagUpdateWithoutReviewTagMappingsInput>, ReviewTagUncheckedUpdateWithoutReviewTagMappingsInput>
  }

  export type ExerciseTemplateCreateNestedManyWithoutBodyPartInput = {
    create?: XOR<ExerciseTemplateCreateWithoutBodyPartInput, ExerciseTemplateUncheckedCreateWithoutBodyPartInput> | ExerciseTemplateCreateWithoutBodyPartInput[] | ExerciseTemplateUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutBodyPartInput | ExerciseTemplateCreateOrConnectWithoutBodyPartInput[]
    createMany?: ExerciseTemplateCreateManyBodyPartInputEnvelope
    connect?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
  }

  export type UserPainProfileCreateNestedManyWithoutBodyPartInput = {
    create?: XOR<UserPainProfileCreateWithoutBodyPartInput, UserPainProfileUncheckedCreateWithoutBodyPartInput> | UserPainProfileCreateWithoutBodyPartInput[] | UserPainProfileUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutBodyPartInput | UserPainProfileCreateOrConnectWithoutBodyPartInput[]
    createMany?: UserPainProfileCreateManyBodyPartInputEnvelope
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
  }

  export type ExerciseTemplateUncheckedCreateNestedManyWithoutBodyPartInput = {
    create?: XOR<ExerciseTemplateCreateWithoutBodyPartInput, ExerciseTemplateUncheckedCreateWithoutBodyPartInput> | ExerciseTemplateCreateWithoutBodyPartInput[] | ExerciseTemplateUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutBodyPartInput | ExerciseTemplateCreateOrConnectWithoutBodyPartInput[]
    createMany?: ExerciseTemplateCreateManyBodyPartInputEnvelope
    connect?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
  }

  export type UserPainProfileUncheckedCreateNestedManyWithoutBodyPartInput = {
    create?: XOR<UserPainProfileCreateWithoutBodyPartInput, UserPainProfileUncheckedCreateWithoutBodyPartInput> | UserPainProfileCreateWithoutBodyPartInput[] | UserPainProfileUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutBodyPartInput | UserPainProfileCreateOrConnectWithoutBodyPartInput[]
    createMany?: UserPainProfileCreateManyBodyPartInputEnvelope
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
  }

  export type ExerciseTemplateUpdateManyWithoutBodyPartNestedInput = {
    create?: XOR<ExerciseTemplateCreateWithoutBodyPartInput, ExerciseTemplateUncheckedCreateWithoutBodyPartInput> | ExerciseTemplateCreateWithoutBodyPartInput[] | ExerciseTemplateUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutBodyPartInput | ExerciseTemplateCreateOrConnectWithoutBodyPartInput[]
    upsert?: ExerciseTemplateUpsertWithWhereUniqueWithoutBodyPartInput | ExerciseTemplateUpsertWithWhereUniqueWithoutBodyPartInput[]
    createMany?: ExerciseTemplateCreateManyBodyPartInputEnvelope
    set?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    disconnect?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    delete?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    connect?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    update?: ExerciseTemplateUpdateWithWhereUniqueWithoutBodyPartInput | ExerciseTemplateUpdateWithWhereUniqueWithoutBodyPartInput[]
    updateMany?: ExerciseTemplateUpdateManyWithWhereWithoutBodyPartInput | ExerciseTemplateUpdateManyWithWhereWithoutBodyPartInput[]
    deleteMany?: ExerciseTemplateScalarWhereInput | ExerciseTemplateScalarWhereInput[]
  }

  export type UserPainProfileUpdateManyWithoutBodyPartNestedInput = {
    create?: XOR<UserPainProfileCreateWithoutBodyPartInput, UserPainProfileUncheckedCreateWithoutBodyPartInput> | UserPainProfileCreateWithoutBodyPartInput[] | UserPainProfileUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutBodyPartInput | UserPainProfileCreateOrConnectWithoutBodyPartInput[]
    upsert?: UserPainProfileUpsertWithWhereUniqueWithoutBodyPartInput | UserPainProfileUpsertWithWhereUniqueWithoutBodyPartInput[]
    createMany?: UserPainProfileCreateManyBodyPartInputEnvelope
    set?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    disconnect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    delete?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    update?: UserPainProfileUpdateWithWhereUniqueWithoutBodyPartInput | UserPainProfileUpdateWithWhereUniqueWithoutBodyPartInput[]
    updateMany?: UserPainProfileUpdateManyWithWhereWithoutBodyPartInput | UserPainProfileUpdateManyWithWhereWithoutBodyPartInput[]
    deleteMany?: UserPainProfileScalarWhereInput | UserPainProfileScalarWhereInput[]
  }

  export type ExerciseTemplateUncheckedUpdateManyWithoutBodyPartNestedInput = {
    create?: XOR<ExerciseTemplateCreateWithoutBodyPartInput, ExerciseTemplateUncheckedCreateWithoutBodyPartInput> | ExerciseTemplateCreateWithoutBodyPartInput[] | ExerciseTemplateUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutBodyPartInput | ExerciseTemplateCreateOrConnectWithoutBodyPartInput[]
    upsert?: ExerciseTemplateUpsertWithWhereUniqueWithoutBodyPartInput | ExerciseTemplateUpsertWithWhereUniqueWithoutBodyPartInput[]
    createMany?: ExerciseTemplateCreateManyBodyPartInputEnvelope
    set?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    disconnect?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    delete?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    connect?: ExerciseTemplateWhereUniqueInput | ExerciseTemplateWhereUniqueInput[]
    update?: ExerciseTemplateUpdateWithWhereUniqueWithoutBodyPartInput | ExerciseTemplateUpdateWithWhereUniqueWithoutBodyPartInput[]
    updateMany?: ExerciseTemplateUpdateManyWithWhereWithoutBodyPartInput | ExerciseTemplateUpdateManyWithWhereWithoutBodyPartInput[]
    deleteMany?: ExerciseTemplateScalarWhereInput | ExerciseTemplateScalarWhereInput[]
  }

  export type UserPainProfileUncheckedUpdateManyWithoutBodyPartNestedInput = {
    create?: XOR<UserPainProfileCreateWithoutBodyPartInput, UserPainProfileUncheckedCreateWithoutBodyPartInput> | UserPainProfileCreateWithoutBodyPartInput[] | UserPainProfileUncheckedCreateWithoutBodyPartInput[]
    connectOrCreate?: UserPainProfileCreateOrConnectWithoutBodyPartInput | UserPainProfileCreateOrConnectWithoutBodyPartInput[]
    upsert?: UserPainProfileUpsertWithWhereUniqueWithoutBodyPartInput | UserPainProfileUpsertWithWhereUniqueWithoutBodyPartInput[]
    createMany?: UserPainProfileCreateManyBodyPartInputEnvelope
    set?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    disconnect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    delete?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    connect?: UserPainProfileWhereUniqueInput | UserPainProfileWhereUniqueInput[]
    update?: UserPainProfileUpdateWithWhereUniqueWithoutBodyPartInput | UserPainProfileUpdateWithWhereUniqueWithoutBodyPartInput[]
    updateMany?: UserPainProfileUpdateManyWithWhereWithoutBodyPartInput | UserPainProfileUpdateManyWithWhereWithoutBodyPartInput[]
    deleteMany?: UserPainProfileScalarWhereInput | UserPainProfileScalarWhereInput[]
  }

  export type ExerciseEquipmentMappingCreateNestedManyWithoutEquipmentTypeInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput> | ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput | ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput[]
    createMany?: ExerciseEquipmentMappingCreateManyEquipmentTypeInputEnvelope
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
  }

  export type ExerciseEquipmentMappingUncheckedCreateNestedManyWithoutEquipmentTypeInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput> | ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput | ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput[]
    createMany?: ExerciseEquipmentMappingCreateManyEquipmentTypeInputEnvelope
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
  }

  export type ExerciseEquipmentMappingUpdateManyWithoutEquipmentTypeNestedInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput> | ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput | ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput[]
    upsert?: ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutEquipmentTypeInput | ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutEquipmentTypeInput[]
    createMany?: ExerciseEquipmentMappingCreateManyEquipmentTypeInputEnvelope
    set?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    disconnect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    delete?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    update?: ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutEquipmentTypeInput | ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutEquipmentTypeInput[]
    updateMany?: ExerciseEquipmentMappingUpdateManyWithWhereWithoutEquipmentTypeInput | ExerciseEquipmentMappingUpdateManyWithWhereWithoutEquipmentTypeInput[]
    deleteMany?: ExerciseEquipmentMappingScalarWhereInput | ExerciseEquipmentMappingScalarWhereInput[]
  }

  export type ExerciseEquipmentMappingUncheckedUpdateManyWithoutEquipmentTypeNestedInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput> | ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput | ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput[]
    upsert?: ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutEquipmentTypeInput | ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutEquipmentTypeInput[]
    createMany?: ExerciseEquipmentMappingCreateManyEquipmentTypeInputEnvelope
    set?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    disconnect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    delete?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    update?: ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutEquipmentTypeInput | ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutEquipmentTypeInput[]
    updateMany?: ExerciseEquipmentMappingUpdateManyWithWhereWithoutEquipmentTypeInput | ExerciseEquipmentMappingUpdateManyWithWhereWithoutEquipmentTypeInput[]
    deleteMany?: ExerciseEquipmentMappingScalarWhereInput | ExerciseEquipmentMappingScalarWhereInput[]
  }

  export type ExerciseTemplateCreatecontraindicationsInput = {
    set: string[]
  }

  export type BodyPartCreateNestedOneWithoutExerciseTemplatesInput = {
    create?: XOR<BodyPartCreateWithoutExerciseTemplatesInput, BodyPartUncheckedCreateWithoutExerciseTemplatesInput>
    connectOrCreate?: BodyPartCreateOrConnectWithoutExerciseTemplatesInput
    connect?: BodyPartWhereUniqueInput
  }

  export type ExerciseEquipmentMappingCreateNestedManyWithoutExerciseTemplateInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput> | ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput | ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput[]
    createMany?: ExerciseEquipmentMappingCreateManyExerciseTemplateInputEnvelope
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
  }

  export type CourseExerciseCreateNestedManyWithoutExerciseTemplateInput = {
    create?: XOR<CourseExerciseCreateWithoutExerciseTemplateInput, CourseExerciseUncheckedCreateWithoutExerciseTemplateInput> | CourseExerciseCreateWithoutExerciseTemplateInput[] | CourseExerciseUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutExerciseTemplateInput | CourseExerciseCreateOrConnectWithoutExerciseTemplateInput[]
    createMany?: CourseExerciseCreateManyExerciseTemplateInputEnvelope
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
  }

  export type ExerciseEquipmentMappingUncheckedCreateNestedManyWithoutExerciseTemplateInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput> | ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput | ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput[]
    createMany?: ExerciseEquipmentMappingCreateManyExerciseTemplateInputEnvelope
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
  }

  export type CourseExerciseUncheckedCreateNestedManyWithoutExerciseTemplateInput = {
    create?: XOR<CourseExerciseCreateWithoutExerciseTemplateInput, CourseExerciseUncheckedCreateWithoutExerciseTemplateInput> | CourseExerciseCreateWithoutExerciseTemplateInput[] | CourseExerciseUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutExerciseTemplateInput | CourseExerciseCreateOrConnectWithoutExerciseTemplateInput[]
    createMany?: CourseExerciseCreateManyExerciseTemplateInputEnvelope
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
  }

  export type ExerciseTemplateUpdatecontraindicationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BodyPartUpdateOneRequiredWithoutExerciseTemplatesNestedInput = {
    create?: XOR<BodyPartCreateWithoutExerciseTemplatesInput, BodyPartUncheckedCreateWithoutExerciseTemplatesInput>
    connectOrCreate?: BodyPartCreateOrConnectWithoutExerciseTemplatesInput
    upsert?: BodyPartUpsertWithoutExerciseTemplatesInput
    connect?: BodyPartWhereUniqueInput
    update?: XOR<XOR<BodyPartUpdateToOneWithWhereWithoutExerciseTemplatesInput, BodyPartUpdateWithoutExerciseTemplatesInput>, BodyPartUncheckedUpdateWithoutExerciseTemplatesInput>
  }

  export type ExerciseEquipmentMappingUpdateManyWithoutExerciseTemplateNestedInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput> | ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput | ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput[]
    upsert?: ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutExerciseTemplateInput | ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutExerciseTemplateInput[]
    createMany?: ExerciseEquipmentMappingCreateManyExerciseTemplateInputEnvelope
    set?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    disconnect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    delete?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    update?: ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutExerciseTemplateInput | ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutExerciseTemplateInput[]
    updateMany?: ExerciseEquipmentMappingUpdateManyWithWhereWithoutExerciseTemplateInput | ExerciseEquipmentMappingUpdateManyWithWhereWithoutExerciseTemplateInput[]
    deleteMany?: ExerciseEquipmentMappingScalarWhereInput | ExerciseEquipmentMappingScalarWhereInput[]
  }

  export type CourseExerciseUpdateManyWithoutExerciseTemplateNestedInput = {
    create?: XOR<CourseExerciseCreateWithoutExerciseTemplateInput, CourseExerciseUncheckedCreateWithoutExerciseTemplateInput> | CourseExerciseCreateWithoutExerciseTemplateInput[] | CourseExerciseUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutExerciseTemplateInput | CourseExerciseCreateOrConnectWithoutExerciseTemplateInput[]
    upsert?: CourseExerciseUpsertWithWhereUniqueWithoutExerciseTemplateInput | CourseExerciseUpsertWithWhereUniqueWithoutExerciseTemplateInput[]
    createMany?: CourseExerciseCreateManyExerciseTemplateInputEnvelope
    set?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    disconnect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    delete?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    update?: CourseExerciseUpdateWithWhereUniqueWithoutExerciseTemplateInput | CourseExerciseUpdateWithWhereUniqueWithoutExerciseTemplateInput[]
    updateMany?: CourseExerciseUpdateManyWithWhereWithoutExerciseTemplateInput | CourseExerciseUpdateManyWithWhereWithoutExerciseTemplateInput[]
    deleteMany?: CourseExerciseScalarWhereInput | CourseExerciseScalarWhereInput[]
  }

  export type ExerciseEquipmentMappingUncheckedUpdateManyWithoutExerciseTemplateNestedInput = {
    create?: XOR<ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput> | ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput[] | ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput | ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput[]
    upsert?: ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutExerciseTemplateInput | ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutExerciseTemplateInput[]
    createMany?: ExerciseEquipmentMappingCreateManyExerciseTemplateInputEnvelope
    set?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    disconnect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    delete?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    connect?: ExerciseEquipmentMappingWhereUniqueInput | ExerciseEquipmentMappingWhereUniqueInput[]
    update?: ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutExerciseTemplateInput | ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutExerciseTemplateInput[]
    updateMany?: ExerciseEquipmentMappingUpdateManyWithWhereWithoutExerciseTemplateInput | ExerciseEquipmentMappingUpdateManyWithWhereWithoutExerciseTemplateInput[]
    deleteMany?: ExerciseEquipmentMappingScalarWhereInput | ExerciseEquipmentMappingScalarWhereInput[]
  }

  export type CourseExerciseUncheckedUpdateManyWithoutExerciseTemplateNestedInput = {
    create?: XOR<CourseExerciseCreateWithoutExerciseTemplateInput, CourseExerciseUncheckedCreateWithoutExerciseTemplateInput> | CourseExerciseCreateWithoutExerciseTemplateInput[] | CourseExerciseUncheckedCreateWithoutExerciseTemplateInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutExerciseTemplateInput | CourseExerciseCreateOrConnectWithoutExerciseTemplateInput[]
    upsert?: CourseExerciseUpsertWithWhereUniqueWithoutExerciseTemplateInput | CourseExerciseUpsertWithWhereUniqueWithoutExerciseTemplateInput[]
    createMany?: CourseExerciseCreateManyExerciseTemplateInputEnvelope
    set?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    disconnect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    delete?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    update?: CourseExerciseUpdateWithWhereUniqueWithoutExerciseTemplateInput | CourseExerciseUpdateWithWhereUniqueWithoutExerciseTemplateInput[]
    updateMany?: CourseExerciseUpdateManyWithWhereWithoutExerciseTemplateInput | CourseExerciseUpdateManyWithWhereWithoutExerciseTemplateInput[]
    deleteMany?: CourseExerciseScalarWhereInput | CourseExerciseScalarWhereInput[]
  }

  export type ExerciseTemplateCreateNestedOneWithoutExerciseEquipmentMappingsInput = {
    create?: XOR<ExerciseTemplateCreateWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUncheckedCreateWithoutExerciseEquipmentMappingsInput>
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutExerciseEquipmentMappingsInput
    connect?: ExerciseTemplateWhereUniqueInput
  }

  export type EquipmentTypeCreateNestedOneWithoutExerciseEquipmentMappingsInput = {
    create?: XOR<EquipmentTypeCreateWithoutExerciseEquipmentMappingsInput, EquipmentTypeUncheckedCreateWithoutExerciseEquipmentMappingsInput>
    connectOrCreate?: EquipmentTypeCreateOrConnectWithoutExerciseEquipmentMappingsInput
    connect?: EquipmentTypeWhereUniqueInput
  }

  export type ExerciseTemplateUpdateOneRequiredWithoutExerciseEquipmentMappingsNestedInput = {
    create?: XOR<ExerciseTemplateCreateWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUncheckedCreateWithoutExerciseEquipmentMappingsInput>
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutExerciseEquipmentMappingsInput
    upsert?: ExerciseTemplateUpsertWithoutExerciseEquipmentMappingsInput
    connect?: ExerciseTemplateWhereUniqueInput
    update?: XOR<XOR<ExerciseTemplateUpdateToOneWithWhereWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUpdateWithoutExerciseEquipmentMappingsInput>, ExerciseTemplateUncheckedUpdateWithoutExerciseEquipmentMappingsInput>
  }

  export type EquipmentTypeUpdateOneRequiredWithoutExerciseEquipmentMappingsNestedInput = {
    create?: XOR<EquipmentTypeCreateWithoutExerciseEquipmentMappingsInput, EquipmentTypeUncheckedCreateWithoutExerciseEquipmentMappingsInput>
    connectOrCreate?: EquipmentTypeCreateOrConnectWithoutExerciseEquipmentMappingsInput
    upsert?: EquipmentTypeUpsertWithoutExerciseEquipmentMappingsInput
    connect?: EquipmentTypeWhereUniqueInput
    update?: XOR<XOR<EquipmentTypeUpdateToOneWithWhereWithoutExerciseEquipmentMappingsInput, EquipmentTypeUpdateWithoutExerciseEquipmentMappingsInput>, EquipmentTypeUncheckedUpdateWithoutExerciseEquipmentMappingsInput>
  }

  export type CourseCreatebodyPartsInput = {
    set: string[]
  }

  export type CourseCreateequipmentAvailableInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseExerciseCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseExerciseCreateWithoutCourseInput, CourseExerciseUncheckedCreateWithoutCourseInput> | CourseExerciseCreateWithoutCourseInput[] | CourseExerciseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutCourseInput | CourseExerciseCreateOrConnectWithoutCourseInput[]
    createMany?: CourseExerciseCreateManyCourseInputEnvelope
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
  }

  export type UserCourseHistoryCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseHistoryCreateWithoutCourseInput, UserCourseHistoryUncheckedCreateWithoutCourseInput> | UserCourseHistoryCreateWithoutCourseInput[] | UserCourseHistoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutCourseInput | UserCourseHistoryCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseHistoryCreateManyCourseInputEnvelope
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
  }

  export type CourseExerciseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseExerciseCreateWithoutCourseInput, CourseExerciseUncheckedCreateWithoutCourseInput> | CourseExerciseCreateWithoutCourseInput[] | CourseExerciseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutCourseInput | CourseExerciseCreateOrConnectWithoutCourseInput[]
    createMany?: CourseExerciseCreateManyCourseInputEnvelope
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
  }

  export type UserCourseHistoryUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseHistoryCreateWithoutCourseInput, UserCourseHistoryUncheckedCreateWithoutCourseInput> | UserCourseHistoryCreateWithoutCourseInput[] | UserCourseHistoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutCourseInput | UserCourseHistoryCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseHistoryCreateManyCourseInputEnvelope
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
  }

  export type CourseUpdatebodyPartsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdateequipmentAvailableInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseExerciseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseExerciseCreateWithoutCourseInput, CourseExerciseUncheckedCreateWithoutCourseInput> | CourseExerciseCreateWithoutCourseInput[] | CourseExerciseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutCourseInput | CourseExerciseCreateOrConnectWithoutCourseInput[]
    upsert?: CourseExerciseUpsertWithWhereUniqueWithoutCourseInput | CourseExerciseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseExerciseCreateManyCourseInputEnvelope
    set?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    disconnect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    delete?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    update?: CourseExerciseUpdateWithWhereUniqueWithoutCourseInput | CourseExerciseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseExerciseUpdateManyWithWhereWithoutCourseInput | CourseExerciseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseExerciseScalarWhereInput | CourseExerciseScalarWhereInput[]
  }

  export type UserCourseHistoryUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseHistoryCreateWithoutCourseInput, UserCourseHistoryUncheckedCreateWithoutCourseInput> | UserCourseHistoryCreateWithoutCourseInput[] | UserCourseHistoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutCourseInput | UserCourseHistoryCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseHistoryUpsertWithWhereUniqueWithoutCourseInput | UserCourseHistoryUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseHistoryCreateManyCourseInputEnvelope
    set?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    disconnect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    delete?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    update?: UserCourseHistoryUpdateWithWhereUniqueWithoutCourseInput | UserCourseHistoryUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseHistoryUpdateManyWithWhereWithoutCourseInput | UserCourseHistoryUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseHistoryScalarWhereInput | UserCourseHistoryScalarWhereInput[]
  }

  export type CourseExerciseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseExerciseCreateWithoutCourseInput, CourseExerciseUncheckedCreateWithoutCourseInput> | CourseExerciseCreateWithoutCourseInput[] | CourseExerciseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseExerciseCreateOrConnectWithoutCourseInput | CourseExerciseCreateOrConnectWithoutCourseInput[]
    upsert?: CourseExerciseUpsertWithWhereUniqueWithoutCourseInput | CourseExerciseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseExerciseCreateManyCourseInputEnvelope
    set?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    disconnect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    delete?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    connect?: CourseExerciseWhereUniqueInput | CourseExerciseWhereUniqueInput[]
    update?: CourseExerciseUpdateWithWhereUniqueWithoutCourseInput | CourseExerciseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseExerciseUpdateManyWithWhereWithoutCourseInput | CourseExerciseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseExerciseScalarWhereInput | CourseExerciseScalarWhereInput[]
  }

  export type UserCourseHistoryUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseHistoryCreateWithoutCourseInput, UserCourseHistoryUncheckedCreateWithoutCourseInput> | UserCourseHistoryCreateWithoutCourseInput[] | UserCourseHistoryUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseHistoryCreateOrConnectWithoutCourseInput | UserCourseHistoryCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseHistoryUpsertWithWhereUniqueWithoutCourseInput | UserCourseHistoryUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseHistoryCreateManyCourseInputEnvelope
    set?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    disconnect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    delete?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    connect?: UserCourseHistoryWhereUniqueInput | UserCourseHistoryWhereUniqueInput[]
    update?: UserCourseHistoryUpdateWithWhereUniqueWithoutCourseInput | UserCourseHistoryUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseHistoryUpdateManyWithWhereWithoutCourseInput | UserCourseHistoryUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseHistoryScalarWhereInput | UserCourseHistoryScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourseExercisesInput = {
    create?: XOR<CourseCreateWithoutCourseExercisesInput, CourseUncheckedCreateWithoutCourseExercisesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseExercisesInput
    connect?: CourseWhereUniqueInput
  }

  export type ExerciseTemplateCreateNestedOneWithoutCourseExercisesInput = {
    create?: XOR<ExerciseTemplateCreateWithoutCourseExercisesInput, ExerciseTemplateUncheckedCreateWithoutCourseExercisesInput>
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutCourseExercisesInput
    connect?: ExerciseTemplateWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseExercisesNestedInput = {
    create?: XOR<CourseCreateWithoutCourseExercisesInput, CourseUncheckedCreateWithoutCourseExercisesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseExercisesInput
    upsert?: CourseUpsertWithoutCourseExercisesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseExercisesInput, CourseUpdateWithoutCourseExercisesInput>, CourseUncheckedUpdateWithoutCourseExercisesInput>
  }

  export type ExerciseTemplateUpdateOneRequiredWithoutCourseExercisesNestedInput = {
    create?: XOR<ExerciseTemplateCreateWithoutCourseExercisesInput, ExerciseTemplateUncheckedCreateWithoutCourseExercisesInput>
    connectOrCreate?: ExerciseTemplateCreateOrConnectWithoutCourseExercisesInput
    upsert?: ExerciseTemplateUpsertWithoutCourseExercisesInput
    connect?: ExerciseTemplateWhereUniqueInput
    update?: XOR<XOR<ExerciseTemplateUpdateToOneWithWhereWithoutCourseExercisesInput, ExerciseTemplateUpdateWithoutCourseExercisesInput>, ExerciseTemplateUncheckedUpdateWithoutCourseExercisesInput>
  }

  export type UserPainProfileCreateequipmentAvailableInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserPainProfilesInput = {
    create?: XOR<UserCreateWithoutUserPainProfilesInput, UserUncheckedCreateWithoutUserPainProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPainProfilesInput
    connect?: UserWhereUniqueInput
  }

  export type BodyPartCreateNestedOneWithoutUserPainProfilesInput = {
    create?: XOR<BodyPartCreateWithoutUserPainProfilesInput, BodyPartUncheckedCreateWithoutUserPainProfilesInput>
    connectOrCreate?: BodyPartCreateOrConnectWithoutUserPainProfilesInput
    connect?: BodyPartWhereUniqueInput
  }

  export type UserPainProfileUpdateequipmentAvailableInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutUserPainProfilesNestedInput = {
    create?: XOR<UserCreateWithoutUserPainProfilesInput, UserUncheckedCreateWithoutUserPainProfilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPainProfilesInput
    upsert?: UserUpsertWithoutUserPainProfilesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPainProfilesInput, UserUpdateWithoutUserPainProfilesInput>, UserUncheckedUpdateWithoutUserPainProfilesInput>
  }

  export type BodyPartUpdateOneRequiredWithoutUserPainProfilesNestedInput = {
    create?: XOR<BodyPartCreateWithoutUserPainProfilesInput, BodyPartUncheckedCreateWithoutUserPainProfilesInput>
    connectOrCreate?: BodyPartCreateOrConnectWithoutUserPainProfilesInput
    upsert?: BodyPartUpsertWithoutUserPainProfilesInput
    connect?: BodyPartWhereUniqueInput
    update?: XOR<XOR<BodyPartUpdateToOneWithWhereWithoutUserPainProfilesInput, BodyPartUpdateWithoutUserPainProfilesInput>, BodyPartUncheckedUpdateWithoutUserPainProfilesInput>
  }

  export type UserCreateNestedOneWithoutUserCourseHistoryInput = {
    create?: XOR<UserCreateWithoutUserCourseHistoryInput, UserUncheckedCreateWithoutUserCourseHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCourseHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutUserCourseHistoryInput = {
    create?: XOR<CourseCreateWithoutUserCourseHistoryInput, CourseUncheckedCreateWithoutUserCourseHistoryInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUserCourseHistoryInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneWithoutUserCourseHistoryNestedInput = {
    create?: XOR<UserCreateWithoutUserCourseHistoryInput, UserUncheckedCreateWithoutUserCourseHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCourseHistoryInput
    upsert?: UserUpsertWithoutUserCourseHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCourseHistoryInput, UserUpdateWithoutUserCourseHistoryInput>, UserUncheckedUpdateWithoutUserCourseHistoryInput>
  }

  export type CourseUpdateOneRequiredWithoutUserCourseHistoryNestedInput = {
    create?: XOR<CourseCreateWithoutUserCourseHistoryInput, CourseUncheckedCreateWithoutUserCourseHistoryInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUserCourseHistoryInput
    upsert?: CourseUpsertWithoutUserCourseHistoryInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutUserCourseHistoryInput, CourseUpdateWithoutUserCourseHistoryInput>, CourseUncheckedUpdateWithoutUserCourseHistoryInput>
  }

  export type UserCreateNestedOneWithoutUserFavoritesInput = {
    create?: XOR<UserCreateWithoutUserFavoritesInput, UserUncheckedCreateWithoutUserFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type GymCreateNestedOneWithoutUserFavoritesInput = {
    create?: XOR<GymCreateWithoutUserFavoritesInput, GymUncheckedCreateWithoutUserFavoritesInput>
    connectOrCreate?: GymCreateOrConnectWithoutUserFavoritesInput
    connect?: GymWhereUniqueInput
  }

  export type UserUpdateOneWithoutUserFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutUserFavoritesInput, UserUncheckedCreateWithoutUserFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavoritesInput
    upsert?: UserUpsertWithoutUserFavoritesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFavoritesInput, UserUpdateWithoutUserFavoritesInput>, UserUncheckedUpdateWithoutUserFavoritesInput>
  }

  export type GymUpdateOneRequiredWithoutUserFavoritesNestedInput = {
    create?: XOR<GymCreateWithoutUserFavoritesInput, GymUncheckedCreateWithoutUserFavoritesInput>
    connectOrCreate?: GymCreateOrConnectWithoutUserFavoritesInput
    upsert?: GymUpsertWithoutUserFavoritesInput
    connect?: GymWhereUniqueInput
    update?: XOR<XOR<GymUpdateToOneWithWhereWithoutUserFavoritesInput, GymUpdateWithoutUserFavoritesInput>, GymUncheckedUpdateWithoutUserFavoritesInput>
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutReviewsInput
    reviewTagMappings?: ReviewTagMappingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    gymId: string
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutUserInput = {
    id?: string
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseExercises?: CourseExerciseCreateNestedManyWithoutCourseInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUserInput = {
    id?: string
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseExercises?: CourseExerciseUncheckedCreateNestedManyWithoutCourseInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUserInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
  }

  export type CourseCreateManyUserInputEnvelope = {
    data: CourseCreateManyUserInput | CourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPainProfileCreateWithoutUserInput = {
    id?: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyPart: BodyPartCreateNestedOneWithoutUserPainProfilesInput
  }

  export type UserPainProfileUncheckedCreateWithoutUserInput = {
    id?: string
    bodyPartId: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPainProfileCreateOrConnectWithoutUserInput = {
    where: UserPainProfileWhereUniqueInput
    create: XOR<UserPainProfileCreateWithoutUserInput, UserPainProfileUncheckedCreateWithoutUserInput>
  }

  export type UserPainProfileCreateManyUserInputEnvelope = {
    data: UserPainProfileCreateManyUserInput | UserPainProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseHistoryCreateWithoutUserInput = {
    id?: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutUserCourseHistoryInput
  }

  export type UserCourseHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseHistoryCreateOrConnectWithoutUserInput = {
    where: UserCourseHistoryWhereUniqueInput
    create: XOR<UserCourseHistoryCreateWithoutUserInput, UserCourseHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserCourseHistoryCreateManyUserInputEnvelope = {
    data: UserCourseHistoryCreateManyUserInput | UserCourseHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutUserInput = {
    id?: string
    savedAt?: Date | string
    createdAt?: Date | string
    gym: GymCreateNestedOneWithoutUserFavoritesInput
  }

  export type UserFavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    gymId: string
    savedAt?: Date | string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteCreateManyUserInputEnvelope = {
    data: UserFavoriteCreateManyUserInput | UserFavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    eventName: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: Date | string
    createdAt?: Date | string
  }

  export type EventUncheckedCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    eventName: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: Date | string
    createdAt?: Date | string
  }

  export type EventCreateOrConnectWithoutUserInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventCreateManyUserInputEnvelope = {
    data: EventCreateManyUserInput | EventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: UuidFilter<"Review"> | string
    gymId?: UuidFilter<"Review"> | string
    userId?: UuidNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    isAdminReview?: BoolFilter<"Review"> | boolean
    isDeleted?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutUserInput, CourseUncheckedUpdateWithoutUserInput>
    create: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutUserInput, CourseUncheckedUpdateWithoutUserInput>
  }

  export type CourseUpdateManyWithWhereWithoutUserInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: UuidFilter<"Course"> | string
    userId?: UuidNullableFilter<"Course"> | string | null
    totalDurationMinutes?: IntFilter<"Course"> | number
    painLevel?: IntNullableFilter<"Course"> | number | null
    experienceLevel?: StringNullableFilter<"Course"> | string | null
    bodyParts?: StringNullableListFilter<"Course">
    equipmentAvailable?: StringNullableListFilter<"Course">
    courseType?: StringFilter<"Course"> | string
    isTemplate?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type UserPainProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPainProfileWhereUniqueInput
    update: XOR<UserPainProfileUpdateWithoutUserInput, UserPainProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserPainProfileCreateWithoutUserInput, UserPainProfileUncheckedCreateWithoutUserInput>
  }

  export type UserPainProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPainProfileWhereUniqueInput
    data: XOR<UserPainProfileUpdateWithoutUserInput, UserPainProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserPainProfileUpdateManyWithWhereWithoutUserInput = {
    where: UserPainProfileScalarWhereInput
    data: XOR<UserPainProfileUpdateManyMutationInput, UserPainProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPainProfileScalarWhereInput = {
    AND?: UserPainProfileScalarWhereInput | UserPainProfileScalarWhereInput[]
    OR?: UserPainProfileScalarWhereInput[]
    NOT?: UserPainProfileScalarWhereInput | UserPainProfileScalarWhereInput[]
    id?: UuidFilter<"UserPainProfile"> | string
    userId?: UuidNullableFilter<"UserPainProfile"> | string | null
    bodyPartId?: UuidFilter<"UserPainProfile"> | string
    painLevel?: IntNullableFilter<"UserPainProfile"> | number | null
    experienceLevel?: StringNullableFilter<"UserPainProfile"> | string | null
    equipmentAvailable?: StringNullableListFilter<"UserPainProfile">
    createdAt?: DateTimeFilter<"UserPainProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserPainProfile"> | Date | string
  }

  export type UserCourseHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCourseHistoryWhereUniqueInput
    update: XOR<UserCourseHistoryUpdateWithoutUserInput, UserCourseHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserCourseHistoryCreateWithoutUserInput, UserCourseHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserCourseHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCourseHistoryWhereUniqueInput
    data: XOR<UserCourseHistoryUpdateWithoutUserInput, UserCourseHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserCourseHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserCourseHistoryScalarWhereInput
    data: XOR<UserCourseHistoryUpdateManyMutationInput, UserCourseHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCourseHistoryScalarWhereInput = {
    AND?: UserCourseHistoryScalarWhereInput | UserCourseHistoryScalarWhereInput[]
    OR?: UserCourseHistoryScalarWhereInput[]
    NOT?: UserCourseHistoryScalarWhereInput | UserCourseHistoryScalarWhereInput[]
    id?: UuidFilter<"UserCourseHistory"> | string
    userId?: UuidNullableFilter<"UserCourseHistory"> | string | null
    courseId?: UuidFilter<"UserCourseHistory"> | string
    completedAt?: DateTimeNullableFilter<"UserCourseHistory"> | Date | string | null
    savedAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    isFavorite?: BoolFilter<"UserCourseHistory"> | boolean
    notes?: StringNullableFilter<"UserCourseHistory"> | string | null
    createdAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseHistory"> | Date | string
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavoriteScalarWhereInput = {
    AND?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    OR?: UserFavoriteScalarWhereInput[]
    NOT?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    id?: UuidFilter<"UserFavorite"> | string
    userId?: UuidNullableFilter<"UserFavorite"> | string | null
    gymId?: UuidFilter<"UserFavorite"> | string
    savedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithWhereWithoutUserInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUserInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: UuidFilter<"Event"> | string
    userId?: UuidNullableFilter<"Event"> | string | null
    anonymousId?: StringNullableFilter<"Event"> | string | null
    eventName?: StringFilter<"Event"> | string
    eventData?: JsonNullableFilter<"Event">
    eventTime?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type GymFacilityCreateWithoutGymInput = {
    id?: string
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: GymFacilityCreateotherFacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymFacilityUncheckedCreateWithoutGymInput = {
    id?: string
    isQuiet?: boolean
    hasRehabEquipment?: boolean
    hasPtCoach?: boolean
    hasShower?: boolean
    hasParking?: boolean
    hasLocker?: boolean
    hasWaterDispenser?: boolean
    hasAirConditioning?: boolean
    otherFacilities?: GymFacilityCreateotherFacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymFacilityCreateOrConnectWithoutGymInput = {
    where: GymFacilityWhereUniqueInput
    create: XOR<GymFacilityCreateWithoutGymInput, GymFacilityUncheckedCreateWithoutGymInput>
  }

  export type GymOperatingHourCreateWithoutGymInput = {
    id?: string
    dayOfWeek: number
    openTime?: string | null
    closeTime?: string | null
    isClosed?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymOperatingHourUncheckedCreateWithoutGymInput = {
    id?: string
    dayOfWeek: number
    openTime?: string | null
    closeTime?: string | null
    isClosed?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymOperatingHourCreateOrConnectWithoutGymInput = {
    where: GymOperatingHourWhereUniqueInput
    create: XOR<GymOperatingHourCreateWithoutGymInput, GymOperatingHourUncheckedCreateWithoutGymInput>
  }

  export type GymOperatingHourCreateManyGymInputEnvelope = {
    data: GymOperatingHourCreateManyGymInput | GymOperatingHourCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type GymCrowdLevelCreateWithoutGymInput = {
    id?: string
    timeSlot: string
    dayOfWeek?: number | null
    crowdLevel: string
    source?: string
    reportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymCrowdLevelUncheckedCreateWithoutGymInput = {
    id?: string
    timeSlot: string
    dayOfWeek?: number | null
    crowdLevel: string
    source?: string
    reportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymCrowdLevelCreateOrConnectWithoutGymInput = {
    where: GymCrowdLevelWhereUniqueInput
    create: XOR<GymCrowdLevelCreateWithoutGymInput, GymCrowdLevelUncheckedCreateWithoutGymInput>
  }

  export type GymCrowdLevelCreateManyGymInputEnvelope = {
    data: GymCrowdLevelCreateManyGymInput | GymCrowdLevelCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutGymInput = {
    id?: string
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutReviewsInput
    reviewTagMappings?: ReviewTagMappingCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutGymInput = {
    id?: string
    userId?: string | null
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutGymInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutGymInput, ReviewUncheckedCreateWithoutGymInput>
  }

  export type ReviewCreateManyGymInputEnvelope = {
    data: ReviewCreateManyGymInput | ReviewCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutGymInput = {
    id?: string
    savedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUserFavoritesInput
  }

  export type UserFavoriteUncheckedCreateWithoutGymInput = {
    id?: string
    userId?: string | null
    savedAt?: Date | string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutGymInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutGymInput, UserFavoriteUncheckedCreateWithoutGymInput>
  }

  export type UserFavoriteCreateManyGymInputEnvelope = {
    data: UserFavoriteCreateManyGymInput | UserFavoriteCreateManyGymInput[]
    skipDuplicates?: boolean
  }

  export type GymFacilityUpsertWithoutGymInput = {
    update: XOR<GymFacilityUpdateWithoutGymInput, GymFacilityUncheckedUpdateWithoutGymInput>
    create: XOR<GymFacilityCreateWithoutGymInput, GymFacilityUncheckedCreateWithoutGymInput>
    where?: GymFacilityWhereInput
  }

  export type GymFacilityUpdateToOneWithWhereWithoutGymInput = {
    where?: GymFacilityWhereInput
    data: XOR<GymFacilityUpdateWithoutGymInput, GymFacilityUncheckedUpdateWithoutGymInput>
  }

  export type GymFacilityUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    isQuiet?: BoolFieldUpdateOperationsInput | boolean
    hasRehabEquipment?: BoolFieldUpdateOperationsInput | boolean
    hasPtCoach?: BoolFieldUpdateOperationsInput | boolean
    hasShower?: BoolFieldUpdateOperationsInput | boolean
    hasParking?: BoolFieldUpdateOperationsInput | boolean
    hasLocker?: BoolFieldUpdateOperationsInput | boolean
    hasWaterDispenser?: BoolFieldUpdateOperationsInput | boolean
    hasAirConditioning?: BoolFieldUpdateOperationsInput | boolean
    otherFacilities?: GymFacilityUpdateotherFacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymFacilityUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    isQuiet?: BoolFieldUpdateOperationsInput | boolean
    hasRehabEquipment?: BoolFieldUpdateOperationsInput | boolean
    hasPtCoach?: BoolFieldUpdateOperationsInput | boolean
    hasShower?: BoolFieldUpdateOperationsInput | boolean
    hasParking?: BoolFieldUpdateOperationsInput | boolean
    hasLocker?: BoolFieldUpdateOperationsInput | boolean
    hasWaterDispenser?: BoolFieldUpdateOperationsInput | boolean
    hasAirConditioning?: BoolFieldUpdateOperationsInput | boolean
    otherFacilities?: GymFacilityUpdateotherFacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourUpsertWithWhereUniqueWithoutGymInput = {
    where: GymOperatingHourWhereUniqueInput
    update: XOR<GymOperatingHourUpdateWithoutGymInput, GymOperatingHourUncheckedUpdateWithoutGymInput>
    create: XOR<GymOperatingHourCreateWithoutGymInput, GymOperatingHourUncheckedCreateWithoutGymInput>
  }

  export type GymOperatingHourUpdateWithWhereUniqueWithoutGymInput = {
    where: GymOperatingHourWhereUniqueInput
    data: XOR<GymOperatingHourUpdateWithoutGymInput, GymOperatingHourUncheckedUpdateWithoutGymInput>
  }

  export type GymOperatingHourUpdateManyWithWhereWithoutGymInput = {
    where: GymOperatingHourScalarWhereInput
    data: XOR<GymOperatingHourUpdateManyMutationInput, GymOperatingHourUncheckedUpdateManyWithoutGymInput>
  }

  export type GymOperatingHourScalarWhereInput = {
    AND?: GymOperatingHourScalarWhereInput | GymOperatingHourScalarWhereInput[]
    OR?: GymOperatingHourScalarWhereInput[]
    NOT?: GymOperatingHourScalarWhereInput | GymOperatingHourScalarWhereInput[]
    id?: UuidFilter<"GymOperatingHour"> | string
    gymId?: UuidFilter<"GymOperatingHour"> | string
    dayOfWeek?: IntFilter<"GymOperatingHour"> | number
    openTime?: StringNullableFilter<"GymOperatingHour"> | string | null
    closeTime?: StringNullableFilter<"GymOperatingHour"> | string | null
    isClosed?: BoolFilter<"GymOperatingHour"> | boolean
    notes?: StringNullableFilter<"GymOperatingHour"> | string | null
    createdAt?: DateTimeFilter<"GymOperatingHour"> | Date | string
    updatedAt?: DateTimeFilter<"GymOperatingHour"> | Date | string
  }

  export type GymCrowdLevelUpsertWithWhereUniqueWithoutGymInput = {
    where: GymCrowdLevelWhereUniqueInput
    update: XOR<GymCrowdLevelUpdateWithoutGymInput, GymCrowdLevelUncheckedUpdateWithoutGymInput>
    create: XOR<GymCrowdLevelCreateWithoutGymInput, GymCrowdLevelUncheckedCreateWithoutGymInput>
  }

  export type GymCrowdLevelUpdateWithWhereUniqueWithoutGymInput = {
    where: GymCrowdLevelWhereUniqueInput
    data: XOR<GymCrowdLevelUpdateWithoutGymInput, GymCrowdLevelUncheckedUpdateWithoutGymInput>
  }

  export type GymCrowdLevelUpdateManyWithWhereWithoutGymInput = {
    where: GymCrowdLevelScalarWhereInput
    data: XOR<GymCrowdLevelUpdateManyMutationInput, GymCrowdLevelUncheckedUpdateManyWithoutGymInput>
  }

  export type GymCrowdLevelScalarWhereInput = {
    AND?: GymCrowdLevelScalarWhereInput | GymCrowdLevelScalarWhereInput[]
    OR?: GymCrowdLevelScalarWhereInput[]
    NOT?: GymCrowdLevelScalarWhereInput | GymCrowdLevelScalarWhereInput[]
    id?: UuidFilter<"GymCrowdLevel"> | string
    gymId?: UuidFilter<"GymCrowdLevel"> | string
    timeSlot?: StringFilter<"GymCrowdLevel"> | string
    dayOfWeek?: IntNullableFilter<"GymCrowdLevel"> | number | null
    crowdLevel?: StringFilter<"GymCrowdLevel"> | string
    source?: StringFilter<"GymCrowdLevel"> | string
    reportedAt?: DateTimeNullableFilter<"GymCrowdLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"GymCrowdLevel"> | Date | string
    updatedAt?: DateTimeFilter<"GymCrowdLevel"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutGymInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutGymInput, ReviewUncheckedUpdateWithoutGymInput>
    create: XOR<ReviewCreateWithoutGymInput, ReviewUncheckedCreateWithoutGymInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutGymInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutGymInput, ReviewUncheckedUpdateWithoutGymInput>
  }

  export type ReviewUpdateManyWithWhereWithoutGymInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutGymInput>
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutGymInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutGymInput, UserFavoriteUncheckedUpdateWithoutGymInput>
    create: XOR<UserFavoriteCreateWithoutGymInput, UserFavoriteUncheckedCreateWithoutGymInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutGymInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutGymInput, UserFavoriteUncheckedUpdateWithoutGymInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutGymInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutGymInput>
  }

  export type GymCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    operatingHours?: GymOperatingHourCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelCreateNestedManyWithoutGymInput
    reviews?: ReviewCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutGymInput
  }

  export type GymUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    operatingHours?: GymOperatingHourUncheckedCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelUncheckedCreateNestedManyWithoutGymInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutGymInput
  }

  export type GymCreateOrConnectWithoutFacilitiesInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutFacilitiesInput, GymUncheckedCreateWithoutFacilitiesInput>
  }

  export type GymUpsertWithoutFacilitiesInput = {
    update: XOR<GymUpdateWithoutFacilitiesInput, GymUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<GymCreateWithoutFacilitiesInput, GymUncheckedCreateWithoutFacilitiesInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutFacilitiesInput, GymUncheckedUpdateWithoutFacilitiesInput>
  }

  export type GymUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatingHours?: GymOperatingHourUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUpdateManyWithoutGymNestedInput
    reviews?: ReviewUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatingHours?: GymOperatingHourUncheckedUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUncheckedUpdateManyWithoutGymNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutGymNestedInput
  }

  export type GymCreateWithoutOperatingHoursInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityCreateNestedOneWithoutGymInput
    crowdLevels?: GymCrowdLevelCreateNestedManyWithoutGymInput
    reviews?: ReviewCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutGymInput
  }

  export type GymUncheckedCreateWithoutOperatingHoursInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityUncheckedCreateNestedOneWithoutGymInput
    crowdLevels?: GymCrowdLevelUncheckedCreateNestedManyWithoutGymInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutGymInput
  }

  export type GymCreateOrConnectWithoutOperatingHoursInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutOperatingHoursInput, GymUncheckedCreateWithoutOperatingHoursInput>
  }

  export type GymUpsertWithoutOperatingHoursInput = {
    update: XOR<GymUpdateWithoutOperatingHoursInput, GymUncheckedUpdateWithoutOperatingHoursInput>
    create: XOR<GymCreateWithoutOperatingHoursInput, GymUncheckedCreateWithoutOperatingHoursInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutOperatingHoursInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutOperatingHoursInput, GymUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type GymUpdateWithoutOperatingHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUpdateOneWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUpdateManyWithoutGymNestedInput
    reviews?: ReviewUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutOperatingHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUncheckedUpdateOneWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUncheckedUpdateManyWithoutGymNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutGymNestedInput
  }

  export type GymCreateWithoutCrowdLevelsInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourCreateNestedManyWithoutGymInput
    reviews?: ReviewCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutGymInput
  }

  export type GymUncheckedCreateWithoutCrowdLevelsInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityUncheckedCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourUncheckedCreateNestedManyWithoutGymInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutGymInput
  }

  export type GymCreateOrConnectWithoutCrowdLevelsInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutCrowdLevelsInput, GymUncheckedCreateWithoutCrowdLevelsInput>
  }

  export type GymUpsertWithoutCrowdLevelsInput = {
    update: XOR<GymUpdateWithoutCrowdLevelsInput, GymUncheckedUpdateWithoutCrowdLevelsInput>
    create: XOR<GymCreateWithoutCrowdLevelsInput, GymUncheckedCreateWithoutCrowdLevelsInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutCrowdLevelsInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutCrowdLevelsInput, GymUncheckedUpdateWithoutCrowdLevelsInput>
  }

  export type GymUpdateWithoutCrowdLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUpdateManyWithoutGymNestedInput
    reviews?: ReviewUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutCrowdLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUncheckedUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUncheckedUpdateManyWithoutGymNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutGymNestedInput
  }

  export type ReviewTagMappingCreateWithoutReviewTagInput = {
    id?: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutReviewTagMappingsInput
  }

  export type ReviewTagMappingUncheckedCreateWithoutReviewTagInput = {
    id?: string
    reviewId: string
    createdAt?: Date | string
  }

  export type ReviewTagMappingCreateOrConnectWithoutReviewTagInput = {
    where: ReviewTagMappingWhereUniqueInput
    create: XOR<ReviewTagMappingCreateWithoutReviewTagInput, ReviewTagMappingUncheckedCreateWithoutReviewTagInput>
  }

  export type ReviewTagMappingCreateManyReviewTagInputEnvelope = {
    data: ReviewTagMappingCreateManyReviewTagInput | ReviewTagMappingCreateManyReviewTagInput[]
    skipDuplicates?: boolean
  }

  export type ReviewTagMappingUpsertWithWhereUniqueWithoutReviewTagInput = {
    where: ReviewTagMappingWhereUniqueInput
    update: XOR<ReviewTagMappingUpdateWithoutReviewTagInput, ReviewTagMappingUncheckedUpdateWithoutReviewTagInput>
    create: XOR<ReviewTagMappingCreateWithoutReviewTagInput, ReviewTagMappingUncheckedCreateWithoutReviewTagInput>
  }

  export type ReviewTagMappingUpdateWithWhereUniqueWithoutReviewTagInput = {
    where: ReviewTagMappingWhereUniqueInput
    data: XOR<ReviewTagMappingUpdateWithoutReviewTagInput, ReviewTagMappingUncheckedUpdateWithoutReviewTagInput>
  }

  export type ReviewTagMappingUpdateManyWithWhereWithoutReviewTagInput = {
    where: ReviewTagMappingScalarWhereInput
    data: XOR<ReviewTagMappingUpdateManyMutationInput, ReviewTagMappingUncheckedUpdateManyWithoutReviewTagInput>
  }

  export type ReviewTagMappingScalarWhereInput = {
    AND?: ReviewTagMappingScalarWhereInput | ReviewTagMappingScalarWhereInput[]
    OR?: ReviewTagMappingScalarWhereInput[]
    NOT?: ReviewTagMappingScalarWhereInput | ReviewTagMappingScalarWhereInput[]
    id?: UuidFilter<"ReviewTagMapping"> | string
    reviewId?: UuidFilter<"ReviewTagMapping"> | string
    reviewTagId?: UuidFilter<"ReviewTagMapping"> | string
    createdAt?: DateTimeFilter<"ReviewTagMapping"> | Date | string
  }

  export type GymCreateWithoutReviewsInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutGymInput
  }

  export type GymUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityUncheckedCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourUncheckedCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelUncheckedCreateNestedManyWithoutGymInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutGymInput
  }

  export type GymCreateOrConnectWithoutReviewsInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutReviewsInput, GymUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ReviewTagMappingCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    reviewTag: ReviewTagCreateNestedOneWithoutReviewTagMappingsInput
  }

  export type ReviewTagMappingUncheckedCreateWithoutReviewInput = {
    id?: string
    reviewTagId: string
    createdAt?: Date | string
  }

  export type ReviewTagMappingCreateOrConnectWithoutReviewInput = {
    where: ReviewTagMappingWhereUniqueInput
    create: XOR<ReviewTagMappingCreateWithoutReviewInput, ReviewTagMappingUncheckedCreateWithoutReviewInput>
  }

  export type ReviewTagMappingCreateManyReviewInputEnvelope = {
    data: ReviewTagMappingCreateManyReviewInput | ReviewTagMappingCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type GymUpsertWithoutReviewsInput = {
    update: XOR<GymUpdateWithoutReviewsInput, GymUncheckedUpdateWithoutReviewsInput>
    create: XOR<GymCreateWithoutReviewsInput, GymUncheckedCreateWithoutReviewsInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutReviewsInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutReviewsInput, GymUncheckedUpdateWithoutReviewsInput>
  }

  export type GymUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUncheckedUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUncheckedUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUncheckedUpdateManyWithoutGymNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutGymNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewTagMappingUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewTagMappingWhereUniqueInput
    update: XOR<ReviewTagMappingUpdateWithoutReviewInput, ReviewTagMappingUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewTagMappingCreateWithoutReviewInput, ReviewTagMappingUncheckedCreateWithoutReviewInput>
  }

  export type ReviewTagMappingUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewTagMappingWhereUniqueInput
    data: XOR<ReviewTagMappingUpdateWithoutReviewInput, ReviewTagMappingUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewTagMappingUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewTagMappingScalarWhereInput
    data: XOR<ReviewTagMappingUpdateManyMutationInput, ReviewTagMappingUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewCreateWithoutReviewTagMappingsInput = {
    id?: string
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gym: GymCreateNestedOneWithoutReviewsInput
    user?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutReviewTagMappingsInput = {
    id?: string
    gymId: string
    userId?: string | null
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutReviewTagMappingsInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutReviewTagMappingsInput, ReviewUncheckedCreateWithoutReviewTagMappingsInput>
  }

  export type ReviewTagCreateWithoutReviewTagMappingsInput = {
    id?: string
    name: string
    category?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ReviewTagUncheckedCreateWithoutReviewTagMappingsInput = {
    id?: string
    name: string
    category?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ReviewTagCreateOrConnectWithoutReviewTagMappingsInput = {
    where: ReviewTagWhereUniqueInput
    create: XOR<ReviewTagCreateWithoutReviewTagMappingsInput, ReviewTagUncheckedCreateWithoutReviewTagMappingsInput>
  }

  export type ReviewUpsertWithoutReviewTagMappingsInput = {
    update: XOR<ReviewUpdateWithoutReviewTagMappingsInput, ReviewUncheckedUpdateWithoutReviewTagMappingsInput>
    create: XOR<ReviewCreateWithoutReviewTagMappingsInput, ReviewUncheckedCreateWithoutReviewTagMappingsInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutReviewTagMappingsInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutReviewTagMappingsInput, ReviewUncheckedUpdateWithoutReviewTagMappingsInput>
  }

  export type ReviewUpdateWithoutReviewTagMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutReviewTagMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagUpsertWithoutReviewTagMappingsInput = {
    update: XOR<ReviewTagUpdateWithoutReviewTagMappingsInput, ReviewTagUncheckedUpdateWithoutReviewTagMappingsInput>
    create: XOR<ReviewTagCreateWithoutReviewTagMappingsInput, ReviewTagUncheckedCreateWithoutReviewTagMappingsInput>
    where?: ReviewTagWhereInput
  }

  export type ReviewTagUpdateToOneWithWhereWithoutReviewTagMappingsInput = {
    where?: ReviewTagWhereInput
    data: XOR<ReviewTagUpdateWithoutReviewTagMappingsInput, ReviewTagUncheckedUpdateWithoutReviewTagMappingsInput>
  }

  export type ReviewTagUpdateWithoutReviewTagMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagUncheckedUpdateWithoutReviewTagMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTemplateCreateWithoutBodyPartInput = {
    id?: string
    name: string
    description?: string | null
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingCreateNestedManyWithoutExerciseTemplateInput
    courseExercises?: CourseExerciseCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateUncheckedCreateWithoutBodyPartInput = {
    id?: string
    name: string
    description?: string | null
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedCreateNestedManyWithoutExerciseTemplateInput
    courseExercises?: CourseExerciseUncheckedCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateCreateOrConnectWithoutBodyPartInput = {
    where: ExerciseTemplateWhereUniqueInput
    create: XOR<ExerciseTemplateCreateWithoutBodyPartInput, ExerciseTemplateUncheckedCreateWithoutBodyPartInput>
  }

  export type ExerciseTemplateCreateManyBodyPartInputEnvelope = {
    data: ExerciseTemplateCreateManyBodyPartInput | ExerciseTemplateCreateManyBodyPartInput[]
    skipDuplicates?: boolean
  }

  export type UserPainProfileCreateWithoutBodyPartInput = {
    id?: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserPainProfilesInput
  }

  export type UserPainProfileUncheckedCreateWithoutBodyPartInput = {
    id?: string
    userId?: string | null
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPainProfileCreateOrConnectWithoutBodyPartInput = {
    where: UserPainProfileWhereUniqueInput
    create: XOR<UserPainProfileCreateWithoutBodyPartInput, UserPainProfileUncheckedCreateWithoutBodyPartInput>
  }

  export type UserPainProfileCreateManyBodyPartInputEnvelope = {
    data: UserPainProfileCreateManyBodyPartInput | UserPainProfileCreateManyBodyPartInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseTemplateUpsertWithWhereUniqueWithoutBodyPartInput = {
    where: ExerciseTemplateWhereUniqueInput
    update: XOR<ExerciseTemplateUpdateWithoutBodyPartInput, ExerciseTemplateUncheckedUpdateWithoutBodyPartInput>
    create: XOR<ExerciseTemplateCreateWithoutBodyPartInput, ExerciseTemplateUncheckedCreateWithoutBodyPartInput>
  }

  export type ExerciseTemplateUpdateWithWhereUniqueWithoutBodyPartInput = {
    where: ExerciseTemplateWhereUniqueInput
    data: XOR<ExerciseTemplateUpdateWithoutBodyPartInput, ExerciseTemplateUncheckedUpdateWithoutBodyPartInput>
  }

  export type ExerciseTemplateUpdateManyWithWhereWithoutBodyPartInput = {
    where: ExerciseTemplateScalarWhereInput
    data: XOR<ExerciseTemplateUpdateManyMutationInput, ExerciseTemplateUncheckedUpdateManyWithoutBodyPartInput>
  }

  export type ExerciseTemplateScalarWhereInput = {
    AND?: ExerciseTemplateScalarWhereInput | ExerciseTemplateScalarWhereInput[]
    OR?: ExerciseTemplateScalarWhereInput[]
    NOT?: ExerciseTemplateScalarWhereInput | ExerciseTemplateScalarWhereInput[]
    id?: UuidFilter<"ExerciseTemplate"> | string
    name?: StringFilter<"ExerciseTemplate"> | string
    description?: StringNullableFilter<"ExerciseTemplate"> | string | null
    bodyPartId?: UuidFilter<"ExerciseTemplate"> | string
    intensityLevel?: IntNullableFilter<"ExerciseTemplate"> | number | null
    durationMinutes?: IntNullableFilter<"ExerciseTemplate"> | number | null
    reps?: IntNullableFilter<"ExerciseTemplate"> | number | null
    sets?: IntNullableFilter<"ExerciseTemplate"> | number | null
    restSeconds?: IntNullableFilter<"ExerciseTemplate"> | number | null
    difficultyScore?: IntNullableFilter<"ExerciseTemplate"> | number | null
    contraindications?: StringNullableListFilter<"ExerciseTemplate">
    instructions?: StringNullableFilter<"ExerciseTemplate"> | string | null
    precautions?: StringNullableFilter<"ExerciseTemplate"> | string | null
    isActive?: BoolFilter<"ExerciseTemplate"> | boolean
    createdAt?: DateTimeFilter<"ExerciseTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseTemplate"> | Date | string
  }

  export type UserPainProfileUpsertWithWhereUniqueWithoutBodyPartInput = {
    where: UserPainProfileWhereUniqueInput
    update: XOR<UserPainProfileUpdateWithoutBodyPartInput, UserPainProfileUncheckedUpdateWithoutBodyPartInput>
    create: XOR<UserPainProfileCreateWithoutBodyPartInput, UserPainProfileUncheckedCreateWithoutBodyPartInput>
  }

  export type UserPainProfileUpdateWithWhereUniqueWithoutBodyPartInput = {
    where: UserPainProfileWhereUniqueInput
    data: XOR<UserPainProfileUpdateWithoutBodyPartInput, UserPainProfileUncheckedUpdateWithoutBodyPartInput>
  }

  export type UserPainProfileUpdateManyWithWhereWithoutBodyPartInput = {
    where: UserPainProfileScalarWhereInput
    data: XOR<UserPainProfileUpdateManyMutationInput, UserPainProfileUncheckedUpdateManyWithoutBodyPartInput>
  }

  export type ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    exerciseTemplate: ExerciseTemplateCreateNestedOneWithoutExerciseEquipmentMappingsInput
  }

  export type ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput = {
    id?: string
    exerciseTemplateId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type ExerciseEquipmentMappingCreateOrConnectWithoutEquipmentTypeInput = {
    where: ExerciseEquipmentMappingWhereUniqueInput
    create: XOR<ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput>
  }

  export type ExerciseEquipmentMappingCreateManyEquipmentTypeInputEnvelope = {
    data: ExerciseEquipmentMappingCreateManyEquipmentTypeInput | ExerciseEquipmentMappingCreateManyEquipmentTypeInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutEquipmentTypeInput = {
    where: ExerciseEquipmentMappingWhereUniqueInput
    update: XOR<ExerciseEquipmentMappingUpdateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedUpdateWithoutEquipmentTypeInput>
    create: XOR<ExerciseEquipmentMappingCreateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedCreateWithoutEquipmentTypeInput>
  }

  export type ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutEquipmentTypeInput = {
    where: ExerciseEquipmentMappingWhereUniqueInput
    data: XOR<ExerciseEquipmentMappingUpdateWithoutEquipmentTypeInput, ExerciseEquipmentMappingUncheckedUpdateWithoutEquipmentTypeInput>
  }

  export type ExerciseEquipmentMappingUpdateManyWithWhereWithoutEquipmentTypeInput = {
    where: ExerciseEquipmentMappingScalarWhereInput
    data: XOR<ExerciseEquipmentMappingUpdateManyMutationInput, ExerciseEquipmentMappingUncheckedUpdateManyWithoutEquipmentTypeInput>
  }

  export type ExerciseEquipmentMappingScalarWhereInput = {
    AND?: ExerciseEquipmentMappingScalarWhereInput | ExerciseEquipmentMappingScalarWhereInput[]
    OR?: ExerciseEquipmentMappingScalarWhereInput[]
    NOT?: ExerciseEquipmentMappingScalarWhereInput | ExerciseEquipmentMappingScalarWhereInput[]
    id?: UuidFilter<"ExerciseEquipmentMapping"> | string
    exerciseTemplateId?: UuidFilter<"ExerciseEquipmentMapping"> | string
    equipmentTypeId?: UuidFilter<"ExerciseEquipmentMapping"> | string
    isRequired?: BoolFilter<"ExerciseEquipmentMapping"> | boolean
    createdAt?: DateTimeFilter<"ExerciseEquipmentMapping"> | Date | string
  }

  export type BodyPartCreateWithoutExerciseTemplatesInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutBodyPartInput
  }

  export type BodyPartUncheckedCreateWithoutExerciseTemplatesInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutBodyPartInput
  }

  export type BodyPartCreateOrConnectWithoutExerciseTemplatesInput = {
    where: BodyPartWhereUniqueInput
    create: XOR<BodyPartCreateWithoutExerciseTemplatesInput, BodyPartUncheckedCreateWithoutExerciseTemplatesInput>
  }

  export type ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    equipmentType: EquipmentTypeCreateNestedOneWithoutExerciseEquipmentMappingsInput
  }

  export type ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput = {
    id?: string
    equipmentTypeId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type ExerciseEquipmentMappingCreateOrConnectWithoutExerciseTemplateInput = {
    where: ExerciseEquipmentMappingWhereUniqueInput
    create: XOR<ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput>
  }

  export type ExerciseEquipmentMappingCreateManyExerciseTemplateInputEnvelope = {
    data: ExerciseEquipmentMappingCreateManyExerciseTemplateInput | ExerciseEquipmentMappingCreateManyExerciseTemplateInput[]
    skipDuplicates?: boolean
  }

  export type CourseExerciseCreateWithoutExerciseTemplateInput = {
    id?: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutCourseExercisesInput
  }

  export type CourseExerciseUncheckedCreateWithoutExerciseTemplateInput = {
    id?: string
    courseId: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CourseExerciseCreateOrConnectWithoutExerciseTemplateInput = {
    where: CourseExerciseWhereUniqueInput
    create: XOR<CourseExerciseCreateWithoutExerciseTemplateInput, CourseExerciseUncheckedCreateWithoutExerciseTemplateInput>
  }

  export type CourseExerciseCreateManyExerciseTemplateInputEnvelope = {
    data: CourseExerciseCreateManyExerciseTemplateInput | CourseExerciseCreateManyExerciseTemplateInput[]
    skipDuplicates?: boolean
  }

  export type BodyPartUpsertWithoutExerciseTemplatesInput = {
    update: XOR<BodyPartUpdateWithoutExerciseTemplatesInput, BodyPartUncheckedUpdateWithoutExerciseTemplatesInput>
    create: XOR<BodyPartCreateWithoutExerciseTemplatesInput, BodyPartUncheckedCreateWithoutExerciseTemplatesInput>
    where?: BodyPartWhereInput
  }

  export type BodyPartUpdateToOneWithWhereWithoutExerciseTemplatesInput = {
    where?: BodyPartWhereInput
    data: XOR<BodyPartUpdateWithoutExerciseTemplatesInput, BodyPartUncheckedUpdateWithoutExerciseTemplatesInput>
  }

  export type BodyPartUpdateWithoutExerciseTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPainProfiles?: UserPainProfileUpdateManyWithoutBodyPartNestedInput
  }

  export type BodyPartUncheckedUpdateWithoutExerciseTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutBodyPartNestedInput
  }

  export type ExerciseEquipmentMappingUpsertWithWhereUniqueWithoutExerciseTemplateInput = {
    where: ExerciseEquipmentMappingWhereUniqueInput
    update: XOR<ExerciseEquipmentMappingUpdateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedUpdateWithoutExerciseTemplateInput>
    create: XOR<ExerciseEquipmentMappingCreateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedCreateWithoutExerciseTemplateInput>
  }

  export type ExerciseEquipmentMappingUpdateWithWhereUniqueWithoutExerciseTemplateInput = {
    where: ExerciseEquipmentMappingWhereUniqueInput
    data: XOR<ExerciseEquipmentMappingUpdateWithoutExerciseTemplateInput, ExerciseEquipmentMappingUncheckedUpdateWithoutExerciseTemplateInput>
  }

  export type ExerciseEquipmentMappingUpdateManyWithWhereWithoutExerciseTemplateInput = {
    where: ExerciseEquipmentMappingScalarWhereInput
    data: XOR<ExerciseEquipmentMappingUpdateManyMutationInput, ExerciseEquipmentMappingUncheckedUpdateManyWithoutExerciseTemplateInput>
  }

  export type CourseExerciseUpsertWithWhereUniqueWithoutExerciseTemplateInput = {
    where: CourseExerciseWhereUniqueInput
    update: XOR<CourseExerciseUpdateWithoutExerciseTemplateInput, CourseExerciseUncheckedUpdateWithoutExerciseTemplateInput>
    create: XOR<CourseExerciseCreateWithoutExerciseTemplateInput, CourseExerciseUncheckedCreateWithoutExerciseTemplateInput>
  }

  export type CourseExerciseUpdateWithWhereUniqueWithoutExerciseTemplateInput = {
    where: CourseExerciseWhereUniqueInput
    data: XOR<CourseExerciseUpdateWithoutExerciseTemplateInput, CourseExerciseUncheckedUpdateWithoutExerciseTemplateInput>
  }

  export type CourseExerciseUpdateManyWithWhereWithoutExerciseTemplateInput = {
    where: CourseExerciseScalarWhereInput
    data: XOR<CourseExerciseUpdateManyMutationInput, CourseExerciseUncheckedUpdateManyWithoutExerciseTemplateInput>
  }

  export type CourseExerciseScalarWhereInput = {
    AND?: CourseExerciseScalarWhereInput | CourseExerciseScalarWhereInput[]
    OR?: CourseExerciseScalarWhereInput[]
    NOT?: CourseExerciseScalarWhereInput | CourseExerciseScalarWhereInput[]
    id?: UuidFilter<"CourseExercise"> | string
    courseId?: UuidFilter<"CourseExercise"> | string
    exerciseTemplateId?: UuidFilter<"CourseExercise"> | string
    section?: StringFilter<"CourseExercise"> | string
    orderInSection?: IntFilter<"CourseExercise"> | number
    durationMinutes?: IntNullableFilter<"CourseExercise"> | number | null
    reps?: IntNullableFilter<"CourseExercise"> | number | null
    sets?: IntNullableFilter<"CourseExercise"> | number | null
    restSeconds?: IntNullableFilter<"CourseExercise"> | number | null
    notes?: StringNullableFilter<"CourseExercise"> | string | null
    createdAt?: DateTimeFilter<"CourseExercise"> | Date | string
  }

  export type ExerciseTemplateCreateWithoutExerciseEquipmentMappingsInput = {
    id?: string
    name: string
    description?: string | null
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyPart: BodyPartCreateNestedOneWithoutExerciseTemplatesInput
    courseExercises?: CourseExerciseCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateUncheckedCreateWithoutExerciseEquipmentMappingsInput = {
    id?: string
    name: string
    description?: string | null
    bodyPartId: string
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseExercises?: CourseExerciseUncheckedCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateCreateOrConnectWithoutExerciseEquipmentMappingsInput = {
    where: ExerciseTemplateWhereUniqueInput
    create: XOR<ExerciseTemplateCreateWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUncheckedCreateWithoutExerciseEquipmentMappingsInput>
  }

  export type EquipmentTypeCreateWithoutExerciseEquipmentMappingsInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EquipmentTypeUncheckedCreateWithoutExerciseEquipmentMappingsInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EquipmentTypeCreateOrConnectWithoutExerciseEquipmentMappingsInput = {
    where: EquipmentTypeWhereUniqueInput
    create: XOR<EquipmentTypeCreateWithoutExerciseEquipmentMappingsInput, EquipmentTypeUncheckedCreateWithoutExerciseEquipmentMappingsInput>
  }

  export type ExerciseTemplateUpsertWithoutExerciseEquipmentMappingsInput = {
    update: XOR<ExerciseTemplateUpdateWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUncheckedUpdateWithoutExerciseEquipmentMappingsInput>
    create: XOR<ExerciseTemplateCreateWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUncheckedCreateWithoutExerciseEquipmentMappingsInput>
    where?: ExerciseTemplateWhereInput
  }

  export type ExerciseTemplateUpdateToOneWithWhereWithoutExerciseEquipmentMappingsInput = {
    where?: ExerciseTemplateWhereInput
    data: XOR<ExerciseTemplateUpdateWithoutExerciseEquipmentMappingsInput, ExerciseTemplateUncheckedUpdateWithoutExerciseEquipmentMappingsInput>
  }

  export type ExerciseTemplateUpdateWithoutExerciseEquipmentMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyPart?: BodyPartUpdateOneRequiredWithoutExerciseTemplatesNestedInput
    courseExercises?: CourseExerciseUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type ExerciseTemplateUncheckedUpdateWithoutExerciseEquipmentMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartId?: StringFieldUpdateOperationsInput | string
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseExercises?: CourseExerciseUncheckedUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type EquipmentTypeUpsertWithoutExerciseEquipmentMappingsInput = {
    update: XOR<EquipmentTypeUpdateWithoutExerciseEquipmentMappingsInput, EquipmentTypeUncheckedUpdateWithoutExerciseEquipmentMappingsInput>
    create: XOR<EquipmentTypeCreateWithoutExerciseEquipmentMappingsInput, EquipmentTypeUncheckedCreateWithoutExerciseEquipmentMappingsInput>
    where?: EquipmentTypeWhereInput
  }

  export type EquipmentTypeUpdateToOneWithWhereWithoutExerciseEquipmentMappingsInput = {
    where?: EquipmentTypeWhereInput
    data: XOR<EquipmentTypeUpdateWithoutExerciseEquipmentMappingsInput, EquipmentTypeUncheckedUpdateWithoutExerciseEquipmentMappingsInput>
  }

  export type EquipmentTypeUpdateWithoutExerciseEquipmentMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentTypeUncheckedUpdateWithoutExerciseEquipmentMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type CourseExerciseCreateWithoutCourseInput = {
    id?: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
    exerciseTemplate: ExerciseTemplateCreateNestedOneWithoutCourseExercisesInput
  }

  export type CourseExerciseUncheckedCreateWithoutCourseInput = {
    id?: string
    exerciseTemplateId: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CourseExerciseCreateOrConnectWithoutCourseInput = {
    where: CourseExerciseWhereUniqueInput
    create: XOR<CourseExerciseCreateWithoutCourseInput, CourseExerciseUncheckedCreateWithoutCourseInput>
  }

  export type CourseExerciseCreateManyCourseInputEnvelope = {
    data: CourseExerciseCreateManyCourseInput | CourseExerciseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseHistoryCreateWithoutCourseInput = {
    id?: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserCourseHistoryInput
  }

  export type UserCourseHistoryUncheckedCreateWithoutCourseInput = {
    id?: string
    userId?: string | null
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseHistoryCreateOrConnectWithoutCourseInput = {
    where: UserCourseHistoryWhereUniqueInput
    create: XOR<UserCourseHistoryCreateWithoutCourseInput, UserCourseHistoryUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseHistoryCreateManyCourseInputEnvelope = {
    data: UserCourseHistoryCreateManyCourseInput | UserCourseHistoryCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseExerciseUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseExerciseWhereUniqueInput
    update: XOR<CourseExerciseUpdateWithoutCourseInput, CourseExerciseUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseExerciseCreateWithoutCourseInput, CourseExerciseUncheckedCreateWithoutCourseInput>
  }

  export type CourseExerciseUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseExerciseWhereUniqueInput
    data: XOR<CourseExerciseUpdateWithoutCourseInput, CourseExerciseUncheckedUpdateWithoutCourseInput>
  }

  export type CourseExerciseUpdateManyWithWhereWithoutCourseInput = {
    where: CourseExerciseScalarWhereInput
    data: XOR<CourseExerciseUpdateManyMutationInput, CourseExerciseUncheckedUpdateManyWithoutCourseInput>
  }

  export type UserCourseHistoryUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserCourseHistoryWhereUniqueInput
    update: XOR<UserCourseHistoryUpdateWithoutCourseInput, UserCourseHistoryUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCourseHistoryCreateWithoutCourseInput, UserCourseHistoryUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseHistoryUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserCourseHistoryWhereUniqueInput
    data: XOR<UserCourseHistoryUpdateWithoutCourseInput, UserCourseHistoryUncheckedUpdateWithoutCourseInput>
  }

  export type UserCourseHistoryUpdateManyWithWhereWithoutCourseInput = {
    where: UserCourseHistoryScalarWhereInput
    data: XOR<UserCourseHistoryUpdateManyMutationInput, UserCourseHistoryUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutCourseExercisesInput = {
    id?: string
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCoursesInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseExercisesInput = {
    id?: string
    userId?: string | null
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseExercisesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseExercisesInput, CourseUncheckedCreateWithoutCourseExercisesInput>
  }

  export type ExerciseTemplateCreateWithoutCourseExercisesInput = {
    id?: string
    name: string
    description?: string | null
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyPart: BodyPartCreateNestedOneWithoutExerciseTemplatesInput
    exerciseEquipmentMappings?: ExerciseEquipmentMappingCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateUncheckedCreateWithoutCourseExercisesInput = {
    id?: string
    name: string
    description?: string | null
    bodyPartId: string
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedCreateNestedManyWithoutExerciseTemplateInput
  }

  export type ExerciseTemplateCreateOrConnectWithoutCourseExercisesInput = {
    where: ExerciseTemplateWhereUniqueInput
    create: XOR<ExerciseTemplateCreateWithoutCourseExercisesInput, ExerciseTemplateUncheckedCreateWithoutCourseExercisesInput>
  }

  export type CourseUpsertWithoutCourseExercisesInput = {
    update: XOR<CourseUpdateWithoutCourseExercisesInput, CourseUncheckedUpdateWithoutCourseExercisesInput>
    create: XOR<CourseCreateWithoutCourseExercisesInput, CourseUncheckedCreateWithoutCourseExercisesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseExercisesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseExercisesInput, CourseUncheckedUpdateWithoutCourseExercisesInput>
  }

  export type CourseUpdateWithoutCourseExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCoursesNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ExerciseTemplateUpsertWithoutCourseExercisesInput = {
    update: XOR<ExerciseTemplateUpdateWithoutCourseExercisesInput, ExerciseTemplateUncheckedUpdateWithoutCourseExercisesInput>
    create: XOR<ExerciseTemplateCreateWithoutCourseExercisesInput, ExerciseTemplateUncheckedCreateWithoutCourseExercisesInput>
    where?: ExerciseTemplateWhereInput
  }

  export type ExerciseTemplateUpdateToOneWithWhereWithoutCourseExercisesInput = {
    where?: ExerciseTemplateWhereInput
    data: XOR<ExerciseTemplateUpdateWithoutCourseExercisesInput, ExerciseTemplateUncheckedUpdateWithoutCourseExercisesInput>
  }

  export type ExerciseTemplateUpdateWithoutCourseExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyPart?: BodyPartUpdateOneRequiredWithoutExerciseTemplatesNestedInput
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type ExerciseTemplateUncheckedUpdateWithoutCourseExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPartId?: StringFieldUpdateOperationsInput | string
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type UserCreateWithoutUserPainProfilesInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPainProfilesInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPainProfilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPainProfilesInput, UserUncheckedCreateWithoutUserPainProfilesInput>
  }

  export type BodyPartCreateWithoutUserPainProfilesInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    exerciseTemplates?: ExerciseTemplateCreateNestedManyWithoutBodyPartInput
  }

  export type BodyPartUncheckedCreateWithoutUserPainProfilesInput = {
    id?: string
    name: string
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    exerciseTemplates?: ExerciseTemplateUncheckedCreateNestedManyWithoutBodyPartInput
  }

  export type BodyPartCreateOrConnectWithoutUserPainProfilesInput = {
    where: BodyPartWhereUniqueInput
    create: XOR<BodyPartCreateWithoutUserPainProfilesInput, BodyPartUncheckedCreateWithoutUserPainProfilesInput>
  }

  export type UserUpsertWithoutUserPainProfilesInput = {
    update: XOR<UserUpdateWithoutUserPainProfilesInput, UserUncheckedUpdateWithoutUserPainProfilesInput>
    create: XOR<UserCreateWithoutUserPainProfilesInput, UserUncheckedCreateWithoutUserPainProfilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPainProfilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPainProfilesInput, UserUncheckedUpdateWithoutUserPainProfilesInput>
  }

  export type UserUpdateWithoutUserPainProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPainProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BodyPartUpsertWithoutUserPainProfilesInput = {
    update: XOR<BodyPartUpdateWithoutUserPainProfilesInput, BodyPartUncheckedUpdateWithoutUserPainProfilesInput>
    create: XOR<BodyPartCreateWithoutUserPainProfilesInput, BodyPartUncheckedCreateWithoutUserPainProfilesInput>
    where?: BodyPartWhereInput
  }

  export type BodyPartUpdateToOneWithWhereWithoutUserPainProfilesInput = {
    where?: BodyPartWhereInput
    data: XOR<BodyPartUpdateWithoutUserPainProfilesInput, BodyPartUncheckedUpdateWithoutUserPainProfilesInput>
  }

  export type BodyPartUpdateWithoutUserPainProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplates?: ExerciseTemplateUpdateManyWithoutBodyPartNestedInput
  }

  export type BodyPartUncheckedUpdateWithoutUserPainProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplates?: ExerciseTemplateUncheckedUpdateManyWithoutBodyPartNestedInput
  }

  export type UserCreateWithoutUserCourseHistoryInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCourseHistoryInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCourseHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCourseHistoryInput, UserUncheckedCreateWithoutUserCourseHistoryInput>
  }

  export type CourseCreateWithoutUserCourseHistoryInput = {
    id?: string
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCoursesInput
    courseExercises?: CourseExerciseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUserCourseHistoryInput = {
    id?: string
    userId?: string | null
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseExercises?: CourseExerciseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUserCourseHistoryInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUserCourseHistoryInput, CourseUncheckedCreateWithoutUserCourseHistoryInput>
  }

  export type UserUpsertWithoutUserCourseHistoryInput = {
    update: XOR<UserUpdateWithoutUserCourseHistoryInput, UserUncheckedUpdateWithoutUserCourseHistoryInput>
    create: XOR<UserCreateWithoutUserCourseHistoryInput, UserUncheckedCreateWithoutUserCourseHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCourseHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCourseHistoryInput, UserUncheckedUpdateWithoutUserCourseHistoryInput>
  }

  export type UserUpdateWithoutUserCourseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCourseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutUserCourseHistoryInput = {
    update: XOR<CourseUpdateWithoutUserCourseHistoryInput, CourseUncheckedUpdateWithoutUserCourseHistoryInput>
    create: XOR<CourseCreateWithoutUserCourseHistoryInput, CourseUncheckedCreateWithoutUserCourseHistoryInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutUserCourseHistoryInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutUserCourseHistoryInput, CourseUncheckedUpdateWithoutUserCourseHistoryInput>
  }

  export type CourseUpdateWithoutUserCourseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCoursesNestedInput
    courseExercises?: CourseExerciseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUserCourseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseExercises?: CourseExerciseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutUserFavoritesInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserFavoritesInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFavoritesInput, UserUncheckedCreateWithoutUserFavoritesInput>
  }

  export type GymCreateWithoutUserFavoritesInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelCreateNestedManyWithoutGymInput
    reviews?: ReviewCreateNestedManyWithoutGymInput
  }

  export type GymUncheckedCreateWithoutUserFavoritesInput = {
    id?: string
    name: string
    address: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    phone?: string | null
    website?: string | null
    priceRange?: string | null
    description?: string | null
    isActive?: boolean
    facilityInfoCount?: number
    lastUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: GymFacilityUncheckedCreateNestedOneWithoutGymInput
    operatingHours?: GymOperatingHourUncheckedCreateNestedManyWithoutGymInput
    crowdLevels?: GymCrowdLevelUncheckedCreateNestedManyWithoutGymInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGymInput
  }

  export type GymCreateOrConnectWithoutUserFavoritesInput = {
    where: GymWhereUniqueInput
    create: XOR<GymCreateWithoutUserFavoritesInput, GymUncheckedCreateWithoutUserFavoritesInput>
  }

  export type UserUpsertWithoutUserFavoritesInput = {
    update: XOR<UserUpdateWithoutUserFavoritesInput, UserUncheckedUpdateWithoutUserFavoritesInput>
    create: XOR<UserCreateWithoutUserFavoritesInput, UserUncheckedCreateWithoutUserFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFavoritesInput, UserUncheckedUpdateWithoutUserFavoritesInput>
  }

  export type UserUpdateWithoutUserFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GymUpsertWithoutUserFavoritesInput = {
    update: XOR<GymUpdateWithoutUserFavoritesInput, GymUncheckedUpdateWithoutUserFavoritesInput>
    create: XOR<GymCreateWithoutUserFavoritesInput, GymUncheckedCreateWithoutUserFavoritesInput>
    where?: GymWhereInput
  }

  export type GymUpdateToOneWithWhereWithoutUserFavoritesInput = {
    where?: GymWhereInput
    data: XOR<GymUpdateWithoutUserFavoritesInput, GymUncheckedUpdateWithoutUserFavoritesInput>
  }

  export type GymUpdateWithoutUserFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUpdateManyWithoutGymNestedInput
    reviews?: ReviewUpdateManyWithoutGymNestedInput
  }

  export type GymUncheckedUpdateWithoutUserFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    facilityInfoCount?: IntFieldUpdateOperationsInput | number
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: GymFacilityUncheckedUpdateOneWithoutGymNestedInput
    operatingHours?: GymOperatingHourUncheckedUpdateManyWithoutGymNestedInput
    crowdLevels?: GymCrowdLevelUncheckedUpdateManyWithoutGymNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGymNestedInput
  }

  export type UserCreateWithoutEventsInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    courses?: CourseCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id?: string
    email?: string | null
    displayName?: string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    userPainProfiles?: UserPainProfileUncheckedCreateNestedManyWithoutUserInput
    userCourseHistory?: UserCourseHistoryUncheckedCreateNestedManyWithoutUserInput
    userFavorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    courses?: CourseUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    userPainProfiles?: UserPainProfileUncheckedUpdateManyWithoutUserNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutUserNestedInput
    userFavorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    gymId: string
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManyUserInput = {
    id?: string
    totalDurationMinutes: number
    painLevel?: number | null
    experienceLevel?: string | null
    bodyParts?: CourseCreatebodyPartsInput | string[]
    equipmentAvailable?: CourseCreateequipmentAvailableInput | string[]
    courseType?: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPainProfileCreateManyUserInput = {
    id?: string
    bodyPartId: string
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseHistoryCreateManyUserInput = {
    id?: string
    courseId: string
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFavoriteCreateManyUserInput = {
    id?: string
    gymId: string
    savedAt?: Date | string
    createdAt?: Date | string
  }

  export type EventCreateManyUserInput = {
    id?: string
    anonymousId?: string | null
    eventName: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: Date | string
    createdAt?: Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutReviewsNestedInput
    reviewTagMappings?: ReviewTagMappingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseExercises?: CourseExerciseUpdateManyWithoutCourseNestedInput
    userCourseHistory?: UserCourseHistoryUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseExercises?: CourseExerciseUncheckedUpdateManyWithoutCourseNestedInput
    userCourseHistory?: UserCourseHistoryUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    bodyParts?: CourseUpdatebodyPartsInput | string[]
    equipmentAvailable?: CourseUpdateequipmentAvailableInput | string[]
    courseType?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyPart?: BodyPartUpdateOneRequiredWithoutUserPainProfilesNestedInput
  }

  export type UserPainProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bodyPartId?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bodyPartId?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutUserCourseHistoryNestedInput
  }

  export type UserCourseHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gym?: GymUpdateOneRequiredWithoutUserFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gymId?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourCreateManyGymInput = {
    id?: string
    dayOfWeek: number
    openTime?: string | null
    closeTime?: string | null
    isClosed?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymCrowdLevelCreateManyGymInput = {
    id?: string
    timeSlot: string
    dayOfWeek?: number | null
    crowdLevel: string
    source?: string
    reportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyGymInput = {
    id?: string
    userId?: string | null
    comment?: string | null
    isAdminReview?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFavoriteCreateManyGymInput = {
    id?: string
    userId?: string | null
    savedAt?: Date | string
    createdAt?: Date | string
  }

  export type GymOperatingHourUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymOperatingHourUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    closeTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCrowdLevelUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCrowdLevelUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymCrowdLevelUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    crowdLevel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    reportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutReviewsNestedInput
    reviewTagMappings?: ReviewTagMappingUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewTagMappings?: ReviewTagMappingUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAdminReview?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutGymInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingCreateManyReviewTagInput = {
    id?: string
    reviewId: string
    createdAt?: Date | string
  }

  export type ReviewTagMappingUpdateWithoutReviewTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutReviewTagMappingsNestedInput
  }

  export type ReviewTagMappingUncheckedUpdateWithoutReviewTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingUncheckedUpdateManyWithoutReviewTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingCreateManyReviewInput = {
    id?: string
    reviewTagId: string
    createdAt?: Date | string
  }

  export type ReviewTagMappingUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewTag?: ReviewTagUpdateOneRequiredWithoutReviewTagMappingsNestedInput
  }

  export type ReviewTagMappingUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewTagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewTagMappingUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewTagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTemplateCreateManyBodyPartInput = {
    id?: string
    name: string
    description?: string | null
    intensityLevel?: number | null
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    difficultyScore?: number | null
    contraindications?: ExerciseTemplateCreatecontraindicationsInput | string[]
    instructions?: string | null
    precautions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPainProfileCreateManyBodyPartInput = {
    id?: string
    userId?: string | null
    painLevel?: number | null
    experienceLevel?: string | null
    equipmentAvailable?: UserPainProfileCreateequipmentAvailableInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseTemplateUpdateWithoutBodyPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUpdateManyWithoutExerciseTemplateNestedInput
    courseExercises?: CourseExerciseUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type ExerciseTemplateUncheckedUpdateWithoutBodyPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseEquipmentMappings?: ExerciseEquipmentMappingUncheckedUpdateManyWithoutExerciseTemplateNestedInput
    courseExercises?: CourseExerciseUncheckedUpdateManyWithoutExerciseTemplateNestedInput
  }

  export type ExerciseTemplateUncheckedUpdateManyWithoutBodyPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intensityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    difficultyScore?: NullableIntFieldUpdateOperationsInput | number | null
    contraindications?: ExerciseTemplateUpdatecontraindicationsInput | string[]
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    precautions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileUpdateWithoutBodyPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserPainProfilesNestedInput
  }

  export type UserPainProfileUncheckedUpdateWithoutBodyPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPainProfileUncheckedUpdateManyWithoutBodyPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    painLevel?: NullableIntFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentAvailable?: UserPainProfileUpdateequipmentAvailableInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingCreateManyEquipmentTypeInput = {
    id?: string
    exerciseTemplateId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type ExerciseEquipmentMappingUpdateWithoutEquipmentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplate?: ExerciseTemplateUpdateOneRequiredWithoutExerciseEquipmentMappingsNestedInput
  }

  export type ExerciseEquipmentMappingUncheckedUpdateWithoutEquipmentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingUncheckedUpdateManyWithoutEquipmentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingCreateManyExerciseTemplateInput = {
    id?: string
    equipmentTypeId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type CourseExerciseCreateManyExerciseTemplateInput = {
    id?: string
    courseId: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ExerciseEquipmentMappingUpdateWithoutExerciseTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentType?: EquipmentTypeUpdateOneRequiredWithoutExerciseEquipmentMappingsNestedInput
  }

  export type ExerciseEquipmentMappingUncheckedUpdateWithoutExerciseTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentTypeId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseEquipmentMappingUncheckedUpdateManyWithoutExerciseTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentTypeId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseUpdateWithoutExerciseTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutCourseExercisesNestedInput
  }

  export type CourseExerciseUncheckedUpdateWithoutExerciseTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseUncheckedUpdateManyWithoutExerciseTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseCreateManyCourseInput = {
    id?: string
    exerciseTemplateId: string
    section: string
    orderInSection: number
    durationMinutes?: number | null
    reps?: number | null
    sets?: number | null
    restSeconds?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type UserCourseHistoryCreateManyCourseInput = {
    id?: string
    userId?: string | null
    completedAt?: Date | string | null
    savedAt?: Date | string
    isFavorite?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseExerciseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTemplate?: ExerciseTemplateUpdateOneRequiredWithoutCourseExercisesNestedInput
  }

  export type CourseExerciseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseExerciseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseTemplateId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    orderInSection?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserCourseHistoryNestedInput
  }

  export type UserCourseHistoryUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseHistoryUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}